
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'automation-script' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}


/**
 * AI Tool Discovery Engine
 * 
 * Continuously searches the web for the best AI tools and automatically
 * integrates them into the automation systems.
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync, spawn } = require('child_process');
const EventEmitter = require('events');
const https = require('https');
const http = require('http');

class AIToolDiscoveryEngine extends EventEmitter {
  constructor() {
    super();
    
    this.config = {
      // Discovery sources
      sources: {
        github: {
          enabled: true,
          token: process.env.GITHUB_TOKEN,
          searchTerms: [
            'artificial-intelligence',
            'machine-learning',
            'ai-tools',
            'automation',
            'code-generation',
            'code-review',
            'performance-optimization',
            'security-scanning',
            'ux-enhancement',
            'database-optimization'
          ]
        },
        npm: {
          enabled: true,
          searchTerms: [
            'ai',
            'artificial-intelligence',
            'machine-learning',
            'automation',
            'code-generation',
            'optimization'
          ]
        },
        papersWithCode: {
          enabled: true,
          searchTerms: [
            'code generation',
            'program synthesis',
            'automated testing',
            'performance optimization',
            'security analysis'
          ]
        },
        arxiv: {
          enabled: true,
          searchTerms: [
            'code generation',
            'program synthesis',
            'automated testing',
            'performance optimization',
            'security analysis'
          ]
        },
        huggingface: {
          enabled: true,
          searchTerms: [
            'code-generation',
            'code-review',
            'optimization',
            'security',
            'automation'
          ]
        }
      },
      
      // Integration settings
      integration: {
        autoIntegrate: true,
        testBeforeIntegration: true,
        backupBeforeIntegration: true,
        maxToolsPerCycle: 5,
        minScore: 0.7
      },
      
      // Discovery settings
      discovery: {
        interval: 15 * 60 * 1000, // 15 minutes
        maxResultsPerSource: 20,
        filterDuplicates: true,
        prioritizeRecent: true
      },
      
      // Paths
      paths: {
        projectRoot: process.cwd(),
        logs: path.join(process.cwd(), 'logs'),
        reports: path.join(process.cwd(), 'reports'),
        tools: path.join(process.cwd(), 'ai-tools'),
        integrations: path.join(process.cwd(), 'integrations')
      }
    };
    
    this.isRunning = false;
    this.currentDiscovery = null;
    this.discoveryHistory = [];
    this.discoveredTools = new Map();
    this.integratedTools = new Map();
    this.stats = {
      totalDiscoveries: 0,
      successfulDiscoveries: 0,
      failedDiscoveries: 0,
      toolsDiscovered: 0,
      toolsIntegrated: 0,
      lastDiscovery: null
    };
    
    this.initializeDirectories();
  }

  async initializeDirectories() {
    const dirs = [
      this.config.paths.logs,
      this.config.paths.reports,
      this.config.paths.tools,
      this.config.paths.integrations
    ];

    for (const dir of dirs) {
      try {
        await fs.mkdir(dir, { recursive: true });
      } catch (error) {
        this.log('warn', `Failed to create directory ${dir}: ${error.message}`);
      }
    }
  }

  async start() {
    if (this.isRunning) {
      this.log('warn', 'AI Tool Discovery Engine is already running');
      return;
    }

    this.log('info', 'ðŸš€ Starting AI Tool Discovery Engine...');
    this.isRunning = true;

    // Start discovery loop
    this.startDiscoveryLoop();

    this.log('info', 'âœ… AI Tool Discovery Engine started successfully');
    this.emit('started');
  }

  async stop() {
    if (!this.isRunning) {
      this.log('warn', 'AI Tool Discovery Engine is not running');
      return;
    }

    this.log('info', 'ðŸ›‘ Stopping AI Tool Discovery Engine...');
    this.isRunning = false;

    if (this.discoveryTimer) {
      clearInterval(this.discoveryTimer);
    }

    this.log('info', 'âœ… AI Tool Discovery Engine stopped');
    this.emit('stopped');
  }

  startDiscoveryLoop() {
    this.discoveryTimer = setInterval(async () => {
      if (this.isRunning && !this.currentDiscovery) {
        await this.performDiscovery();
      }
    }, this.config.discovery.interval);
  }

  async performDiscovery() {
    try {
      this.currentDiscovery = {
        id: `discovery_${Date.now()}`,
        startTime: Date.now(),
        status: 'running'
      };

      this.log('info', 'ðŸ” Starting AI tool discovery...');

      const allTools = [];

      // Discover from GitHub
      if (this.config.sources.github.enabled) {
        const githubTools = await this.discoverFromGitHub();
        allTools.push(...githubTools);
      }

      // Discover from NPM
      if (this.config.sources.npm.enabled) {
        const npmTools = await this.discoverFromNPM();
        allTools.push(...npmTools);
      }

      // Discover from Papers with Code
      if (this.config.sources.papersWithCode.enabled) {
        const papersTools = await this.discoverFromPapersWithCode();
        allTools.push(...papersTools);
      }

      // Discover from ArXiv
      if (this.config.sources.arxiv.enabled) {
        const arxivTools = await this.discoverFromArXiv();
        allTools.push(...arxivTools);
      }

      // Discover from Hugging Face
      if (this.config.sources.huggingface.enabled) {
        const hfTools = await this.discoverFromHuggingFace();
        allTools.push(...hfTools);
      }

      // Filter and rank tools
      const filteredTools = this.filterTools(allTools);
      const rankedTools = this.rankTools(filteredTools);

      // Evaluate top tools
      const evaluatedTools = await this.evaluateTools(rankedTools.slice(0, this.config.integration.maxToolsPerCycle));

      // Integrate promising tools
      let integratedCount = 0;
      for (const tool of evaluatedTools) {
        if (tool.score >= this.config.integration.minScore) {
          const integrated = await this.integrateTool(tool);
          if (integrated) {
            integratedCount++;
          }
        }
      }

      this.currentDiscovery.status = 'completed';
      this.currentDiscovery.endTime = Date.now();
      this.currentDiscovery.results = {
        totalDiscovered: allTools.length,
        filtered: filteredTools.length,
        evaluated: evaluatedTools.length,
        integrated: integratedCount
      };

      this.discoveryHistory.push(this.currentDiscovery);
      this.stats.totalDiscoveries++;
      this.stats.successfulDiscoveries++;
      this.stats.toolsDiscovered += allTools.length;
      this.stats.toolsIntegrated += integratedCount;
      this.stats.lastDiscovery = Date.now();

      // Generate report
      await this.generateDiscoveryReport();

      this.log('info', `âœ… Discovery completed: ${allTools.length} discovered, ${integratedCount} integrated`);
      this.emit('discoveryCompleted', this.currentDiscovery);

    } catch (error) {
      this.log('error', `Discovery failed: ${error.message}`);
      this.stats.failedDiscoveries++;
      this.emit('discoveryFailed', error);
    } finally {
      this.currentDiscovery = null;
    }
  }

  async discoverFromGitHub() {
    const tools = [];
    
    try {
      for (const term of this.config.sources.github.searchTerms) {
        const searchResults = await this.searchGitHub(term);
        tools.push(...searchResults);
      }
    } catch (error) {
      this.log('warn', `GitHub discovery failed: ${error.message}`);
    }
    
    return tools;
  }

  async searchGitHub(term) {
    try {
      const url = `https://api.github.com/search/repositories?q=${encodeURIComponent(term)}&sort=stars&order=desc&per_page=${this.config.discovery.maxResultsPerSource}`;
      
      const response = await this.makeRequest(url, {
        headers: {
          'Authorization': `token ${this.config.sources.github.token}`,
          'User-Agent': 'AI-Tool-Discovery-Engine'
        }
      });
      
      const data = JSON.parse(response);
      return data.items.map(item => ({
        id: `github-${item.id}`,
        name: item.name,
        description: item.description,
        url: item.html_url,
        source: 'github',
        stars: item.stargazers_count,
        language: item.language,
        lastUpdated: item.updated_at,
        topics: item.topics || [],
        searchTerm: term
      }));
    } catch (error) {
      this.log('warn', `GitHub search failed for ${term}: ${error.message}`);
      return [];
    }
  }

  async discoverFromNPM() {
    const tools = [];
    
    try {
      for (const term of this.config.sources.npm.searchTerms) {
        const searchResults = await this.searchNPM(term);
        tools.push(...searchResults);
      }
    } catch (error) {
      this.log('warn', `NPM discovery failed: ${error.message}`);
    }
    
    return tools;
  }

  async searchNPM(term) {
    try {
      const url = `https://registry.npmjs.org/-/v1/search?text=${encodeURIComponent(term)}&size=${this.config.discovery.maxResultsPerSource}`;
      
      const response = await this.makeRequest(url);
      const data = JSON.parse(response);
      
      return data.objects.map(obj => ({
        id: `npm-${obj.package.name}`,
        name: obj.package.name,
        description: obj.package.description,
        url: obj.package.links.npm,
        source: 'npm',
        downloads: obj.package.downloads?.lastMonth || 0,
        version: obj.package.version,
        lastUpdated: obj.package.date,
        keywords: obj.package.keywords || [],
        searchTerm: term
      }));
    } catch (error) {
      this.log('warn', `NPM search failed for ${term}: ${error.message}`);
      return [];
    }
  }

  async discoverFromPapersWithCode(term) {
    const tools = [];
    
    try {
      for (const term of this.config.sources.papersWithCode.searchTerms) {
        const searchResults = await this.searchPapersWithCode(term);
        tools.push(...searchResults);
      }
    } catch (error) {
      this.log('warn', `Papers with Code discovery failed: ${error.message}`);
    }
    
    return tools;
  }

  async searchPapersWithCode(term) {
    try {
      const url = `https://paperswithcode.com/api/v1/papers/?search=${encodeURIComponent(term)}&items_per_page=${this.config.discovery.maxResultsPerSource}`;
      
      const response = await this.makeRequest(url);
      const data = JSON.parse(response);
      
      return data.results.map(paper => ({
        id: `papers-${paper.id}`,
        name: paper.title,
        description: paper.abstract,
        url: paper.url,
        source: 'papers-with-code',
        citations: paper.citation_count || 0,
        lastUpdated: paper.published,
        tags: paper.tags || [],
        searchTerm: term
      }));
    } catch (error) {
      this.log('warn', `Papers with Code search failed for ${term}: ${error.message}`);
      return [];
    }
  }

  async discoverFromArXiv(term) {
    const tools = [];
    
    try {
      for (const term of this.config.sources.arxiv.searchTerms) {
        const searchResults = await this.searchArXiv(term);
        tools.push(...searchResults);
      }
    } catch (error) {
      this.log('warn', `ArXiv discovery failed: ${error.message}`);
    }
    
    return tools;
  }

  async searchArXiv(term) {
    try {
      const url = `http://export.arxiv.org/api/query?search_query=all:${encodeURIComponent(term)}&start=0&max_results=${this.config.discovery.maxResultsPerSource}`;
      
      const response = await this.makeRequest(url);
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(response, 'text/xml');
      
      const entries = xmlDoc.getElementsByTagName('entry');
      const tools = [];
      
      for (const entry of entries) {
        const title = entry.getElementsByTagName('title')[0]?.textContent || '';
        const summary = entry.getElementsByTagName('summary')[0]?.textContent || '';
        const id = entry.getElementsByTagName('id')[0]?.textContent || '';
        const published = entry.getElementsByTagName('published')[0]?.textContent || '';
        
        tools.push({
          id: `arxiv-${id.split('/').pop()}`,
          name: title,
          description: summary,
          url: id,
          source: 'arxiv',
          citations: 0,
          lastUpdated: published,
          tags: [],
          searchTerm: term
        });
      }
      
      return tools;
    } catch (error) {
      this.log('warn', `ArXiv search failed for ${term}: ${error.message}`);
      return [];
    }
  }

  async discoverFromHuggingFace(term) {
    const tools = [];
    
    try {
      for (const term of this.config.sources.huggingface.searchTerms) {
        const searchResults = await this.searchHuggingFace(term);
        tools.push(...searchResults);
      }
    } catch (error) {
      this.log('warn', `Hugging Face discovery failed: ${error.message}`);
    }
    
    return tools;
  }

  async searchHuggingFace(term) {
    try {
      const url = `https://huggingface.co/api/models?search=${encodeURIComponent(term)}&limit=${this.config.discovery.maxResultsPerSource}`;
      
      const response = await this.makeRequest(url);
      const data = JSON.parse(response);
      
      return data.map(model => ({
        id: `hf-${model.id}`,
        name: model.id,
        description: model.description || '',
        url: `https://huggingface.co/${model.id}`,
        source: 'huggingface',
        downloads: model.downloads || 0,
        likes: model.likes || 0,
        lastUpdated: model.lastModified,
        tags: model.tags || [],
        searchTerm: term
      }));
    } catch (error) {
      this.log('warn', `Hugging Face search failed for ${term}: ${error.message}`);
      return [];
    }
  }

  filterTools(tools) {
    let filtered = tools;

    // Remove duplicates
    if (this.config.discovery.filterDuplicates) {
      const seen = new Set();
      filtered = filtered.filter(tool => {
        const key = `${tool.source}-${tool.name}`;
        if (seen.has(key)) {
          return false;
        }
        seen.add(key);
        return true;
      });
    }

    // Filter by relevance
    filtered = filtered.filter(tool => {
      const text = `${tool.name} ${tool.description}`.toLowerCase();
      const aiTerms = ['ai', 'artificial intelligence', 'machine learning', 'automation', 'code', 'optimization'];
      return aiTerms.some(term => text.includes(term));
    });

    return filtered;
  }

  rankTools(tools) {
    return tools.sort((a, b) => {
      let scoreA = 0;
      let scoreB = 0;

      // Source reliability
      const sourceScores = {
        'github': 1.0,
        'npm': 0.8,
        'papers-with-code': 0.9,
        'arxiv': 0.7,
        'huggingface': 0.9
      };

      scoreA += sourceScores[a.source] || 0.5;
      scoreB += sourceScores[b.source] || 0.5;

      // Popularity metrics
      if (a.stars) scoreA += Math.log(a.stars + 1) * 0.3;
      if (b.stars) scoreB += Math.log(b.stars + 1) * 0.3;

      if (a.downloads) scoreA += Math.log(a.downloads + 1) * 0.2;
      if (b.downloads) scoreB += Math.log(b.downloads + 1) * 0.2;

      if (a.citations) scoreA += Math.log(a.citations + 1) * 0.2;
      if (b.citations) scoreB += Math.log(b.citations + 1) * 0.2;

      // Recency
      if (this.config.discovery.prioritizeRecent) {
        const now = new Date();
        const aDate = new Date(a.lastUpdated);
        const bDate = new Date(b.lastUpdated);
        
        const aDays = (now - aDate) / (1000 * 60 * 60 * 24);
        const bDays = (now - bDate) / (1000 * 60 * 60 * 24);
        
        scoreA += Math.max(0, 1 - aDays / 365) * 0.1;
        scoreB += Math.max(0, 1 - bDays / 365) * 0.1;
      }

      return scoreB - scoreA;
    });
  }

  async evaluateTools(tools) {
    const evaluated = [];

    for (const tool of tools) {
      try {
        const evaluation = await this.evaluateTool(tool);
        evaluated.push({
          ...tool,
          score: evaluation.score,
          evaluation: evaluation
        });
      } catch (error) {
        this.log('warn', `Failed to evaluate tool ${tool.name}: ${error.message}`);
      }
    }

    return evaluated.sort((a, b) => b.score - a.score);
  }

  async evaluateTool(tool) {
    const evaluation = {
      score: 0,
      criteria: {}
    };

    // Relevance to automation
    const relevanceScore = this.calculateRelevanceScore(tool);
    evaluation.criteria.relevance = relevanceScore;
    evaluation.score += relevanceScore * 0.4;

    // Quality indicators
    const qualityScore = this.calculateQualityScore(tool);
    evaluation.criteria.quality = qualityScore;
    evaluation.score += qualityScore * 0.3;

    // Integration potential
    const integrationScore = this.calculateIntegrationScore(tool);
    evaluation.criteria.integration = integrationScore;
    evaluation.score += integrationScore * 0.3;

    return evaluation;
  }

  calculateRelevanceScore(tool) {
    const text = `${tool.name} ${tool.description}`.toLowerCase();
    let score = 0;

    // Automation-related terms
    const automationTerms = ['automation', 'automated', 'auto', 'continuous', 'monitoring'];
    automationTerms.forEach(term => {
      if (text.includes(term)) score += 0.2;
    });

    // AI-related terms
    const aiTerms = ['ai', 'artificial intelligence', 'machine learning', 'ml', 'neural'];
    aiTerms.forEach(term => {
      if (text.includes(term)) score += 0.15;
    });

    // Development-related terms
    const devTerms = ['code', 'development', 'programming', 'software', 'testing'];
    devTerms.forEach(term => {
      if (text.includes(term)) score += 0.1;
    });

    return Math.min(1, score);
  }

  calculateQualityScore(tool) {
    let score = 0;

    // Popularity indicators
    if (tool.stars && tool.stars > 100) score += 0.3;
    if (tool.downloads && tool.downloads > 1000) score += 0.2;
    if (tool.citations && tool.citations > 10) score += 0.2;

    // Source reliability
    const sourceScores = {
      'github': 0.3,
      'npm': 0.2,
      'papers-with-code': 0.3,
      'arxiv': 0.2,
      'huggingface': 0.3
    };
    score += sourceScores[tool.source] || 0.1;

    return Math.min(1, score);
  }

  calculateIntegrationScore(tool) {
    let score = 0;

    // API availability
    if (tool.url.includes('api') || tool.description.toLowerCase().includes('api')) {
      score += 0.3;
    }

    // Documentation
    if (tool.description.length > 100) {
      score += 0.2;
    }

    // Recent updates
    const lastUpdated = new Date(tool.lastUpdated);
    const daysSinceUpdate = (new Date() - lastUpdated) / (1000 * 60 * 60 * 24);
    if (daysSinceUpdate < 365) {
      score += 0.2;
    }

    // Language compatibility
    if (tool.language === 'JavaScript' || tool.language === 'TypeScript' || tool.language === 'Python') {
      score += 0.3;
    }

    return Math.min(1, score);
  }

  async integrateTool(tool) {
    try {
      this.log('info', `ðŸ”§ Integrating tool: ${tool.name}`);

      // Create backup if enabled
      if (this.config.integration.backupBeforeIntegration) {
        await this.createBackup();
      }

      // Generate integration code
      const integrationCode = await this.generateIntegrationCode(tool);

      // Test integration if enabled
      if (this.config.integration.testBeforeIntegration) {
        const testResult = await this.testIntegration(integrationCode);
        if (!testResult.success) {
          this.log('warn', `Integration test failed for ${tool.name}: ${testResult.error}`);
          return false;
        }
      }

      // Apply integration
      await this.applyIntegration(tool, integrationCode);

      // Store tool information
      this.integratedTools.set(tool.id, {
        ...tool,
        integratedAt: Date.now(),
        integrationCode
      });

      this.log('info', `âœ… Successfully integrated tool: ${tool.name}`);
      return true;

    } catch (error) {
      this.log('error', `Failed to integrate tool ${tool.name}: ${error.message}`);
      return false;
    }
  }

  async generateIntegrationCode(tool) {
    const template = `
// AI Tool Integration: ${tool.name}
// Source: ${tool.source}
// URL: ${tool.url}

const ${tool.name.replace(/[^a-zA-Z0-9]/g, '')} = {
  name: '${tool.name}',
  description: '${tool.description}',
  url: '${tool.url}',
  source: '${tool.source}',
  
  async process(input) {
    // Implementation for ${tool.name}
    // TODO: Implement actual integration
    return { result: '', success: true };
  },
  
  async test() {
    // Test implementation
    return { success: true };
  }
};

module.exports = ${tool.name.replace(/[^a-zA-Z0-9]/g, '')};
    `;

    return template;
  }

  async testIntegration(integrationCode) {
    try {
      // Create temporary test file
      const testFile = path.join(this.config.paths.integrations, 'test-integration.js');
      await fs.writeFile(testFile, integrationCode);
      
      // Test syntax
      execSync(`node -c ${testFile}`, { stdio: 'pipe' });
      
      // Clean up
      await fs.unlink(testFile);
      
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async applyIntegration(tool, integrationCode) {
    // Create integration file
    const integrationFile = path.join(this.config.paths.integrations, `${tool.name.replace(/[^a-zA-Z0-9]/g, '')}.js`);
    await fs.writeFile(integrationFile, integrationCode);
    
    // Update package.json if needed
    await this.updatePackageJson(tool);
    
    // Update automation systems
    await this.updateAutomationSystems(tool);
  }

  async updatePackageJson(tool) {
    try {
      const packagePath = path.join(this.config.paths.projectRoot, 'package.json');
      const packageJson = JSON.parse(await fs.readFile(packagePath, 'utf8'));
      
      // Add new script
      const scriptName = tool.name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
      packageJson.scripts[`ai-tool:${scriptName}`] = `node integrations/${tool.name.replace(/[^a-zA-Z0-9]/g, '')}.js`;
      
      await fs.writeFile(packagePath, JSON.stringify(packageJson, null, 2));
    } catch (error) {
      this.log('warn', `Failed to update package.json: ${error.message}`);
    }
  }

  async updateAutomationSystems(tool) {
    // Update automation systems to include the new tool
    const automationFile = path.join(this.config.paths.projectRoot, 'scripts', 'infinite-improvement-loop.cjs');
    
    try {
      let automationCode = await fs.readFile(automationFile, 'utf8');
      
      // Add import for new tool
      const importStatement = `const ${tool.name.replace(/[^a-zA-Z0-9]/g, '')} = require('../integrations/${tool.name.replace(/[^a-zA-Z0-9]/g, '')}.js');\n`;
      
      if (!automationCode.includes(importStatement)) {
        automationCode = importStatement + automationCode;
        await fs.writeFile(automationFile, automationCode);
      }
    } catch (error) {
      this.log('warn', `Failed to update automation systems: ${error.message}`);
    }
  }

  async createBackup() {
    const backupPath = path.join(this.config.paths.projectRoot, 'backups', `ai-tool-backup-${Date.now()}`);
    await fs.mkdir(backupPath, { recursive: true });
    
    // Backup relevant files
    const filesToBackup = ['package.json', 'scripts/', 'integrations/'];
    
    for (const file of filesToBackup) {
      try {
        const sourcePath = path.join(this.config.paths.projectRoot, file);
        const destPath = path.join(backupPath, file);
        
        if (await this.fileExists(sourcePath)) {
          await this.copyFile(sourcePath, destPath);
        }
      } catch (error) {
        this.log('warn', `Failed to backup ${file}: ${error.message}`);
      }
    }
  }

  async makeRequest(url, options = {}) {
    return new Promise((resolve, reject) => {
      const protocol = url.startsWith('https') ? https : http;
      
      const req = protocol.get(url, options, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => resolve(data));
      });
      
      req.on('error', reject);
      req.
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(10000,                                   ();
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
 => req.destroy());
    });
  }

  async generateDiscoveryReport() {
    const report = {
      timestamp: Date.now(),
      stats: this.stats,
      recentDiscoveries: this.discoveryHistory.slice(-10),
      discoveredTools: Array.from(this.discoveredTools.values()),
      integratedTools: Array.from(this.integratedTools.values()),
      summary: {
        totalDiscoveries: this.stats.totalDiscoveries,
        successRate: this.stats.successfulDiscoveries / this.stats.totalDiscoveries * 100,
        toolsDiscovered: this.stats.toolsDiscovered,
        toolsIntegrated: this.stats.toolsIntegrated,
        integrationRate: this.stats.toolsIntegrated / this.stats.toolsDiscovered * 100
      }
    };

    const reportPath = path.join(this.config.paths.reports, `ai-tool-discovery-${Date.now()}.json`);
    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
    
    this.log('info', `Generated discovery report: ${reportPath}`);
    return report;
  }

  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  async copyFile(source, dest) {
    const content = await fs.readFile(source);
    await fs.writeFile(dest, content);
  }

  log(level, message) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level.toUpperCase()}] [AI-DISCOVERY] ${message}`;
    
    logger.info(logMessage);
    
    // Save to log file
    const logPath = path.join(this.config.paths.logs, 'ai-tool-discovery.log');
    fs.appendFile(logPath, logMessage + '\n').catch(() => {});
  }

  getStatus() {
    return {
      isRunning: this.isRunning,
      currentDiscovery: this.currentDiscovery,
      stats: this.stats,
      discoveredTools: this.discoveredTools.size,
      integratedTools: this.integratedTools.size,
      lastDiscovery: this.stats.lastDiscovery
    };
  }
}

// CLI Interface
async function main() {
  const engine = new AIToolDiscoveryEngine();
  const command = process.argv[2];

  switch (command) {
    case 'start':
      await engine.start();
      break;
    case 'stop':
      await engine.stop();
      break;
    case 'status':
      logger.info(JSON.stringify(engine.getStatus(), null, 2));
      break;
    case 'discover':
      await engine.performDiscovery();
      break;
    default:
      logger.info('Usage: node ai-tool-discovery-engine.cjs [start|stop|status|discover]');
      break;
  }
}

if (require.main === module) {
  main().catch(error => {
    logger.error('AI Tool Discovery Engine failed:', error.message);
    process.exit(1);
  });
}

module.exports = AIToolDiscoveryEngine; 

// Graceful shutdown handling
process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Received SIGINT, shutting down gracefully...');
  // Add cleanup logic here
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\nðŸ›‘ Received SIGTERM, shutting down gracefully...');
  // Add cleanup logic here
  process.exit(0);
});

