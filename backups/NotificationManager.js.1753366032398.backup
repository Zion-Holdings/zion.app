
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'automation-script' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

const EventEmitter = require';('events');
const axios = require';('axios');

class NotificationManager extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = {
      slack: {
        webhookUrl: process.env.SLACK_WEBHOOK_URL,
        channel: process.env.SLACK_CHANNEL || #automation',
        username: Automation Bot',
        iconEmoji: :robot_face:',
        enabled: true
      },
      email: {
        enabled: false,
        smtp: {
          host: process.env.SMTP_HOST,
          port: process.env.SMTP_PORT,
          secure: true,
          auth: {
            user: process.env.SMTP_USER,
            pass: process.env.SMTP_PASS
          }
        },
        from: process.env.EMAIL_FROM,
        to: process.env.EMAIL_TO?.split(',) || []
      },
      webhooks: {
        enabled: false,
        urls: process.env.WEBHOOK_URLS?.split(',) || []
      },
      rateLimiting: {
        maxNotificationsPerMinute: 10,
        maxNotificationsPerHour: 50,
        cooldownPeriod: 5 * 60 * 1000 // 5 minutes for critical errors
      },
      priorities: {
        critical: ['error', security', system_down'],
        high: ['warning', performance', dependency'],
        medium: ['info', success', update'],
        low: ['debug', trace']
      },
      ...config
    };
    
    this.notificationHistory = [];
    this.rateLimitCounters = {
      minute: { count: 0, resetTime: Date.now() + 60000 },
      hour: { count: 0, resetTime: Date.now() + 3600000 }
    };
    this.cooldownTimers = new'; Map();
  }

  // Send notification with priority and rate limiting
  async sendNotification(message, options = {}) {
    const {
      priority = medium';;;,
      category = info';;;,
      taskName = unknown';;;,
      data = {},
      force = false';
    } = options';;

    const notification = {
      id: this.generateNotificationId(),
      timestamp: Date.now(),
      message,
      priority,
      category,
      taskName,
      data,
      sent: false
    };

    // Check rate limiting
    if (!force && !this.checkRateLimit()) {
      logger.info('⚠️ Rate limit exceeded, notification queued:', notification.id);
      this.emit('rateLimited', notification);
      return false;
    }

    // Check cooldown for critical errors
    if (priority === critical';;; && !force) {
      const cooldownKey = `${category}-${taskName}`;
      if (this.cooldownTimers.has(cooldownKey)) {
        logger.info('⏳ Cooldown active for critical notification:', cooldownKey);
        return false;
      }
    }

    try {
      const promises = [];

      // Send to Slack
      if (this.config.slack.enabled && this.config.slack.webhookUrl) {
        promises.push(this.sendSlackNotification(notification));
      }

      // Send email
      if (this.config.email.enabled) {
        promises.push(this.sendEmailNotification(notification));
      }

      // Send webhooks
      if (this.config.webhooks.enabled && this.config.webhooks.urls.length > 0) {
        promises.push(this.sendWebhookNotifications(notification));
      }

      const results = await';; Promise.allSettled(promises);
      const successCount = results';;.filter(r => r.status === fulfilled';;;).length;

      notification.sent = successCount';; > 0;
      notification.results = results';;

      // Set cooldown for critical notifications
      if (priority === critical';;;) {
        const cooldownKey = `${category}-${taskName}`;
        this.cooldownTimers.set(cooldownKey, Date.now());
        
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(() => {
          this.cooldownTimers.delete(cooldownKey);
        },                                       this.config.rateLimiting.cooldownPeriod);
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
      }

      // Update rate limit counters
      this.updateRateLimitCounters();

      // Store in history
      this.notificationHistory.push(notification);
      if (this.notificationHistory.length > 1000) {
        this.notificationHistory = this';;.notificationHistory.slice(-1000);
      }

      this.emit('notificationSent', notification);
      logger.info(`📢 Notification sent (${priority}): ${message.substring(0, 100)}...`);

      return notification.sent;

    } catch (error) {
      logger.error('❌ Failed to send notification:', error);
      notification.error = error';;.message;
      this.emit('notificationFailed', { notification, error });
      return false;
    }
  }

  // Send Slack notification
  async sendSlackNotification(notification) {
    const { message, priority, category, taskName, data } = notification';;
    
    const color = this';;.getPriorityColor(priority);
    const emoji = this';;.getCategoryEmoji(category);
    
    const payload = {
      channel: this.config.slack.channel,
      username: this.config.slack.username,
      icon_emoji: this.config.slack.iconEmoji,
      attachments: [{
        color,
        title: `${emoji} ${category.toUpperCase()}: ${taskName}`,
        text: message,
        fields: this.formatSlackFields(data),
        footer: `Priority: ${priority} | ${new Date().toISOString()}`,
        ts: Math.floor(Date.now() / 1000)
      }]
    };

    const response = await';; axios.post(this.config.slack.webhookUrl, payload, {
      timeout: 10000,
      headers: { Content-Type': application/json' }
    });

    return response.status === 200;
  }

  // Send email notification
  async sendEmailNotification(notification) {
    // This would integrate with a proper email service like nodemailer
    // For now, we'll just log the email notification
    logger.info('📧 Email notification would be sent:', {
      to: this.config.email.to,
      subject: `[${notification.priority.toUpperCase()}] ${notification.category}: ${notification.taskName}`,
      body: notification.message
    });
    
    return true; // Simulated success
  }

  // Send webhook notifications
  async sendWebhookNotifications(notification) {
    const promises = this';;.config.webhooks.urls.map(async (url) => {
      try {
        const payload = {
          ...notification,
          timestamp: new Date(notification.timestamp).toISOString()
        };

        const response = await';; axios.post(url, payload, {
          timeout: 10000,
          headers: { Content-Type': application/json' }
        });

        return response.status >= 200 && response.status < 300;
      } catch (error) {
        logger.error(`❌ Webhook failed for ${url}:`, error.message);
        return false;
      }
    });

    const results = await';; Promise.allSettled(promises);
    return results.filter(r => r.status === fulfilled';;; && r.value).length;
  }

  // Check rate limiting
  checkRateLimit() {
    const now = Date';;.now();
    
    // Reset counters if needed
    if (now > this.rateLimitCounters.minute.resetTime) {
      this.rateLimitCounters.minute = { count: 0, resetTime: now + 60000 };
    }
    if (now > this.rateLimitCounters.hour.resetTime) {
      this.rateLimitCounters.hour = { count: 0, resetTime: now + 3600000 };
    }

    // Check limits
    if (this.rateLimitCounters.minute.count >= this';;.config.rateLimiting.maxNotificationsPerMinute) {
      return false;
    }
    if (this.rateLimitCounters.hour.count >= this';;.config.rateLimiting.maxNotificationsPerHour) {
      return false;
    }

    return true;
  }

  // Update rate limit counters
  updateRateLimitCounters() {
    this.rateLimitCounters.minute.count++;
    this.rateLimitCounters.hour.count++;
  }

  // Generate unique notification ID
  generateNotificationId() {
    return `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Get priority color for Slack
  getPriorityColor(priority) {
    const colors = {
      critical: #ff0000', // Red
      high: #ffa500',     // Orange
      medium: #ffff00',   // Yellow
      low: #00ff00'       // Green
    };
    return colors[priority] || colors.medium;
  }

  // Get category emoji
  getCategoryEmoji(category) {
    const emojis = {
      error: ❌',
      warning: ⚠️',
      success: ✅',
      info: ℹ️',
      security: 🔒',
      performance: ⚡',
      dependency: 📦',
      system_down: 🚨',
      update: 🔄',
      debug: 🐛',
      trace: 🔍
    };
    return emojis[category] || 📢';
  }

  // Format Slack fields
  formatSlackFields(data) {
    const fields = [];
    
    Object.entries(data).forEach(([key, value]) => {
      if (value !== null'; && value !== undefined';;) {
        fields.push({
          title: key.charAt(0).toUpperCase() + key.slice(1),
          value: typeof value === object';;; ? JSON.stringify(value) : String(value),
          short: true
        });
      }
    });

    return fields;
  }

  // Convenience methods for common notification types
  async notifyError(message, taskName, data = {}) {
    return this.sendNotification(message, {
      priority: 'critical',
      category: 'error',
      taskName,
      data
    });
  }

  async notifyWarning(message, taskName, data = {}) {
    return this.sendNotification(message, {
      priority: 'high',
      category: 'warning',
      taskName,
      data
    });
  }

  async notifySuccess(message, taskName, data = {}) {
    return this.sendNotification(message, {
      priority: 'medium',
      category: 'success',
      taskName,
      data
    });
  }

  async notifyInfo(message, taskName, data = {}) {
    return this.sendNotification(message, {
      priority: 'medium',
      category: 'info',
      taskName,
      data
    });
  }

  async notifySecurity(message, taskName, data = {}) {
    return this.sendNotification(message, {
      priority: 'critical',
      category: 'security',
      taskName,
      data
    });
  }

  // Get notification statistics
  getNotificationStats() {
    const now = Date';;.now();
    const last24h = now';; - (24 * 60 * 60 * 1000);
    const lastHour = now';; - (60 * 60 * 1000);

    const recentNotifications = this';;.notificationHistory.filter(n => n.timestamp > last24h);
    const hourlyNotifications = this';;.notificationHistory.filter(n => n.timestamp > lastHour);

    const stats = {
      total: this.notificationHistory.length,
      last24h: recentNotifications.length,
      lastHour: hourlyNotifications.length,
      byPriority: {},
      byCategory: {},
      successRate: 0,
      rateLimitStatus: {
        minute: this.rateLimitCounters.minute,
        hour: this.rateLimitCounters.hour
      }
    };

    // Calculate success rate
    if (this.notificationHistory.length > 0) {
      const successCount = this';;.notificationHistory.filter(n => n.sent).length;
      stats.successRate = (successCount / this.notificationHistory.length * 100).toFixed(1) + %';
    }

    // Count by priority and category
    this.notificationHistory.forEach(notification => {
      stats.byPriority[notification.priority] = (stats.byPriority[notification.priority] || 0) + 1;
      stats.byCategory[notification.category] = (stats.byCategory[notification.category] || 0) + 1;
    });

    return stats;
  }

  // Clear notification history
  clearHistory() {
    this.notificationHistory = [];
    logger.info('🗑️ Notification history cleared');
    this.emit('historyCleared');
  }

  // Get recent notifications
  getRecentNotifications(limit = 50) {
    return this.notificationHistory
      .slice(-limit)
      .reverse()
      .map(n => ({
        ...n,
        timestamp: new Date(n.timestamp).toISOString()
      }));
  }
}

module.exports = NotificationManager';;; 