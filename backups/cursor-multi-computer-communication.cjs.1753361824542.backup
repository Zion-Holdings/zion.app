
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'automation-script' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}


/**
 * Cursor Multi-Computer Communication System
 *
 * This script enables continuous communication with Cursor IDE instances
 * across multiple computers for automated app improvement and real-time collaboration.
 */

const fs = require('fs')
const path = require('path')
const { execSync, spawn } = require('child_process')
const os = require('os')
const https = require('https')
const http = require('http')
const WebSocket = require('ws')
class CursorMultiComputerCommunication {
  constructor() {
    this.config = {
      cursorApiUrl: process.env.CURSOR_API_URL || 'https://api.cursor.sh',
      cursorApiKey: process.env.CURSOR_API_KEY,
      cursorWorkspaceId: process.env.CURSOR_WORKSPACE_ID,
      localPort: process.env.CURSOR_LOCAL_PORT || 3002,
      masterPort: process.env.CURSOR_MASTER_PORT || 3004,
      computerId: process.env.COMPUTER_ID || this.generateComputerId(),
      projectPath: process.cwd(),
      logFile: 'logs/cursor-communication.log',
    };

    this.activeConnections = new Map();
    this.chatHistory = [];
    this.isMaster = false;
    this.workerNodes = new Map();
    this.ensureLogDirectory();
  }

  generateComputerId() {
    return `computer_${os.hostname()}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  ensureLogDirectory() {
    const logDir = path.dirname(this.config.logFile);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
  }

  log(message, level = 'INFO') {
    const timestamp = new Date().toISOString()
const logEntry = `[${timestamp}] [${level}] [${this.config.computerId}] ${message}`;

    logger.info(logEntry);
    fs.appendFileSync(this.config.logFile, logEntry + '\n');
  }

  async initializeCursorCommunication() {
    this.log('üöÄ Initializing Cursor Multi-Computer Communication System...');

    try {
      // Check if Cursor is installed and running
      await this.checkCursorInstallation();

      // Initialize API connection
      await this.initializeCursorAPI();

      // Start local communication server
      await this.startLocalServer();

      // Connect to master node or become master
      await this.establishMasterConnection();

      // Start continuous monitoring
      this.startContinuousMonitoring();

      this.log(
        '‚úÖ Cursor Multi-Computer Communication System initialized successfully',
      );
    } catch (error) {
      this.log(
        `‚ùå Failed to initialize Cursor communication: ${error.message}`,
        'ERROR',
      );
      throw error;
    }
  }

  async checkCursorInstallation() {
    this.log('üîç Checking Cursor installation...');

    try {
      let cursorPath;
      switch (os.platform()) {
        case 'darwin':
          cursorPath = '/Applications/Cursor.app/Contents/MacOS/Cursor';
          break;
        case 'win32':
          cursorPath =
            'C:\\Users\\' +
            os.userInfo().username +
            '\\AppData\\Local\\Programs\\Cursor\\Cursor.exe';
          break;
        case 'linux':
          cursorPath = '/usr/bin/cursor';
          break;
        default:
          throw new Error(`Unsupported platform: ${os.platform()}`);
      }

      if (!fs.existsSync(cursorPath)) {
        throw new Error(`Cursor not found at: ${cursorPath}`);
      }

      this.log(`‚úÖ Cursor found at: ${cursorPath}`);
    } catch (error) {
      this.log(
        `‚ùå Cursor installation check failed: ${error.message}`,
        'ERROR',
      );
      throw error;
    }
  }

  async initializeCursorAPI() {
    this.log('üîå Initializing Cursor API connection...');

    if (!this.config.cursorApiKey) {
      this.log(
        '‚ö†Ô∏è Cursor API key not configured. Some features may be limited.',
      );
      return;
    }

    try {
      // Test API connection
      const testResponse = await this.makeCursorAPIRequest(
        'GET',
        '/workspaces',
      );
      this.log('‚úÖ Cursor API connection established');

      // Store workspace information
      if (testResponse.workspaces) {
        this.config.workspaces = testResponse.workspaces;
        this.log(`üìÅ Found ${testResponse.workspaces.length} workspaces`);
      }
    } catch (error) {
      this.log(
        `‚ùå Cursor API initialization failed: ${error.message}`,
        'ERROR',
      );
      // Don't throw error, continue with limited functionality
    }
  }

  async makeCursorAPIRequest(method, endpoint, data = null) {
    return new Promise((resolve, reject) => {
      const options = {
        hostname: new URL(this.config.cursorApiUrl).hostname,
        port: 443,
        path: endpoint,
        method: method,
        headers: {
          Authorization: `Bearer ${this.config.cursorApiKey}`,
          'Content-Type': 'application/json',
          'User-Agent': 'Cursor-Multi-Computer-Communication/1.0',
        },
      };

      if (data) {
        options.headers['Content-Length'] = Buffer.byteLength(
          JSON.stringify(data),
        );
      }

      const req = https.request(options, (res) => {
        let responseData = '';

        res.on('data', (chunk) => {
          responseData += chunk;
        });

        res.on('end', () => {
          try {
            const parsed = JSON.parse(responseData);
            resolve(parsed);
          } catch (error) {
            resolve(responseData);
          }
        });
      });

      req.on('error', (error) => {
        reject(error);
      });

      if (data) {
        req.write(JSON.stringify(data));
      }

      req.end();
    });
  }

  async startLocalServer() {
    this.log(
      `üåê Starting local communication server on port ${this.config.localPort}...`,
    );

    return new Promise((resolve, reject) => {
      this.localServer = http.createServer((req, res) => {
        this.handleLocalRequest(req, res);
      });

      this.localServer.listen(this.config.localPort, () => {
        this.log(`‚úÖ Local server started on port ${this.config.localPort}`);
        resolve();
      });

      this.localServer.on('error', (error) => {
        this.log(`‚ùå Local server error: ${error.message}`, 'ERROR');
        reject(error);
      });
    });
  }

  handleLocalRequest(req, res) {
    const { method, url } = req;

    this.log(`üì® Local request: ${method} ${url}`);

    let body = '';
    req.on('data', (chunk) => {
      body += chunk;
    });

    req.on('end', async () => {
      try {
        const response = await this.processLocalRequest(method, url, body);

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(response));
      } catch (error) {
        this.log(`‚ùå Local request error: ${error.message}`, 'ERROR');
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
  }

  async processLocalRequest(method, url, body) {
    const parsedUrl = new URL(url, `http://localhost:${this.config.localPort}`)
const path = parsedUrl.pathname;

    switch (path) {
      case '/status':
        return this.getStatus();

      case '/chat':
        if (method === 'POST') {
          const chatData = JSON.parse(body);
          return await this.triggerCursorChat(chatData);
        }
        break;

      case '/fix':
        if (method === 'POST') {
          const fixData = JSON.parse(body);
          return await this.applyCursorFix(fixData);
        }
        break;

      case '/monitor':
        return this.getMonitoringData();

      default:
        throw new Error(`Unknown endpoint: ${path}`);
    }
  }

  async establishMasterConnection() {
    this.log('üîó Establishing master node connection...');

    try {
      // Try to connect to existing master
      const masterConnection = await this.connectToMaster();

      if (masterConnection) {
        this.log('‚úÖ Connected to existing master node');
        this.isMaster = false;
        this.masterConnection = masterConnection;
      } else {
        // Become the master node
        this.log('üëë Becoming master node...');
        await this.startMasterNode();
        this.isMaster = true;
      }
    } catch (error) {
      this.log(`‚ùå Master connection failed: ${error.message}`, 'ERROR');
      // Continue as standalone node
    }
  }

  async connectToMaster() {
    return new Promise((resolve) => {
      const ws = new WebSocket(`ws://localhost:${this.config.masterPort}`);

      ws.on('open', () => {
        this.log('üîó Connected to master node');
        ws.send(
          JSON.stringify({
            type: 'register',
            computerId: this.config.computerId,
            capabilities: this.getCapabilities(),
          }),
        );
        resolve(ws);
      });

      ws.on('message', (data) => {
        this.handleMasterMessage(JSON.parse(data));
      });

      ws.on('error', (error) => {
        this.log(`‚ùå Master connection error: ${error.message}`, 'ERROR');
        resolve(null);
      });

      ws.on('close', () => {
        this.log('üîå Disconnected from master node');
        this.masterConnection = null;
      });

      // Timeout after 5 seconds
      
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(() => {
        if (!ws.readyState === WebSocket.OPEN) {
          resolve(null);
        }
      },                         5000);
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
    });
  }

  async startMasterNode() {
    this.log(`üëë Starting master node on port ${this.config.masterPort}...`);

    return new Promise((resolve, reject) => {
      this.masterServer = new WebSocket.Server({
        port: this.config.masterPort,
      });

      this.masterServer.on('connection', (ws) => {
        this.handleWorkerConnection(ws);
      });

      this.masterServer.on('listening', () => {
        this.log(`‚úÖ Master node started on port ${this.config.masterPort}`);
        resolve();
      });

      this.masterServer.on('error', (error) => {
        this.log(`‚ùå Master node error: ${error.message}`, 'ERROR');
        reject(error);
      });
    });
  }

  handleWorkerConnection(ws) {
    this.log('üîó New worker node connected');

    ws.on('message', (data) => {
      try {
        const message = JSON.parse(data);
        this.handleWorkerMessage(ws, message);
      } catch (error) {
        this.log(`‚ùå Invalid worker message: ${error.message}`, 'ERROR');
      }
    });

    ws.on('close', () => {
      this.log('üîå Worker node disconnected');
      // Remove from worker nodes
      for (const [computerId, worker] of this.workerNodes.entries()) {
        if (worker.ws === ws) {
          this.workerNodes.delete(computerId);
          break;
        }
      }
    });
  }

  handleWorkerMessage(ws, message) {
    this.log(`üì® Worker message: ${message.type}`);

    switch (message.type) {
      case 'register':
        this.workerNodes.set(message.computerId, {
          ws,
          capabilities: message.capabilities,
          connectedAt: new Date(),
        });
        this.log(`‚úÖ Worker registered: ${message.computerId}`);
        break;

      case 'chat_request':
        this.broadcastChatRequest(message);
        break;

      case 'fix_request':
        this.broadcastFixRequest(message);
        break;

      case 'status_update':
        this.broadcastStatusUpdate(message);
        break;

      default:
        this.log(`‚ö†Ô∏è Unknown worker message type: ${message.type}`);
    }
  }

  handleMasterMessage(message) {
    this.log(`üì® Master message: ${message.type}`);

    switch (message.type) {
      case 'chat_request':
        this.handleChatRequest(message);
        break;

      case 'fix_request':
        this.handleFixRequest(message);
        break;

      case 'status_request':
        this.sendStatusToMaster();
        break;

      default:
        this.log(`‚ö†Ô∏è Unknown master message type: ${message.type}`);
    }
  }

  async triggerCursorChat(chatData) {
    this.log(`üí¨ Triggering Cursor chat: ${chatData.category}`);

    try {
      if (this.isMaster) {
        // Broadcast to all worker nodes
        this.broadcastChatRequest(chatData);
      } else if (this.masterConnection) {
        // Send to master
        this.masterConnection.send(
          JSON.stringify({
            type: 'chat_request',
            ...chatData,
          }),
        );
      }

      // Also trigger locally
      const localResponse = await this.executeLocalCursorChat(chatData);

      return {
        success: true,
        localResponse,
        broadcasted: this.isMaster || this.masterConnection,
      };
    } catch (error) {
      this.log(`‚ùå Chat trigger failed: ${error.message}`, 'ERROR');
      return {
        success: false,
        error: error.message,
      };
    }
  }

  async executeLocalCursorChat(chatData) {
    // This would integrate with Cursor's local API or use AppleScript/automation
    this.log(`üí¨ Executing local Cursor chat: ${chatData.prompt}`);

    // For now, we'll simulate the chat execution
    return {
      chatId: `chat_${Date.now()}`,
      status: 'executed',
      timestamp: new Date().toISOString(),
    };
  }

  async applyCursorFix(fixData) {
    this.log(`üîß Applying Cursor fix: ${fixData.type}`);

    try {
      if (this.isMaster) {
        // Broadcast to all worker nodes
        this.broadcastFixRequest(fixData);
      } else if (this.masterConnection) {
        // Send to master
        this.masterConnection.send(
          JSON.stringify({
            type: 'fix_request',
            ...fixData,
          }),
        );
      }

      // Also apply locally
      const localResult = await this.executeLocalCursorFix(fixData);

      return {
        success: true,
        localResult,
        broadcasted: this.isMaster || this.masterConnection,
      };
    } catch (error) {
      this.log(`‚ùå Fix application failed: ${error.message}`, 'ERROR');
      return {
        success: false,
        error: error.message,
      };
    }
  }

  async executeLocalCursorFix(fixData) {
    this.log(`üîß Executing local Cursor fix: ${fixData.type}`);

    try {
      switch (fixData.type) {
        case 'lint':
          execSync('npm run lint: 'fix', { stdio: 'pipe' });
          break;
        case 'format':
          execSync('npm run format', { stdio: 'pipe' });
          break;
        case 'build':
          execSync('npm run build', { stdio: 'pipe' });
          break;
        case 'test':
          execSync('npm run test', { stdio: 'pipe' });
          break;
        default:
          throw new Error(`Unknown fix type: ${fixData.type}`);
      }

      return {
        fixId: `fix_${Date.now()}`,
        status: 'applied',
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      this.log(`‚ùå Local fix execution failed: ${error.message}`, 'ERROR');
      throw error;
    }
  }

  broadcastChatRequest(chatData) {
    this.log(
      `üì° Broadcasting chat request to ${this.workerNodes.size} worker nodes`,
    )
const message = JSON.stringify({
      type: 'chat_request',
      ...chatData,
    });

    for (const [computerId, worker] of this.workerNodes.entries()) {
      try {
        worker.ws.send(message);
      } catch (error) {
        this.log(
          `‚ùå Failed to send to worker ${computerId}: ${error.message}`,
          'ERROR',
        );
      }
    }
  }

  broadcastFixRequest(fixData) {
    this.log(
      `üì° Broadcasting fix request to ${this.workerNodes.size} worker nodes`,
    )
const message = JSON.stringify({
      type: 'fix_request',
      ...fixData,
    });

    for (const [computerId, worker] of this.workerNodes.entries()) {
      try {
        worker.ws.send(message);
      } catch (error) {
        this.log(
          `‚ùå Failed to send to worker ${computerId}: ${error.message}`,
          'ERROR',
        );
      }
    }
  }

  startContinuousMonitoring() {
    this.log('üîç Starting continuous monitoring...');

    // Monitor for issues every 30 seconds
    setInterval(async () => {
      try {
        await this.performHealthCheck();
        await this.checkForIssues();
        await this.updateStatus();
      } catch (error) {
        this.log(`‚ùå Monitoring cycle failed: ${error.message}`, 'ERROR');
      }
    }, 30000);

    this.log('‚úÖ Continuous monitoring started');
  }

  async performHealthCheck() {
    try {
      // Check if Cursor is still running
      const cursorRunning = await this.checkCursorRunning();

      // Check if local server is responding
      const serverHealthy = await this.checkLocalServerHealth();

      // Check if master connection is active
      const masterConnected =
        this.isMaster ||
        (this.masterConnection && this.masterConnection.readyState === 1);

      this.healthStatus = {
        cursorRunning,
        serverHealthy,
        masterConnected,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      this.log(`‚ùå Health check failed: ${error.message}`, 'ERROR');
    }
  }

  async checkCursorRunning() {
    try {
      if (os.platform() === 'darwin') {
        execSync('pgrep -f "Cursor.app"', { stdio: 'pipe' });
        return true;
      } else {
        execSync('tasklist /FI "IMAGENAME eq Cursor.exe"', { stdio: 'pipe' });
        return true;
      }
    } catch (error) {
      return false;
    }
  }

  async checkLocalServerHealth() {
    return new Promise((resolve) => {
      const req = http.request(
        `http://localhost:${this.config.localPort}/status`,
        (res) => {
          resolve(res.statusCode === 200);
        },
      );

      req.on('error', () => {
        resolve(false);
      });

      req.
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(5000,                         ();
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
 => {
        resolve(false);
      });

      req.end();
    });
  }

  async checkForIssues() {
    try {
      // Check for build issues
      try {
        execSync('npm run build', { stdio: 'pipe', timeout: 60000 });
      } catch (error) {
        await this.triggerCursorChat({
          category: 'build',
          prompt: `Build error detected: ${error.message}. Please help fix this build issue.`,
          priority: 'high',
        });
      }

      // Check for lint issues
      try {
        execSync('npm run lint', { stdio: 'pipe', timeout: 30000 });
      } catch (error) {
        await this.triggerCursorChat({
          category: 'lint',
          prompt: `Linting error detected: ${error.message}. Please help fix these code quality issues.`,
          priority: 'medium',
        });
      }
    } catch (error) {
      this.log(`‚ùå Issue check failed: ${error.message}`, 'ERROR');
    }
  }

  async updateStatus() {
    const status = {
      computerId: this.config.computerId,
      isMaster: this.isMaster,
      workerCount: this.workerNodes.size,
      healthStatus: this.healthStatus,
      timestamp: new Date().toISOString(),
    };

    if (this.masterConnection) {
      this.masterConnection.send(
        JSON.stringify({
          type: 'status_update',
          ...status,
        }),
      );
    }
  }

  getStatus() {
    return {
      computerId: this.config.computerId,
      isMaster: this.isMaster,
      workerCount: this.workerNodes.size,
      healthStatus: this.healthStatus,
      uptime: process.uptime(),
      timestamp: new Date().toISOString(),
    };
  }

  getMonitoringData() {
    return {
      chatHistory: this.chatHistory.slice(-10), // Last 10 chats
      activeConnections: this.activeConnections.size,
      workerNodes: Array.from(this.workerNodes.keys()),
      healthStatus: this.healthStatus,
    };
  }

  getCapabilities() {
    return {
      platform: os.platform(),
      nodeVersion: process.version,
      cursorInstalled: true,
      canExecuteCommands: true,
      canApplyFixes: true,
      canTriggerChats: true,
    };
  }

  async shutdown() {
    this.log('üõë Shutting down Cursor Multi-Computer Communication System...');

    try {
      // Close all connections
      if (this.masterConnection) {
        this.masterConnection.close();
      }

      if (this.masterServer) {
        this.masterServer.close();
      }

      if (this.localServer) {
        this.localServer.close();
      }

      // Close all worker connections
      for (const [computerId, worker] of this.workerNodes.entries()) {
        worker.ws.close();
      }

      this.log('‚úÖ Shutdown completed');
    } catch (error) {
      this.log(`‚ùå Shutdown error: ${error.message}`, 'ERROR');
    }
  }
}

// Export for use in other modules
module.exports = CursorMultiComputerCommunication;

// Main execution
if (require.main === module) {
  const communication = new CursorMultiComputerCommunication()
const command = process.argv[2];

  switch (command) {
    case 'start':
      communication
        .initializeCursorCommunication()
        .then(() => {
          logger.info(
            'üöÄ Cursor Multi-Computer Communication System is running',
          );

          // Keep the process alive
          process.on('SIGINT', async () => {
            logger.info('\nüõë Received SIGINT, shutting down...');
            await communication.shutdown();
            process.exit(0);
          });

          process.on('SIGTERM', async () => {
            logger.info('\nüõë Received SIGTERM, shutting down...');
            await communication.shutdown();
            process.exit(0);
          });
        })
        .catch((error) => {
          logger.error(`‚ùå Failed to start: ${error.message}`);
          process.exit(1);
        });
      break;

    case 'status':
      communication.getStatus().then(console.log);
      break;

    case 'chat':
      const chatData = {
        category: process.argv[3] || 'general',
        prompt: process.argv[4] || 'Please help improve this application',
        priority: process.argv[5] || 'medium',
      };
      communication.triggerCursorChat(chatData).then(console.log);
      break;

    case 'fix':
      const fixData = {
        type: process.argv[3] || 'lint',
        file: process.argv[4] || null,
      };
      communication.applyCursorFix(fixData).then(console.log);
      break;

    default:
      logger.info(`
Usage: node cursor-multi-computer-communication.cjs <command> [args]

Commands:
  start                    Start the communication system
  status                   Get current status
  chat <category> <prompt> [priority]  Trigger a Cursor chat
  fix <type> [file]        Apply a Cursor fix

Examples:
  node cursor-multi-computer-communication.cjs start
  node cursor-multi-computer-communication.cjs chat build "Fix build errors"
  node cursor-multi-computer-communication.cjs fix lint
      `);
  }
}
