
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'automation-script' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}


/**
 * Heal and Deploy System
 * Comprehensive system that fixes issues and triggers deployment
 */

const fs = require('fs')
const path = require('path')
const { execSync, spawn } = require('child_process')
const AutoFixSystem = require('./auto-fix-errors')
class HealAndDeploy {
  constructor() {
    this.logFile = logs/heal-and-deploy.log';    this.ensureLogDirectory();
    this.fixesApplied = [];
    this.deploymentStatus = null;
  }

  ensureLogDirectory() {
    const logDir = path.dirname(this.logFile);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
  }

  log(message, level = 'INFO') {'    const timestamp = new Date().toISOString()
const logMessage = `[${timestamp}] [${level}] ${message}`;
    logger.info(logMessage);
    fs.appendFileSync(this.logFile, logMessage + \n');  }

  async run() {
    this.log('Starting heal and deploy process...');    
    try {
      // Step 1: Pre-deployment health check
      await this.preDeploymentCheck();
      
      // Step 2: Apply auto-fixes
      await this.applyAutoFixes();
      
      // Step 3: Run quality checks
      await this.runQualityChecks();
      
      // Step 4: Build the application
      await this.buildApplication();
      
      // Step 5: Run tests
      await this.runTests();
      
      // Step 6: Deploy
      await this.deploy();
      
      // Step 7: Post-deployment verification
      await this.postDeploymentVerification();
      
      this.log('Heal and deploy process completed successfully');      
    } catch (error) {
      this.log(`Heal and deploy process failed: ${error.message}`, ERROR');      throw error;
    }
  }

  async preDeploymentCheck() {
    this.log('Running pre-deployment health check...')
const checks = [
      this.checkEnvironmentVariables(),
      this.checkDependencies(),
      this.checkConfiguration(),
      this.checkGitStatus()
    ]
const results = await Promise.allSettled(checks);
    
    results.forEach((result, index) => {
      if (result.status === 'rejected') {        this.log(`Pre-deployment check ${index + 1} failed: ${result.reason}`, ERROR');      }
    });
  }

  async checkEnvironmentVariables() {
    this.log('Checking environment variables...')
const requiredEnvVars = [
      NEXT_PUBLIC_SUPABASE_URL',NEXT_PUBLIC_SUPABASE_ANON_KEY',NEXT_PUBLIC_REOWN_PROJECT_ID''    ]
const missingVars = [];
    
    for (const envVar of requiredEnvVars) {
      if (!process.env[envVar]) {
        missingVars.push(envVar);
      }
    }

    if (missingVars.length > 0) {
      this.log(`Missing environment variables: ${missingVars.join(', )}`, WARN');      
      // Create or update .env.local with placeholders
      const envContent = `# Auto-generated environment file
NEXT_PUBLIC_SUPABASE_URL=${process.env.NEXT_PUBLIC_SUPABASE_URL || your_supabase_url_here'}NEXT_PUBLIC_SUPABASE_ANON_KEY=${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || your_supabase_anon_key_here'}NEXT_PUBLIC_REOWN_PROJECT_ID=${process.env.NEXT_PUBLIC_REOWN_PROJECT_ID || your_reown_project_id_here'}`;
      fs.writeFileSync('.env.local', envContent);      this.log('Created .env.local file with available values');    } else {
      this.log('All required environment variables are set');    }
  }

  async checkDependencies() {
    this.log('Checking dependencies...');    
    try {
      // Check for outdated packages
      const outdatedOutput = execSync('npm outdated --json', { encoding: 'utf8', stdio: 'pipe' });      const outdated = JSON.parse(outdatedOutput);
      
      if (Object.keys(outdated).length > 0) {
        this.log('Outdated dependencies found', WARN');        this.log(`Outdated packages: ${Object.keys(outdated).join(', )}`);      } else {
        this.log('All dependencies are up to date');      }
    } catch (error) {
      // npm outdated exits with code 1 when there are outdated packages
      this.log('Dependencies check completed');    }
  }

  async checkConfiguration() {
    this.log('Checking configuration files...');    
    // Check tsconfig.json
    if (fs.existsSync('tsconfig.json')) {'      try {
        const tsConfig = JSON.parse(fs.readFileSync('tsconfig.json', 'utf8'));        
        if (!tsConfig.compilerOptions) {
          this.log('tsconfig.json missing compilerOptions', WARN');        }
        
        if (!tsConfig.compilerOptions.strict) {
          this.log('TypeScript strict mode is disabled', WARN');        }
      } catch (error) {
        this.log('Invalid tsconfig.json', ERROR');      }
    }
    
    // Check package.json
    try {
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));      
      if (!packageJson.scripts || !packageJson.scripts.build) {
        this.log('Missing build script in package.json', ERROR');      }
    } catch (error) {
      this.log('Invalid package.json', ERROR');    }
  }

  async checkGitStatus() {
    this.log('Checking git status...');    
    try {
      const status = execSync('git status --porcelain', { encoding: 'utf8' });      
      if (status.trim()) {
        this.log('Uncommitted changes detected', WARN');        this.log('Changes:', status);      } else {
        this.log('Working directory is clean');      }
    } catch (error) {
      this.log('Git status check failed', ERROR');    }
  }

  async applyAutoFixes() {
    this.log('Applying auto-fixes...');    
    try {
      const autoFix = new AutoFixSystem();
      await autoFix.run();
      
      if (autoFix.fixesApplied && autoFix.fixesApplied.length > 0) {
        this.fixesApplied.push(...autoFix.fixesApplied);
      }
      
      this.log('Auto-fixes applied successfully');    } catch (error) {
      this.log(`Auto-fix failed: ${error.message}`, ERROR');      throw error;
    }
  }

  async runQualityChecks() {
    this.log('Running quality checks...')
const checks = [
      this.runLinting(),
      this.runTypeCheck(),
      this.runSecurityAudit()
    ]
const results = await Promise.allSettled(checks);
    
    let hasFailures = false;
    results.forEach((result, index) => {
      if (result.status === rejected' || result.value === false) {        this.log(`Quality check ${index + 1} failed`, ERROR');        hasFailures = true;
      }
    });

    if (hasFailures) {
      throw new Error('Quality checks failed');    }
  }

  async runLinting() {
    try {
      this.log('Running ESLint...');      execSync('npm run lint: 'fix', { stdio: 'inherit' });      this.log('ESLint passed');      return true;
    } catch (error) {
      this.log('ESLint failed', ERROR');      return false;
    }
  }

  async runTypeCheck() {
    try {
      this.log('Running TypeScript type check...');      execSync('npm run type-check', { stdio: 'inherit' });      this.log('TypeScript type check passed');      return true;
    } catch (error) {
      this.log('TypeScript type check failed', ERROR');      return false;
    }
  }

  async runSecurityAudit() {
    try {
      this.log('Running security audit...');      execSync('npm audit --audit-level='moderate', { stdio: 'inherit' });      this.log('Security audit passed');      return true;
    } catch (error) {
      this.log('Security audit failed', ERROR');      return false;
    }
  }

  async buildApplication() {
    this.log('Building application...');    
    return new Promise((resolve, reject) => {
      const buildProcess = spawn('npm', ['run', build'], {'        stdio: ['pipe', pipe', pipe'],        timeout: 300000 // 5 minutes
      });

      let output = ;      let errorOutput = ;
      buildProcess.stdout.on('data', (data) => {'        output += data.toString();
        process.stdout.write(data);
      });

      buildProcess.stderr.on('data', (data) => {'        errorOutput += data.toString();
        process.stderr.write(data);
      });

      buildProcess.on('close', (code) => {'        if (code === 0) {
          this.log('Build completed successfully');          resolve();
        } else {
          this.log(`Build failed with code ${code}`, ERROR');          reject(new Error(`Build failed: ${errorOutput}`));
        }
      });

      buildProcess.on('error', (error) => {'        this.log(`Build process error: ${error.message}`, ERROR');        reject(error);
      });
    });
  }

  async runTests() {
    this.log('Running tests...');    
    try {
      execSync('npm test', { stdio: 'inherit' });      this.log('Tests passed');    } catch (error) {
      this.log('Tests failed', ERROR');      throw error;
    }
  }

  async deploy() {
    this.log('Starting deployment...');    
    try {
      // Commit changes if any fixes were applied
      if (this.fixesApplied.length > 0) {
        await this.commitChanges();
      }
      
      // Trigger deployment
      await this.triggerDeployment();
      
      this.log('Deployment initiated successfully');    } catch (error) {
      this.log(`Deployment failed: ${error.message}`, ERROR');      throw error;
    }
  }

  async commitChanges() {
    try {
      const commitMessage = `Auto-heal: Applied ${this.fixesApplied.length} fixes\n\n${this.fixesApplied.map(fix => `- ${fix}`).join('\n')}`;      
      execSync('git add .', { stdio: 'inherit' });      execSync(`git commit -m "${commitMessage}"`, { stdio: 'inherit' });      execSync('git push', { stdio: 'inherit' });      
      this.log('Changes committed and pushed successfully');    } catch (error) {
      this.log(`Failed to commit changes: ${error.message}`, ERROR');      throw error;
    }
  }

  async triggerDeployment() {
    try {
      // Try Netlify CLI first
      try {
        execSync('netlify --version', { stdio: 'pipe' });        execSync('netlify deploy --prod', { stdio: 'inherit' });        this.log('Deployment triggered via Netlify CLI');        this.deploymentStatus = netlify-cli';      } catch (netlifyError) {
        // Fallback to git push for Netlify auto-deploy
        this.log('Netlify CLI not available, using git push for auto-deploy');        execSync('git push', { stdio: 'inherit' });        this.log('Git push completed, Netlify auto-deploy should trigger');        this.deploymentStatus = git-push';      }
    } catch (error) {
      this.log(`Failed to trigger deployment: ${error.message}`, ERROR');      throw error;
    }
  }

  async postDeploymentVerification() {
    this.log('Running post-deployment verification...');    
    // Wait a bit for deployment to start
    await new Promise(resolve => 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(resolve,                10000);
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
);
    
    try {
      // Check if the site is accessible
      const response = await fetch('https://ziontechgroup.netlify.app/api/health');      
      if (response.ok) {
        this.log('Post-deployment verification passed');      } else {
        this.log('Post-deployment verification failed', WARN');      }
    } catch (error) {
      this.log('Post-deployment verification failed', WARN');    }
  }

  getDeploymentStatus() {
    return {
      fixesApplied: this.fixesApplied,
      deploymentStatus: this.deploymentStatus,
      timestamp: new Date().toISOString()
    };
  }
}

// Run the heal and deploy system
if (require.main === module) {
  const healer = new HealAndDeploy();
  
  healer.run().catch(error => {
    logger.error('Heal and deploy failed:', error);    process.exit(1);
  });
}

module.exports = HealAndDeploy; 

// Graceful shutdown handling
process.on('SIGINT', () => {
  console.log('\n🛑 Received SIGINT, shutting down gracefully...');
  // Add cleanup logic here
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\n🛑 Received SIGTERM, shutting down gracefully...');
  // Add cleanup logic here
  process.exit(0);
});

