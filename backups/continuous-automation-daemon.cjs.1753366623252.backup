
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'automation-script' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}


/**
 * Zion App - Continuous Automation Daemon
 *
 * Runs the automated improvement system continuously in the background
 * with automatic restart capabilities and 24/7 operation
 */

const fs = require('fs')
const path = require('path')
const { spawn, execSync } = require('child_process')
const os = require('os');

// Configuration
const CONFIG = {
  // Daemon settings
  DAEMON: {
    NAME: 'zion-automation-daemon',
    LOG_FILE: 'logs/automation-daemon.log',
    PID_FILE: 'logs/automation-daemon.pid',
    RESTART_DELAY: 5000, // 5 seconds
    MAX_RESTARTS: 10,
    RESTART_WINDOW: 60000, // 1 minute
    HEALTH_CHECK_INTERVAL: 30000, // 30 seconds
  },

  // Services to manage
  SERVICES: [
    {
      name: 'ai-delegation-master',
      command: 'npm run ai-delegate: 'master',
      port: 3002,
      healthCheck: 'http://localhost:3007/api/nodes/status',
    },
    {
      name: 'automated-improvement-pipeline',
      command: 'node scripts/automated-improvement-pipeline.cjs',
      port: 3006,
      healthCheck: 'http://localhost:3006/api/status',
    },
    {
      name: 'cursor-ai-delegator',
      command: 'node scripts/cursor-ai-delegator.cjs',
      port: 3005,
      healthCheck: 'http://localhost:3007/api/status',
    },
  ],

  // Monitoring
  MONITORING: {
    ENABLED: true,
    METRICS_FILE: 'logs/automation-metrics.json',
    ALERT_EMAIL: process.env.ALERT_EMAIL,
    SLACK_WEBHOOK: process.env.SLACK_WEBHOOK,
  },
}
class ContinuousAutomationDaemon {
  constructor() {
    this.isRunning = false;
    this.services = new Map();
    this.restartCounts = new Map();
    this.lastRestarts = new Map();
    this.metrics = {
      startTime: Date.now(),
      totalRestarts: 0,
      services: {},
    };

    // Initialize service tracking
    CONFIG.SERVICES.forEach((service) => {
      this.restartCounts.set(service.name, 0);
      this.lastRestarts.set(service.name, []);
      this.metrics.services[service.name] = {
        startCount: 0,
        restartCount: 0,
        lastStart: null,
        lastRestart: null,
        uptime: 0,
      };
    });
  }

  /**
   * Start the daemon
   */
  async start() {
    logger.info('üöÄ Starting Zion Automation Daemon...');

    // Create log directory
    const logDir = path.dirname(CONFIG.DAEMON.LOG_FILE);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }

    // Write PID file
    fs.writeFileSync(CONFIG.DAEMON.PID_FILE, process.pid.toString());

    this.isRunning = true;

    // Start all services
    await this.startAllServices();

    // Start monitoring
    this.startMonitoring();

    // Start health checks
    this.startHealthChecks();

    // Start metrics collection
    this.startMetricsCollection();

    logger.info('‚úÖ Zion Automation Daemon started successfully');
    logger.info(`üìä PID: ${process.pid}`);
    logger.info(`üìù Logs: ${CONFIG.DAEMON.LOG_FILE}`);
    logger.info(`üìà Metrics: ${CONFIG.MONITORING.METRICS_FILE}`);

    // Log startup
    this.log('DAEMON_STARTED', 'Zion Automation Daemon started successfully');
  }

  /**
   * Start all services
   */
  async startAllServices() {
    logger.info('üîß Starting all automation services...');

    for (const serviceConfig of CONFIG.SERVICES) {
      await this.startService(serviceConfig);
    }

    logger.info('‚úÖ All services started');
  }

  /**
   * Start a single service
   */
  async startService(serviceConfig) {
    try {
      logger.info(`üöÄ Starting service: ${serviceConfig.name}`);

      // Check if service is already running
      if (this.services.has(serviceConfig.name)) {
        logger.info(`‚ö†Ô∏è  Service ${serviceConfig.name} is already running`);
        return;
      }

      // Start the service
      const service = spawn('bash', ['-c', serviceConfig.command], {
        stdio: ['pipe', 'pipe', 'pipe'],
        detached: false,
      });

      // Track the service
      this.services.set(serviceConfig.name, {
        process: service,
        config: serviceConfig,
        startTime: Date.now(),
        status: 'starting',
      });

      // Update metrics
      this.metrics.services[serviceConfig.name].startCount++;
      this.metrics.services[serviceConfig.name].lastStart = Date.now();

      // Handle service output
      service.stdout.on('data', (data) => {
        this.logService(serviceConfig.name, 'STDOUT', data.toString());
      });

      service.stderr.on('data', (data) => {
        this.logService(serviceConfig.name, 'STDERR', data.toString());
      });

      // Handle service exit
      service.on('exit', (code, signal) => {
        this.handleServiceExit(serviceConfig.name, code, signal);
      });

      // Handle service error
      service.on('error', (error) => {
        this.handleServiceError(serviceConfig.name, error);
      });

      // Wait a moment for service to start
      await this.sleep(2000);

      // Check if service started successfully
      if (service.exitCode === null) {
        this.services.get(serviceConfig.name).status = 'running';
        logger.info(`‚úÖ Service ${serviceConfig.name} started successfully`);
        this.log(
          'SERVICE_STARTED',
          `Service ${serviceConfig.name} started successfully`,
        );
      } else {
        throw new Error(
          `Service failed to start with exit code ${service.exitCode}`,
        );
      }
    } catch (error) {
      logger.error(
        `‚ùå Failed to start service ${serviceConfig.name}:`,
        error.message,
      );
      this.log(
        'SERVICE_START_FAILED',
        `Failed to start service ${serviceConfig.name}: ${error.message}`,
      );

      // Schedule restart
      this.scheduleServiceRestart(serviceConfig.name);
    }
  }

  /**
   * Handle service exit
   */
  handleServiceExit(serviceName, code, signal) {
    logger.info(
      `üîÑ Service ${serviceName} exited with code ${code} and signal ${signal}`,
    );
    this.log(
      'SERVICE_EXIT',
      `Service ${serviceName} exited with code ${code} and signal ${signal}`,
    )
const service = this.services.get(serviceName);
    if (service) {
      service.status = 'exited';
      service.exitCode = code;
      service.exitSignal = signal;
      service.exitTime = Date.now();

      // Update metrics
      this.metrics.services[serviceName].uptime +=
        Date.now() - service.startTime;

      // Remove from active services
      this.services.delete(serviceName);

      // Schedule restart if daemon is still running
      if (this.isRunning) {
        this.scheduleServiceRestart(serviceName);
      }
    }
  }

  /**
   * Handle service error
   */
  handleServiceError(serviceName, error) {
    logger.error(`‚ùå Service ${serviceName} error:`, error.message);
    this.log('SERVICE_ERROR', `Service ${serviceName} error: ${error.message}`);

    // Schedule restart
    this.scheduleServiceRestart(serviceName);
  }

  /**
   * Schedule service restart
   */
  scheduleServiceRestart(serviceName) {
    const serviceConfig = CONFIG.SERVICES.find((s) => s.name === serviceName);
    if (!serviceConfig) return;

    // Check restart limits
    const restartCount = this.restartCounts.get(serviceName) || 0
const lastRestarts = this.lastRestarts.get(serviceName) || []
const now = Date.now();

    // Remove old restarts outside the window
    const recentRestarts = lastRestarts.filter(
      (time) => now - time < CONFIG.DAEMON.RESTART_WINDOW,
    );
    this.lastRestarts.set(serviceName, recentRestarts);

    if (recentRestarts.length >= CONFIG.DAEMON.MAX_RESTARTS) {
      logger.error(
        `‚ùå Service ${serviceName} exceeded restart limit. Stopping restarts.`,
      );
      this.log(
        'SERVICE_RESTART_LIMIT',
        `Service ${serviceName} exceeded restart limit`,
      );
      this.sendAlert(
        `Service ${serviceName} exceeded restart limit and will not be restarted`,
      );
      return;
    }

    // Schedule restart
    
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(async () => {
      if (this.isRunning) {
        logger.info(`üîÑ Restarting service: ${serviceName}`);
        this.log('SERVICE_RESTART',                                         `Restarting service ${serviceName}`);
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;

        // Update restart tracking
        this.restartCounts.set(serviceName, restartCount + 1);
        recentRestarts.push(now);
        this.lastRestarts.set(serviceName, recentRestarts);

        // Update metrics
        this.metrics.services[serviceName].restartCount++;
        this.metrics.services[serviceName].lastRestart = now;
        this.metrics.totalRestarts++;

        // Restart the service
        await this.startService(serviceConfig);
      }
    }, CONFIG.DAEMON.RESTART_DELAY);
  }

  /**
   * Start monitoring
   */
  startMonitoring() {
    if (!CONFIG.MONITORING.ENABLED) return;

    logger.info('üìä Starting monitoring...');

    setInterval(() => {
      this.collectMetrics();
    }, 60000); // Every minute

    setInterval(() => {
      this.saveMetrics();
    }, 300000); // Every 5 minutes
  }

  /**
   * Start health checks
   */
  startHealthChecks() {
    logger.info('üíö Starting health checks...');

    setInterval(async () => {
      for (const serviceConfig of CONFIG.SERVICES) {
        await this.checkServiceHealth(serviceConfig);
      }
    }, CONFIG.DAEMON.HEALTH_CHECK_INTERVAL);
  }

  /**
   * Check service health
   */
  async checkServiceHealth(serviceConfig) {
    try {
      const response = await fetch(serviceConfig.healthCheck, {
        method: 'GET',
        timeout: 5000,
      });

      if (response.ok) {
        const service = this.services.get(serviceConfig.name);
        if (service && service.status === 'running') {
          // Service is healthy
          return;
        }
      }

      // Service is unhealthy, restart it
      logger.warn(`‚ö†Ô∏è  Service ${serviceConfig.name} health check failed`);
      this.log(
        'SERVICE_UNHEALTHY',
        `Service ${serviceConfig.name} health check failed`,
      )
const service = this.services.get(serviceConfig.name);
      if (service) {
        service.process.kill('SIGTERM');
      }
    } catch (error) {
      logger.warn(
        `‚ö†Ô∏è  Health check failed for ${serviceConfig.name}:`,
        error.message,
      );
    }
  }

  /**
   * Start metrics collection
   */
  startMetricsCollection() {
    logger.info('üìà Starting metrics collection...');

    setInterval(() => {
      this.updateServiceMetrics();
    }, 10000); // Every 10 seconds
  }

  /**
   * Update service metrics
   */
  updateServiceMetrics() {
    for (const [serviceName, service] of this.services) {
      if (service.status === 'running') {
        const uptime = Date.now() - service.startTime;
        this.metrics.services[serviceName].uptime = uptime;
      }
    }
  }

  /**
   * Collect metrics
   */
  collectMetrics() {
    const metrics = {
      timestamp: Date.now(),
      daemon: {
        uptime: Date.now() - this.metrics.startTime,
        isRunning: this.isRunning,
        activeServices: this.services.size,
        totalServices: CONFIG.SERVICES.length,
      },
      services: this.metrics.services,
      system: {
        memory: process.memoryUsage(),
        cpu: os.loadavg(),
        uptime: os.uptime(),
      },
    };

    this.metrics = { ...this.metrics, ...metrics };
  }

  /**
   * Save metrics to file
   */
  saveMetrics() {
    try {
      const metricsDir = path.dirname(CONFIG.MONITORING.METRICS_FILE);
      if (!fs.existsSync(metricsDir)) {
        fs.mkdirSync(metricsDir, { recursive: true });
      }

      fs.writeFileSync(
        CONFIG.MONITORING.METRICS_FILE,
        JSON.stringify(this.metrics, null, 2),
      );
    } catch (error) {
      logger.error('‚ùå Failed to save metrics:', error.message);
    }
  }

  /**
   * Send alert
   */
  sendAlert(message) {
    logger.info(`üö® ALERT: ${message}`);

    // Send to Slack if configured
    if (CONFIG.MONITORING.SLACK_WEBHOOK) {
      this.sendSlackAlert(message);
    }

    // Send email if configured
    if (CONFIG.MONITORING.ALERT_EMAIL) {
      this.sendEmailAlert(message);
    }
  }

  /**
   * Send Slack alert
   */
  async sendSlackAlert(message) {
    try {
      await fetch(CONFIG.MONITORING.SLACK_WEBHOOK, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: `üö® Zion Automation Alert: ${message}`,
          username: 'Zion Automation Daemon',
          icon_emoji: ':robot_face:',
        }),
      });
    } catch (error) {
      logger.error('‚ùå Failed to send Slack alert:', error.message);
    }
  }

  /**
   * Send email alert
   */
  async sendEmailAlert(message) {
    // Implementation would use a mail service
    logger.info(
      `üìß Email alert would be sent to ${CONFIG.MONITORING.ALERT_EMAIL}: ${message}`,
    );
  }

  /**
   * Log message
   */
  log(level, message) {
    const timestamp = new Date().toISOString()
const logEntry = `[${timestamp}] [${level}] ${message}\n`;

    try {
      fs.appendFileSync(CONFIG.DAEMON.LOG_FILE, logEntry);
    } catch (error) {
      logger.error('‚ùå Failed to write to log file:', error.message);
    }
  }

  /**
   * Log service message
   */
  logService(serviceName, level, message) {
    const timestamp = new Date().toISOString()
const logEntry = `[${timestamp}] [${serviceName}] [${level}] ${message}`;

    // Write to service-specific log
    const serviceLogFile = `logs/${serviceName}.log`;
    try {
      fs.appendFileSync(serviceLogFile, logEntry + '\n');
    } catch (error) {
      logger.error(
        `‚ùå Failed to write to service log ${serviceLogFile}:`,
        error.message,
      );
    }
  }

  /**
   * Sleep utility
   */
  sleep(ms) {
    return new Promise((resolve) => 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(resolve,                                         ms);
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
);
  }

  /**
   * Stop the daemon
   */
  async stop() {
    logger.info('‚èπÔ∏è  Stopping Zion Automation Daemon...');

    this.isRunning = false;

    // Stop all services
    for (const [serviceName, service] of this.services) {
      logger.info(`üõë Stopping service: ${serviceName}`);
      try {
        service.process.kill('SIGTERM');
      } catch (error) {
        logger.error(
          `‚ùå Error stopping service ${serviceName}:`,
          error.message,
        );
      }
    }

    // Wait for services to stop
    await this.sleep(5000);

    // Force kill any remaining processes
    for (const [serviceName, service] of this.services) {
      try {
        service.process.kill('SIGKILL');
      } catch (error) {
        // Process already stopped
      }
    }

    // Remove PID file
    try {
      fs.unlinkSync(CONFIG.DAEMON.PID_FILE);
    } catch (error) {
      // PID file doesn't exist
    }

    // Save final metrics
    this.saveMetrics();

    logger.info('‚úÖ Zion Automation Daemon stopped');
    this.log('DAEMON_STOPPED', 'Zion Automation Daemon stopped');
  }

  /**
   * Get daemon status
   */
  getStatus() {
    return {
      isRunning: this.isRunning,
      pid: process.pid,
      uptime: Date.now() - this.metrics.startTime,
      services: Array.from(this.services.entries()).map(([name, service]) => ({
        name,
        status: service.status,
        uptime: Date.now() - service.startTime,
        restartCount: this.restartCounts.get(name) || 0,
      })),
      metrics: this.metrics,
    };
  }
}

// CLI handling
if (require.main === module) {
  const daemon = new ContinuousAutomationDaemon();

  // Handle process signals
  process.on('SIGINT', async () => {
    logger.info('\nüõë Received SIGINT, shutting down gracefully...');
    await daemon.stop();
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    logger.info('\nüõë Received SIGTERM, shutting down gracefully...');
    await daemon.stop();
    process.exit(0);
  });

  // Start the daemon
  daemon.start().catch((error) => {
    logger.error('‚ùå Failed to start automation daemon:', error);
    process.exit(1);
  });
}

module.exports = ContinuousAutomationDaemon;
