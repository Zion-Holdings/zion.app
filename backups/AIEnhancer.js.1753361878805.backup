
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'automation-script' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

const AutomationTask = require('../continuous-improvement/AutomationTask');
const { execSync, spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

class AIEnhancer extends AutomationTask {
  constructor(config = {}) {
    super({
      name: 'AIEnhancer',
      schedule: 0 */6 * * *', // Every 6 hours
      enabled: true,
      autoApply: false, // Don't auto-apply by default
      aiProviders: ['openai', claude', local'],
      enhancementTypes: ['code', documentation', tests', performance'],
      ...config
    });
    
    this.enhancementHistory = [];
    this.aiConfig = this.loadAIConfig();
  }

  async run() {
    logger.info('ü§ñ Starting AI enhancement process...');
    
    try {
      const results = {
        timestamp: new Date().toISOString(),
        enhancements: {},
        suggestions: {},
        summary: {}
      };
      
      // Run different types of AI enhancements
      if (this.config.enhancementTypes.includes('code')) {
        results.enhancements.code = await this.enhanceCode();
      }
      
      if (this.config.enhancementTypes.includes('documentation')) {
        results.enhancements.documentation = await this.enhanceDocumentation();
      }
      
      if (this.config.enhancementTypes.includes('tests')) {
        results.enhancements.tests = await this.enhanceTests();
      }
      
      if (this.config.enhancementTypes.includes('performance')) {
        results.enhancements.performance = await this.enhancePerformance();
      }
      
      // Generate suggestions
      results.suggestions = await this.generateSuggestions(results.enhancements);
      
      // Generate summary
      results.summary = this.generateSummary(results);
      
      // Store enhancement history
      this.enhancementHistory.push(results);
      
      // Apply enhancements if enabled
      if (this.config.autoApply) {
        await this.applyEnhancements(results);
      }
      
      this.lastStatus = success';
      this.lastRun = new Date();
      
      return results;
      
    } catch (error) {
      logger.error('‚ùå AI enhancement failed:', error);
      this.lastStatus = failed';
      this.lastError = error.message;
      this.lastRun = new Date();
      
      throw error;
    }
  }

  loadAIConfig() {
    return {
      openai: {
        enabled: process.env.OPENAI_ENABLED === 'true',
        apiKey: process.env.OPENAI_API_KEY,
        model: process.env.OPENAI_MODEL || gpt-4-turbo-preview
      },
      claude: {
        enabled: process.env.CLAUDE_ENABLED === 'true',
        apiKey: process.env.CLAUDE_API_KEY,
        model: process.env.CLAUDE_MODEL || claude-3-sonnet-20240229
      },
      local: {
        enabled: process.env.LOCAL_AI_ENABLED === 'true',
        endpoint: process.env.LOCAL_AI_ENDPOINT || http://localhost:11434',
        model: process.env.LOCAL_AI_MODEL || codellama:7b
      }
    };
  }

  async enhanceCode() {
    logger.info('üíª Enhancing code with AI...');
    
    try {
      const codeFiles = await this.findCodeFiles();
      const enhancements = [];
      
      for (const file of codeFiles.slice(0, 5)) { // Limit to 5 files per run
        const enhancement = await this.enhanceCodeFile(file);
        if (enhancement) {
          enhancements.push(enhancement);
        }
      }
      
      return {
        filesAnalyzed: codeFiles.length,
        filesEnhanced: enhancements.length,
        enhancements: enhancements
      };
      
    } catch (error) {
      logger.error('‚ùå Code enhancement failed:', error);
      return { error: error.message };
    }
  }

  async findCodeFiles() {
    const codeFiles = [];
    const extensions = ['.js', .jsx', .ts', .tsx'];
    
    try {
      const srcDir = path.join(process.cwd(), src');
      await this.scanDirectory(srcDir, extensions, codeFiles);
    } catch (error) {
      logger.warn('‚ö†Ô∏è Could not scan src directory:', error.message);
    }
    
    try {
      const pagesDir = path.join(process.cwd(), pages');
      await this.scanDirectory(pagesDir, extensions, codeFiles);
    } catch (error) {
      logger.warn('‚ö†Ô∏è Could not scan pages directory:', error.message);
    }
    
    return codeFiles;
  }

  async scanDirectory(dir, extensions, files) {
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory()) {
          await this.scanDirectory(fullPath, extensions, files);
        } else if (extensions.some(ext => entry.name.endsWith(ext))) {
          const stats = await fs.stat(fullPath);
          files.push({
            path: fullPath,
            name: entry.name,
            size: stats.size,
            relativePath: path.relative(process.cwd(), fullPath)
          });
        }
      }
    } catch (error) {
      // Directory might not exist
    }
  }

  async enhanceCodeFile(file) {
    try {
      const content = await fs.readFile(file.path, utf8');
      
      // Analyze code with AI
      const analysis = await this.analyzeCodeWithAI(content, file.name);
      
      if (analysis.suggestions && analysis.suggestions.length > 0) {
        return {
          file: file.relativePath,
          suggestions: analysis.suggestions,
          improvements: analysis.improvements,
          confidence: analysis.confidence
        };
      }
      
      return null;
      
    } catch (error) {
      logger.warn(`‚ö†Ô∏è Could not enhance ${file.path}:`, error.message);
      return null;
    }
  }

  async analyzeCodeWithAI(content, filename) {
    const prompt = this.generateCodeAnalysisPrompt(content, filename);
    
    // Try different AI providers
    for (const provider of this.config.aiProviders) {
      if (this.aiConfig[provider]?.enabled) {
        try {
          const result = await this.callAIProvider(provider, prompt);
          return this.parseAIResponse(result);
        } catch (error) {
          logger.warn(`‚ö†Ô∏è ${provider} AI provider failed:`, error.message);
          continue;
        }
      }
    }
    
    // Fallback to local analysis
    return this.localCodeAnalysis(content, filename);
  }

  generateCodeAnalysisPrompt(content, filename) {
    return `Analyze the following code and provide suggestions for improvement:

File: ${filename}
Content:
\`\`\`
${content}
\`\`\`

Please provide:
1. Code quality improvements
2. Performance optimizations
3. Best practices suggestions
4. Security considerations
5. Accessibility improvements

Format the response as JSON with the following structure:
{
  "suggestions": ["""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    {
      "type": "quality|performance|security|accessibility",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""description": "Description of the suggestion",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""code": "Improved code snippet",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""impact": "high|medium|low""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    }
  ],
  "improvements": {""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""quality": 0-100,""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""performance": 0-100,""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""security": 0-100"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
  },
  "confidence": 0-100"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
}`;
  }

  async callAIProvider(provider, prompt) {
    switch (provider) {
      case openai':
        return await this.callOpenAI(prompt);
      case claude':
        return await this.callClaude(prompt);
      case local':
        return await this.callLocalAI(prompt);
      default:
        throw new Error(`Unknown AI provider: ${provider}`);
    }
  }

  async callOpenAI(prompt) {
    // This would use the OpenAI API
    // For now, we'll simulate the response
    logger.info('ü§ñ Using OpenAI for code analysis...');
    
    return {
      suggestions: [
        {
          type: 'quality',
          description: Consider using TypeScript for better type safety',
          code: // Add type annotations',
          impact: high
        }
      ],
      improvements: {
        quality: 85,
        performance: 90,
        security: 95
      },
      confidence: 85
    };
  }

  async callClaude(prompt) {
    // This would use the Claude API
    logger.info('ü§ñ Using Claude for code analysis...');
    
    return {
      suggestions: [
        {
          type: 'performance',
          description: Optimize component rendering with React.memo',
          code: const Component = React.memo(({ props }) => { ... }),
          impact: medium
        }
      ],
      improvements: {
        quality: 80,
        performance: 85,
        security: 90
      },
      confidence: 80
    };
  }

  async callLocalAI(prompt) {
    // This would use a local AI model
    logger.info('ü§ñ Using local AI for code analysis...');
    
    return {
      suggestions: [
        {
          type: 'security',
          description: Sanitize user input to prevent XSS attacks',
          code: const sanitizedInput = DOMPurify.sanitize(userInput),
          impact: high
        }
      ],
      improvements: {
        quality: 75,
        performance: 80,
        security: 85
      },
      confidence: 70
    };
  }

  parseAIResponse(response) {
    try {
      if (typeof response === 'string') {
        return JSON.parse(response);
      }
      return response;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Failed to parse AI response:', error);
      return this.localCodeAnalysis('', );
    }
  }

  localCodeAnalysis(content, filename) {
    // Simple local analysis as fallback
    const suggestions = [];
    
    // Check for common issues
    if (content.includes('console.log')) {
      suggestions.push({
        type: 'quality',
        description: Remove console.log statements from production code',
        code: // Remove or use proper logging',
        impact: low
      });
    }
    
    if (content.includes('var )) {
      suggestions.push({
        type: 'quality',
        description: Use const or let instead of var',
        code: const variable = value;,
        impact: medium
      });
    }
    
    return {
      suggestions: suggestions,
      improvements: {
        quality: 70,
        performance: 75,
        security: 80
      },
      confidence: 60
    };
  }

  async enhanceDocumentation() {
    logger.info('üìö Enhancing documentation with AI...');
    
    try {
      const docFiles = await this.findDocumentationFiles();
      const enhancements = [];
      
      for (const file of docFiles.slice(0, 3)) { // Limit to 3 files per run
        const enhancement = await this.enhanceDocumentationFile(file);
        if (enhancement) {
          enhancements.push(enhancement);
        }
      }
      
      return {
        filesAnalyzed: docFiles.length,
        filesEnhanced: enhancements.length,
        enhancements: enhancements
      };
      
    } catch (error) {
      logger.error('‚ùå Documentation enhancement failed:', error);
      return { error: error.message };
    }
  }

  async findDocumentationFiles() {
    const docFiles = [];
    const extensions = ['.md', .mdx', .txt'];
    
    try {
      const docsDir = path.join(process.cwd(), docs');
      await this.scanDirectory(docsDir, extensions, docFiles);
    } catch (error) {
      logger.warn('‚ö†Ô∏è Could not scan docs directory:', error.message);
    }
    
    try {
      const readmePath = path.join(process.cwd(), README.md');
      const stats = await fs.stat(readmePath);
      docFiles.push({
        path: readmePath,
        name: 'README.md',
        size: stats.size,
        relativePath: README.md
      });
    } catch (error) {
      // README might not exist
    }
    
    return docFiles;
  }

  async enhanceDocumentationFile(file) {
    try {
      const content = await fs.readFile(file.path, utf8');
      
      const prompt = this.generateDocumentationPrompt(content, file.name);
      const analysis = await this.analyzeDocumentationWithAI(prompt);
      
      if (analysis.suggestions && analysis.suggestions.length > 0) {
        return {
          file: file.relativePath,
          suggestions: analysis.suggestions,
          improvements: analysis.improvements
        };
      }
      
      return null;
      
    } catch (error) {
      logger.warn(`‚ö†Ô∏è Could not enhance documentation ${file.path}:`, error.message);
      return null;
    }
  }

  generateDocumentationPrompt(content, filename) {
    return `Analyze the following documentation and provide suggestions for improvement:

File: ${filename}
Content:
\`\`\`
${content}
\`\`\`

Please provide:
1. Clarity improvements
2. Structure suggestions
3. Missing information
4. Examples that could be added
5. Grammar and style improvements

Format the response as JSON with the following structure:
{
  "suggestions": ["""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    {
      "type": "clarity|structure|content|style",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""description": "Description of the suggestion",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""improvement": "Improved text",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""impact": "high|medium|low""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    }
  ],
  "improvements": {""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""clarity": 0-100,""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""completeness": 0-100,""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""structure": 0-100"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
  }
}`;
  }

  async analyzeDocumentationWithAI(prompt) {
    // Use the same AI providers as code analysis
    for (const provider of this.config.aiProviders) {
      if (this.aiConfig[provider]?.enabled) {
        try {
          const result = await this.callAIProvider(provider, prompt);
          return this.parseAIResponse(result);
        } catch (error) {
          logger.warn(`‚ö†Ô∏è ${provider} AI provider failed for documentation:`, error.message);
          continue;
        }
      }
    }
    
    return { suggestions: [], improvements: { clarity: 70, completeness: 75, structure: 80 } };
  }

  async enhanceTests() {
    logger.info('üß™ Enhancing tests with AI...');
    
    try {
      const testFiles = await this.findTestFiles();
      const enhancements = [];
      
      for (const file of testFiles.slice(0, 3)) { // Limit to 3 files per run
        const enhancement = await this.enhanceTestFile(file);
        if (enhancement) {
          enhancements.push(enhancement);
        }
      }
      
      return {
        filesAnalyzed: testFiles.length,
        filesEnhanced: enhancements.length,
        enhancements: enhancements
      };
      
    } catch (error) {
      logger.error('‚ùå Test enhancement failed:', error);
      return { error: error.message };
    }
  }

  async findTestFiles() {
    const testFiles = [];
    const patterns = ['test', spec'];
    const extensions = ['.js', .jsx', .ts', .tsx'];
    
    try {
      const testDir = path.join(process.cwd(), __tests__');
      await this.scanDirectory(testDir, extensions, testFiles);
    } catch (error) {
      logger.warn('‚ö†Ô∏è Could not scan __tests__ directory:', error.message);
    }
    
    try {
      const srcDir = path.join(process.cwd(), src');
      await this.scanDirectory(srcDir, extensions, testFiles, patterns);
    } catch (error) {
      logger.warn('‚ö†Ô∏è Could not scan src for test files:', error.message);
    }
    
    return testFiles;
  }

  async scanDirectory(dir, extensions, files, patterns = []) {
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory()) {
          await this.scanDirectory(fullPath, extensions, files, patterns);
        } else if (extensions.some(ext => entry.name.endsWith(ext))) {
          // Check if file matches test patterns
          const isTestFile = patterns.length === 0 || 
            patterns.some(pattern => entry.name.includes(pattern));
          
          if (isTestFile) {
            const stats = await fs.stat(fullPath);
            files.push({
              path: fullPath,
              name: entry.name,
              size: stats.size,
              relativePath: path.relative(process.cwd(), fullPath)
            });
          }
        }
      }
    } catch (error) {
      // Directory might not exist
    }
  }

  async enhanceTestFile(file) {
    try {
      const content = await fs.readFile(file.path, utf8');
      
      const prompt = this.generateTestPrompt(content, file.name);
      const analysis = await this.analyzeTestsWithAI(prompt);
      
      if (analysis.suggestions && analysis.suggestions.length > 0) {
        return {
          file: file.relativePath,
          suggestions: analysis.suggestions,
          improvements: analysis.improvements
        };
      }
      
      return null;
      
    } catch (error) {
      logger.warn(`‚ö†Ô∏è Could not enhance test ${file.path}:`, error.message);
      return null;
    }
  }

  generateTestPrompt(content, filename) {
    return `Analyze the following test file and provide suggestions for improvement:

File: ${filename}
Content:
\`\`\`
${content}
\`\`\`

Please provide:
1. Test coverage improvements
2. Better test cases
3. Mocking suggestions
4. Assertion improvements
5. Test organization suggestions

Format the response as JSON with the following structure:
{
  "suggestions": ["""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    {
      "type": "coverage|mocking|assertion|organization",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""description": "Description of the suggestion",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""code": "Improved test code",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""impact": "high|medium|low""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    }
  ],
  "improvements": {""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""coverage": 0-100,""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""quality": 0-100,""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""maintainability": 0-100"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
  }
}`;
  }

  async analyzeTestsWithAI(prompt) {
    // Use the same AI providers
    for (const provider of this.config.aiProviders) {
      if (this.aiConfig[provider]?.enabled) {
        try {
          const result = await this.callAIProvider(provider, prompt);
          return this.parseAIResponse(result);
        } catch (error) {
          logger.warn(`‚ö†Ô∏è ${provider} AI provider failed for tests:`, error.message);
          continue;
        }
      }
    }
    
    return { suggestions: [], improvements: { coverage: 70, quality: 75, maintainability: 80 } };
  }

  async enhancePerformance() {
    logger.info('‚ö° Enhancing performance with AI...');
    
    try {
      // Analyze performance bottlenecks
      const analysis = await this.analyzePerformanceWithAI();
      
      return {
        bottlenecks: analysis.bottlenecks,
        optimizations: analysis.optimizations,
        improvements: analysis.improvements
      };
      
    } catch (error) {
      logger.error('‚ùå Performance enhancement failed:', error);
      return { error: error.message };
    }
  }

  async analyzePerformanceWithAI() {
    const prompt = `Analyze the following performance metrics and provide optimization suggestions:

Current Performance:
- Bundle size: ${await this.getBundleSize()} bytes
- Build time: ${await this.getBuildTime()} ms
- Lighthouse score: ${await this.getLighthouseScore()}

Please provide:
1. Performance bottlenecks
2. Optimization strategies
3. Code-level improvements
4. Configuration optimizations

Format the response as JSON with the following structure:
{
  "bottlenecks": ["""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    {
      "type": "bundle|build|runtime",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""description": "Description of the bottleneck",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""impact": "high|medium|low""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    }
  ],
  "optimizations": ["""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    {
      "type": "code|config|build",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""description": "Description of the optimization",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""implementation": "How to implement",""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""expectedImprovement": "Expected improvement""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    }
  ],
  "improvements": {""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""bundle": 0-100,""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""build": 0-100,""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""runtime": 0-100"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
  }
}`;

    // Use AI providers
    for (const provider of this.config.aiProviders) {
      if (this.aiConfig[provider]?.enabled) {
        try {
          const result = await this.callAIProvider(provider, prompt);
          return this.parseAIResponse(result);
        } catch (error) {
          logger.warn(`‚ö†Ô∏è ${provider} AI provider failed for performance:`, error.message);
          continue;
        }
      }
    }
    
    return { bottlenecks: [], optimizations: [], improvements: { bundle: 70, build: 75, runtime: 80 } };
  }

  async getBundleSize() {
    try {
      const buildDir = path.join(process.cwd(), .next');
      const stats = await this.getDirectorySize(buildDir);
      return stats.total;
    } catch {
      return 0;
    }
  }

  async getDirectorySize(dirPath) {
    let totalSize = 0;
    
    try {
      const files = await fs.readdir(dirPath, { withFileTypes: true });
      
      for (const file of files) {
        const filePath = path.join(dirPath, file.name);
        
        if (file.isDirectory()) {
          const subDirSize = await this.getDirectorySize(filePath);
          totalSize += subDirSize;
        } else {
          const stats = await fs.stat(filePath);
          totalSize += stats.size;
        }
      }
    } catch {
      // Directory might not exist
    }
    
    return totalSize;
  }

  async getBuildTime() {
    try {
      const startTime = Date.now();
      execSync('npm run build', { stdio: 'pipe' });
      return Date.now() - startTime;
    } catch {
      return 0;
    }
  }

  async getLighthouseScore() {
    try {
      // This would run Lighthouse and get the score
      return 85; // Mock score
    } catch {
      return 0;
    }
  }

  async generateSuggestions(enhancements) {
    const suggestions = [];
    
    // Aggregate suggestions from all enhancement types
    for (const [type, enhancement] of Object.entries(enhancements)) {
      if (enhancement && !enhancement.error) {
        if (enhancement.enhancements) {
          for (const item of enhancement.enhancements) {
            if (item.suggestions) {
              suggestions.push(...item.suggestions.map(s => ({ ...s, source: type })));
            }
          }
        }
      }
    }
    
    // Sort by impact
    suggestions.sort((a, b) => {
      const impactOrder = { high: 3, medium: 2, low: 1 };
      return impactOrder[b.impact] - impactOrder[a.impact];
    });
    
    return suggestions;
  }

  generateSummary(results) {
    const summary = {
      totalEnhancements: 0,
      totalSuggestions: results.suggestions.length,
      highImpactSuggestions: results.suggestions.filter(s => s.impact === 'high').length,
      appliedEnhancements: 0
    };
    
    // Count enhancements
    for (const [type, enhancement] of Object.entries(results.enhancements)) {
      if (enhancement && !enhancement.error) {
        summary.totalEnhancements += enhancement.filesEnhanced || 0;
      }
    }
    
    return summary;
  }

  async applyEnhancements(results) {
    logger.info('üîß Applying AI enhancements...');
    
    const applied = [];
    
    for (const suggestion of results.suggestions.slice(0, 10)) { // Limit to 10 suggestions
      try {
        await this.applySuggestion(suggestion);
        applied.push(suggestion);
      } catch (error) {
        logger.error(`‚ùå Failed to apply suggestion:`, error);
      }
    }
    
    logger.info(`‚úÖ Applied ${applied.length} enhancements`);
    return applied;
  }

  async applySuggestion(suggestion) {
    // This would apply the actual suggestion
    logger.info(`üîß Applying ${suggestion.type} enhancement: ${suggestion.description}`);
    
    // For now, we'll just log the suggestion
    // In a real implementation, this would modify files
  }

  async selfHeal(error) {
    logger.info('üîß Attempting self-healing for AIEnhancer...');
    
    if (error.message.includes('API')) {
      logger.info('üîë API issue detected, checking configuration...');
      await this.checkAIConfiguration();
      return;
    }
    
    if (error.message.includes('rate limit')) {
      logger.info('‚è≥ Rate limit detected, waiting before retry...');
      await new Promise(resolve => 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(resolve,                                   60000);
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
); // Wait 1 minute
      return;
    }
  }

  async checkAIConfiguration() {
    for (const [provider, config] of Object.entries(this.aiConfig)) {
      if (config.enabled && !config.apiKey) {
        logger.warn(`‚ö†Ô∏è ${provider} is enabled but no API key configured`);
      }
    }
  }

  getStatus() {
    return {
      ...super.getStatus(),
      enhancementHistory: this.enhancementHistory.slice(-5), // Last 5 enhancements
      totalEnhancements: this.enhancementHistory.length,
      aiProviders: Object.entries(this.aiConfig).map(([name, config]) => ({
        name,
        enabled: config.enabled,
        configured: !!config.apiKey
      })),
      lastEnhancement: this.enhancementHistory.length > 0 
        ? this.enhancementHistory[this.enhancementHistory.length - 1] 
        : null
    };
  }
}

module.exports = AIEnhancer; 