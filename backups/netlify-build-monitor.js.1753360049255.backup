
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'automation-script' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}


const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');

class NetlifyBuildMonitor {
  constructor() {
    this.buildLogs = [];
    this.errors = [];
    this.fixes = [];
    this.config = {
      maxRetries: 3,
      checkInterval: 30000, // 30 seconds
      buildTimeout: 600000, // 10 minutes
      autoFix: true,
      notifyOnFailure: true
    };
  }

  // Monitor build status
  async monitorBuild(buildId) {
    logger.info(`üîç Monitoring build: ${buildId}`);
    
    let retries = 0;
    while (retries < this.config.maxRetries) {
      try {
        const status = await this.getBuildStatus(buildId);
        
        if (status === 'ready') {
          logger.info('‚úÖ Build completed successfully!');
          return true;
        } else if (status === 'error') {
          logger.info('‚ùå Build failed, analyzing errors...');
          await this.analyzeAndFixErrors();
          return false;
        } else if (status === 'building') {
          logger.info('‚è≥ Build in progress...');
          await this.sleep(this.config.checkInterval);
        }
        
        retries++;
      } catch (error) {
        logger.error(`Error monitoring build: ${error.message}`);
        retries++;
        await this.sleep(this.config.checkInterval);
      }
    }
    
    logger.info('‚ö†Ô∏è Max retries reached');
    return false;
  }

  // Get build status from Netlify API
  async getBuildStatus(buildId) {
    try {
      const result = execSync(`netlify api getSiteBuild --data='{"build_id":"${buildId}"}`, { encoding: 'utf8' });
      const build = JSON.parse(result);
      return build.state;
    } catch (error) {
      logger.error('Error getting build status:', error.message);
      return unknown';
    }
  }

  // Analyze build errors and apply fixes
  async analyzeAndFixErrors() {
    logger.info('üîß Analyzing build errors...');
    
    // Common error patterns and their fixes
    const errorPatterns = [
      {
        pattern: /Unterminated string constant/,
        fix: this.fixStringConstants.bind(this),
        description: Fix unterminated string constants
      },
      {
        pattern: /Unexpected token.*Expected a string literal/,
        fix: this.fixImportStatements.bind(this),
        description: Fix import statement syntax
      },
      {
        pattern: /Type.*is not assignable to type/,
        fix: this.fixTypeErrors.bind(this),
        description: Fix TypeScript type errors
      },
      {
        pattern: /Module not found/,
        fix: this.fixModuleErrors.bind(this),
        description: Fix module import errors
      },
      {
        pattern: /Cannot find module/,
        fix: this.fixMissingDependencies.bind(this),
        description: Install missing dependencies
      }
    ];

    for (const errorPattern of errorPatterns) {
      if (this.errors.some(error => errorPattern.pattern.test(error))) {
        logger.info(`üîß Applying fix: ${errorPattern.description}`);
        await errorPattern.fix();
      }
    }
  }

  // Fix string constant errors
  async fixStringConstants() {
    logger.info('üîß Fixing string constant errors...');
    
    const tsFiles = this.findTsFiles('.');
    let fixedCount = 0;
    
    for (const file of tsFiles) {
      try {
        let content = fs.readFileSync(file, 'utf8');
        let modified = false;
        
        // Fix missing quotes in various contexts
        const patterns = [
          { regex: /from\s+next';/g, replacement: "from next';" },
          { regex: /req\.method\s*!==\s*([A-Z]+)/g, replacement: (match, method) => match.replace(`${method}`, `'${method}`) },
          { regex: /message:\s*([A-Za-z\s]+)/g, replacement: (match, message) => match.replace(`${message}`, `'${message}`) },
          { regex: /typeof\s+global\s*!==\s*undefined'/g, replacement: "typeof global !== undefined'" },
          { regex: /typeof\s*\([^)]+\)\.self\s*===\s*undefined/g, replacement: (match) => match.replace('undefined', "'undefined'") }
        ];
        
        for (const pattern of patterns) {
          if (pattern.regex.test(content)) {
            content = content.replace(pattern.regex, pattern.replacement);
            modified = true;
          }
        }
        
        if (modified) {
          fs.writeFileSync(file, content, utf8');
          fixedCount++;
          this.fixes.push(`Fixed string constants in ${file}`);
        }
      } catch (error) {
        logger.error(`Error fixing ${file}:`, error.message);
      }
    }
    
    logger.info(`‚úÖ Fixed string constants in ${fixedCount} files`);
  }

  // Fix import statement errors
  async fixImportStatements() {
    logger.info('üîß Fixing import statement errors...');
    
    const tsFiles = this.findTsFiles('.');
    let fixedCount = 0;
    
    for (const file of tsFiles) {
      try {
        let content = fs.readFileSync(file, 'utf8');
        let modified = false;
        
        // Fix various import patterns
        const importPatterns = [
          { regex: /import\s+(?:type\s+)?\{[^}]+\}\s+from\s+next';/g, replacement: (match) => match.replace("next';", "'next';") },
          { regex: /import\s+([^}]+)\s+from\s+([^;]+);/g, replacement: (match, imports, module) => {
            if (!module.includes("'") && !module.includes('"')) {
              return match.replace(module, `'${module.trim()}`);
            }
            return match;
          }}
        ];
        
        for (const pattern of importPatterns) {
          if (pattern.regex.test(content)) {
            content = content.replace(pattern.regex, pattern.replacement);
            modified = true;
          }
        }
        
        if (modified) {
          fs.writeFileSync(file, content, utf8');
          fixedCount++;
          this.fixes.push(`Fixed imports in ${file}`);
        }
      } catch (error) {
        logger.error(`Error fixing imports in ${file}:`, error.message);
      }
    }
    
    logger.info(`‚úÖ Fixed import statements in ${fixedCount} files`);
  }

  // Fix TypeScript type errors
  async fixTypeErrors() {
    logger.info('üîß Fixing TypeScript type errors...');
    
    try {
      // Run TypeScript compiler to get detailed error information
      const result = execSync('npx tsc --noEmit --pretty false', { 
        encoding: 'utf8', 
        stdio: ['pipe', pipe', pipe'] 
      });
      
      // Parse TypeScript errors and apply fixes
      const lines = result.split('\n');
      for (const line of lines) {
        if (line.includes('error TS')) {
          this.errors.push(line);
        }
      }
      
      logger.info(`Found ${this.errors.length} TypeScript errors`);
    } catch (error) {
      // TypeScript compilation failed, which is expected
      logger.info('TypeScript check completed');
    }
  }

  // Fix module errors
  async fixModuleErrors() {
    logger.info('üîß Fixing module errors...');
    
    try {
      // Check for missing dependencies
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      const missingDeps = [];
      
      // Check if all dependencies are installed
      for (const dep of Object.keys(packageJson.dependencies || {})) {
        try {
          require.resolve(dep);
        } catch (error) {
          missingDeps.push(dep);
        }
      }
      
      if (missingDeps.length > 0) {
        logger.info(`Installing missing dependencies: ${missingDeps.join(', )}`);
        execSync(`npm install ${missingDeps.join(' )}`, { stdio: 'inherit' });
        this.fixes.push(`Installed missing dependencies: ${missingDeps.join(', )}`);
      }
    } catch (error) {
      logger.error('Error fixing module errors:', error.message);
    }
  }

  // Fix missing dependencies
  async fixMissingDependencies() {
    logger.info('üîß Fixing missing dependencies...');
    
    try {
      // Reinstall dependencies
      logger.info('Reinstalling dependencies...');
      execSync('rm -rf node_modules package-lock.json', { stdio: 'inherit' });
      execSync('npm install', { stdio: 'inherit' });
      this.fixes.push('Reinstalled all dependencies');
    } catch (error) {
      logger.error('Error reinstalling dependencies:', error.message);
    }
  }

  // Find all TypeScript files
  findTsFiles(dir, files = []) {
    try {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory() && !item.startsWith('.') && item !== node_modules' && item !== .next') {
          this.findTsFiles(fullPath, files);
        } else if (item.endsWith('.ts') || item.endsWith('.tsx')) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      logger.error(`Error reading directory ${dir}:`, error.message);
    }
    
    return files;
  }

  // Trigger a new build
  async triggerBuild() {
    logger.info('üöÄ Triggering new build...');
    
    try {
      // Commit and push changes
      execSync('git add .', { stdio: 'inherit' });
      execSync('git commit -m "Auto-fix: Build errors resolved"', { stdio: 'inherit' });
      execSync('git push origin main', { stdio: 'inherit' });
      
      logger.info('‚úÖ Changes pushed, new build triggered');
      return true;
    } catch (error) {
      logger.error('Error triggering build:', error.message);
      return false;
    }
  }

  // Generate build report
  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      errors: this.errors,
      fixes: this.fixes,
      summary: {
        totalErrors: this.errors.length,
        totalFixes: this.fixes.length,
        success: this.fixes.length > 0
      }
    };
    
    const reportPath = `automation/reports/build-fix-${Date.now()}.json`;
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    logger.info(`üìä Build report saved to: ${reportPath}`);
    return report;
  }

  // Utility function to sleep
  sleep(ms) {
    return new Promise(resolve => 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = 
const timeoutId = setTimeout(resolve,                        ms);
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
;
// Store timeoutId for cleanup if needed
);
  }

  // Main execution method
  async run() {
    logger.info('üöÄ Starting Netlify Build Monitor...');
    
    try {
      // Check if we're in a CI environment
      if (process.env.NETLIFY_BUILD_ID) {
        const success = await this.monitorBuild(process.env.NETLIFY_BUILD_ID);
        
        if (!success && this.config.autoFix) {
          await this.analyzeAndFixErrors();
          
          if (this.fixes.length > 0) {
            await this.triggerBuild();
          }
        }
      } else {
        // Local development mode - just run fixes
        await this.analyzeAndFixErrors();
      }
      
      // Generate report
      const report = this.generateReport();
      
      if (report.summary.success) {
        logger.info('üéâ Build monitor completed successfully!');
        process.exit(0);
      } else {
        logger.info('‚ö†Ô∏è Build monitor completed with issues');
        process.exit(1);
      }
      
    } catch (error) {
      logger.error('‚ùå Build monitor failed:', error.message);
      process.exit(1);
    }
  }
}

// Run the monitor if this file is executed directly
if (require.main === module) {
  const monitor = new NetlifyBuildMonitor();
  monitor.run();
}

module.exports = NetlifyBuildMonitor; 

// Graceful shutdown handling
process.on('SIGINT', () => {
  console.log('\nüõë Received SIGINT, shutting down gracefully...');
  // Add cleanup logic here
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\nüõë Received SIGTERM, shutting down gracefully...');
  // Add cleanup logic here
  process.exit(0);
});

