<<<<<<< HEAD
import React from 'react';
// Remove direct import of sonnerToast, rely on globalToastManager
import { globalToastManager, showToast, ToastType, ToastPriority } from '@/utils/globalToastManager';

export type ToastOptions = OptionsObject & { variant?: VariantType };

export function useToast() {
  const { enqueueSnackbar } = useSnackbar();
  const toast = React.useCallback((message: string, options?: ToastOptions) => {
    enqueueSnackbar(message, options);
  }, [enqueueSnackbar]);

  toast.error = (msg: string) => enqueueSnackbar(msg, { variant: 'error' });
  toast.success = (msg: string) => enqueueSnackbar(msg, { variant: 'success' });

  return { toast } as { toast: typeof toast };
}

let globalEnqueue: (msg: string, opts?: OptionsObject) => void;

export function ToastInitializer() {
  const { enqueueSnackbar } = useSnackbar();
  React.useEffect(() => {
    globalEnqueue = enqueueSnackbar;
  }, [enqueueSnackbar]);
  return null;
}

const shouldShow = (key: string): boolean => {
  const now = Date.now();
  if (key === lastKey && (now - lastShown) < DEDUPE_DELAY) {
    return false;
  }
  lastKey = key;
  lastShown = now;
  return true;
};

/**
 * Enhanced toast adapter that uses the global toast manager
 */
const toastAdapter = (props: ToastProps | string) => {
  if (typeof props === 'string') {
    return globalToastManager.showToast({
      message: props,
      type: ToastType.INFO,
    });
  }

  const { 
    title, 
    description, 
    variant = 'default', 
    action, 
    onRetry, 
    duration,
    priority,
    persistent = false 
  } = props;

  // Map variant to toast type
  let type: ToastType;
  switch (variant) {
    case 'destructive':
      type = ToastType.ERROR;
      break;
    case 'success':
      type = ToastType.SUCCESS;
      break;
    default:
      type = ToastType.INFO;
      break;
  }

  // Use title as message if no description, otherwise use description
  const message = description || title || '';
  const toastTitle = title && description ? title : undefined;

  return globalToastManager.showToast({
    message,
    ...(toastTitle && { title: toastTitle }),
    type,
    ...(priority && { priority }),
    ...(duration && { duration }),
    persistent,
    ...(action && { action }),
    ...(onRetry && { onRetry }),
  });
};

// Convenience methods that use the global toast manager
toastAdapter.success = (message: string, options?: { id?: string; duration?: number } & Record<string, any>) => {
  return showToast.success(message, options);
};

toastAdapter.error = (message: string, options?: { id?: string; duration?: number } & Record<string, any>) => {
  return showToast.error(message, options);
};

toastAdapter.info = (message: string, options?: { id?: string; duration?: number } & Record<string, any>) => {
  return showToast.info(message, options);
};

toastAdapter.warning = (message: string, options?: { id?: string; duration?: number } & Record<string, any>) => {
  return showToast.warning(message, options);
};

toastAdapter.dismiss = (toastId?: string | number) => {
  if (toastId) {
    globalToastManager.dismissToast(String(toastId));
  } else {
    globalToastManager.dismissAll();
  }
};

// Enhanced useToast hook with global toast manager integration
export const useToast = () => ({
  toast: toastAdapter,
  dismiss: (toastId?: string) => {
    if (toastId) {
      globalToastManager.dismissToast(toastId);
    } else {
      globalToastManager.dismissAll();
    }
  },
  
  // Additional methods from global toast manager
  showToast: globalToastManager.showToast.bind(globalToastManager),
  getActiveToasts: globalToastManager.getActiveToasts.bind(globalToastManager),
  getQueueLength: globalToastManager.getQueueLength.bind(globalToastManager),
  dismissAll: globalToastManager.dismissAll.bind(globalToastManager),
  
  // Convenience methods
  success: showToast.success,
  error: showToast.error,
  warning: showToast.warning,
  info: showToast.info,
  networkError: showToast.networkError,
  authError: showToast.authError,
  validationError: showToast.validationError,
  criticalError: showToast.criticalError,
});

export const toast = toastAdapter;
=======
import { toast as hotToast, type ToastOptions as HotToastOptions } from 'react-hot-toast';

export type ToastOptions = HotToastOptions & {
  title?: string;
  description?: string;
  variant?: 'default' | 'destructive' | 'success';
};

export const useToast = () => ({ toast });

function toast(options: ToastOptions) {
  const message = options.description || options.title || '';
  if (options.variant === 'destructive') {
    hotToast.error(message, options);
  } else if (options.variant === 'success') {
    hotToast.success(message, options);
  } else {
    hotToast(message, options);
  }
}

toast.title = (title: string) => hotToast(title);
toast.description = (description: string) => hotToast(description);
toast.error = (error: string) => hotToast.error(error);
toast.success = (message: string) => hotToast.success(message);

export { toast };
>>>>>>> origin/4o9pcp-codex/add-test-for-failed-login-toast
