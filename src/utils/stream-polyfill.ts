/**
 * Stream Polyfill for Browser Environment
 * 
 * This polyfill provides a basic implementation of Node.js streams
 * for browser environments where the stream module is not available.
 */

// EventEmitter polyfill (simplified)
class EventEmitter {
  private events: { [key: string]: Array<(...args: unknown[]) => unknown> } = {};

  on(event: string, listener: (...args: unknown[]) => unknown): this {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return this;
  }

  emit(event: string, ...args: unknown[]): boolean {
    if (!this.events[event]) {
      return false;
    }
    this.events[event].forEach(listener => listener(...args));
    return true;
  }

  removeListener(event: string, listener: (...args: unknown[]) => unknown): this {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(l => l !== listener);
    }
    return this;
  }

  removeAllListeners(event?: string): this {
    if (event) {
      delete this.events[event];
    } else {
      this.events = {};
    }
    return this;
  }
}

// Base Stream class
class Stream extends EventEmitter {
  constructor() {
    super();
  }
}

// Readable Stream
class Readable extends Stream {
  private _readableState: unknown;
  private _read: (size?: number) => unknown;

  constructor(options: unknown = {}) {
    super();
    // Type guard for options
    const opts = typeof options === 'object' && options !== null ? options as Record<string, unknown> : {};
    this._readableState = {
      ...opts,
      buffer: [],
      ended: false,
      reading: false,
    };
    this._read = opts.read as ((size?: number) => unknown) || (() => {});
  }

  read(size?: number): unknown {
    return this._read(size);
  }

  push(chunk: unknown, encoding?: string): boolean {
    this.emit('data', chunk);
    return true;
  }

  pipe(dest: unknown, options?: unknown): unknown {
    // Type guard for dest
    if (typeof dest !== 'object' || dest === null) return undefined;
    const writable = dest as { write?: (chunk: unknown) => boolean; on?: (event: string, cb: (...args: unknown[]) => void) => void };
    this.on('data', (chunk) => {
      if (writable.write && !writable.write(chunk)) {
        // Pause if backpressure
        if (this.pause) this.pause();
      }
    });
    if (writable.on) {
      writable.on('drain', () => {
        if (this.resume) this.resume();
      });
    }
    return dest;
  }

  pause(): this {
    if (typeof this._readableState === 'object' && this._readableState !== null) {
      (this._readableState as Record<string, unknown>).flowing = false;
    }
    return this;
  }

  resume(): this {
    if (typeof this._readableState === 'object' && this._readableState !== null) {
      (this._readableState as Record<string, unknown>).flowing = true;
    }
    return this;
  }

  destroy(): this {
    if (typeof this._readableState === 'object' && this._readableState !== null) {
      (this._readableState as Record<string, unknown>).destroyed = true;
    }
    this.emit('close');
    return this;
  }
}

// Writable Stream
class Writable extends Stream {
  private _writableState: unknown;
  private _write: (chunk: unknown, encoding?: string, cb?: (err?: Error) => unknown) => unknown;

  constructor(options: unknown = {}) {
    super();
    // Type guard for options
    const opts = typeof options === 'object' && options !== null ? options as Record<string, unknown> : {};
    this._writableState = {
      ...opts,
      buffer: [],
      ended: false,
      writing: false,
    };
    this._write = opts.write as ((chunk: unknown, encoding?: string, cb?: (err?: Error) => unknown) => unknown) || (() => {});
  }

  write(chunk: unknown, encoding?: string, cb?: (err?: Error) => unknown): boolean {
    this._write(chunk, encoding, cb);
    return true;
  }

  end(chunk?: unknown, encoding?: string, cb?: (err?: Error) => unknown): this {
    if (typeof this._writableState === 'object' && this._writableState !== null) {
      (this._writableState as Record<string, unknown>).ending = true;
      (this._writableState as Record<string, unknown>).finished = true;
    }
    this.emit('finish');
    return this;
  }

  destroy(): this {
    if (typeof this._writableState === 'object' && this._writableState !== null) {
      (this._writableState as Record<string, unknown>).destroyed = true;
    }
    this.emit('close');
    return this;
  }
}

// Duplex Stream
class Duplex extends Readable {
  private _writable: Writable;

  constructor(options: unknown = {}) {
    super(options);
    this._writable = new Writable(options);
  }

  write(chunk: unknown, encoding?: string, cb?: (err?: Error) => unknown): boolean {
    return this._writable.write(chunk, encoding, cb);
  }

  end(chunk?: unknown, encoding?: string, cb?: (err?: Error) => unknown): this {
    this._writable.end(chunk, encoding, cb);
    return this;
  }
}

// Top-level default transform and flush functions
function defaultTransform(chunk: unknown, encoding: string, callback: (err?: Error, data?: unknown) => unknown): unknown {
  callback();
  return undefined;
}
function defaultFlush(callback: (err?: Error) => unknown): unknown {
  callback();
  return undefined;
}

// Transform Stream
class Transform extends Duplex {
  private _internalTransform: (chunk: unknown, encoding: string, callback: (err?: Error, data?: unknown) => unknown) => unknown;
  private _internalFlush: (callback: (err?: Error) => unknown) => unknown;

  constructor(options: unknown = {}) {
    super(options);
    // Type guard for options
    const opts = typeof options === 'object' && options !== null ? options as Record<string, unknown> : {};
<<<<<<< HEAD
    this._internalTransform = typeof opts.transform === 'function'
      ? opts.transform as (chunk: unknown, encoding: string, callback: (err?: Error, data?: unknown) => unknown)
      : defaultTransform;
    this._internalFlush = typeof opts.flush === 'function'
      ? opts.flush as (callback: (err?: Error) => unknown) => unknown
      : defaultFlush;
=======
    if (typeof opts.transform === 'function') {
      this._internalTransform = opts.transform as (chunk: unknown, encoding: string, callback: (err?: Error, data?: unknown) => unknown) => unknown;
    } else {
      this._internalTransform = (chunk, encoding, callback) => callback();
    }
    if (typeof opts.flush === 'function') {
      this._internalFlush = opts.flush as (callback: (err?: Error) => unknown) => unknown;
    } else {
      this._internalFlush = (callback) => { callback(); };
    }
>>>>>>> 8a67bff44c79f9591d14830dbaf4a0b5c8b76731
  }

  _transform(chunk: unknown, encoding: string, callback: (err?: Error, data?: unknown) => unknown): void {
    this._internalTransform(chunk, encoding, callback);
  }

  _flush(callback: (err?: Error) => unknown): void {
    this._internalFlush(callback);
  }
}

// PassThrough Stream
class PassThrough extends Transform {
  constructor(options: unknown = {}) {
    super(options);
  }
}

// Create the stream module
const streamModule = {
  Stream,
  Readable,
  Writable,
  Duplex,
  Transform,
  PassThrough,
  // Add commonly used properties
  ReadableState: class {},
  WritableState: class {},
  Buffer: typeof Buffer !== 'undefined' ? Buffer : null,
  // Add utility functions
  finished: (stream: unknown, callback: (err?: Error) => unknown) => {
    if (typeof stream === 'object' && stream !== null && 'on' in stream && typeof (stream as { on: unknown }).on === 'function') {
      (stream as { on: (event: string, cb: (err?: Error) => unknown) => void }).on('end', callback);
      (stream as { on: (event: string, cb: (err?: Error) => unknown) => void }).on('finish', callback);
      (stream as { on: (event: string, cb: (err?: Error) => unknown) => void }).on('close', callback);
    }
  },
  pipeline: (...streams: unknown[]) => {
    // Simple pipeline implementation
    let current = streams[0];
    for (let i = 1; i < streams.length; i++) {
      if (typeof current === 'object' && current !== null && 'pipe' in current && typeof (current as { pipe: unknown }).pipe === 'function') {
        current = (current as { pipe: (dest: unknown) => unknown }).pipe(streams[i]);
      }
    }
    return current;
  }
};

// Export the stream module
export default streamModule;

// Also make it available globally
if (typeof globalThis !== 'undefined') {
  (globalThis as unknown as { stream?: typeof streamModule }).stream = streamModule;
}

if (typeof window !== 'undefined') {
  (window as unknown as { stream?: typeof streamModule }).stream = streamModule;
} 