/**
 * Memoization utilities for performance optimization
 * Auto-generated by performance optimizer
 */
import { memo, useMemo, useCallback } from 'react';

// Higher-order component for automatic memoization
export function withMemo<T extends object>(
  Component: React.ComponentType<T>,
  compare?: (prevProps: T, nextProps: T) => boolean
) {
  return memo(Component, compare);
}

// Memoization for expensive calculations
export function useExpensiveMemo<T>(
  factory: () => T,
  deps: React.DependencyList
): T {
  return useMemo(() => {
    const start = performance.now();
    const result = factory();
    const end = performance.now();
    
    if (process.env.NODE_ENV === 'development' && end - start > 50) {
      console.warn(`Expensive calculation took ${(end - start).toFixed(2)}ms`, deps);
    }
    
    return result;
  }, deps);
}

// Stable callback memoization
export function useStableCallback<T extends (...args: any[]) => any>(
  callback: T,
  deps: React.DependencyList
): T {
  return useCallback(callback, deps);
}

// Memoization for complex objects
export function useObjectMemo<T extends object>(
  obj: T,
  deps: React.DependencyList
): T {
  return useMemo(() => obj, deps);
}

// Performance-aware component wrapper
export function PerformanceWrapper<T extends object>({
  children,
  name = 'Component',
  ...props
}: T & { children: React.ReactNode; name?: string }) {
  const renderStart = useMemo(() => performance.now(), []);
  
  useMemo(() => {
    const renderEnd = performance.now();
    const renderTime = renderEnd - renderStart;
    
    if (process.env.NODE_ENV === 'development' && renderTime > 100) {
      console.warn(`Slow render: ${name} took ${renderTime.toFixed(2)}ms`);
    }
  }, [name, renderStart]);
  
  return children as React.ReactElement;
}

// Usage examples:
// 1. Component memoization:
//    export default withMemo(MyComponent);
//
// 2. Expensive calculations:
//    const result = useExpensiveMemo(() => heavyCalculation(data), [data]);
//
// 3. Stable callbacks:
//    const handleClick = useStableCallback(() => onClick(id), [onClick, id]);
