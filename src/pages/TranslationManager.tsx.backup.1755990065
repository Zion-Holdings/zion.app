<<<<<<< HEAD
import React, { useState, useEffect } from 'react';
import { Header } from "@/components/Header";
import { SEO } from "@/components/SEO";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "@/components/ui/use-toast";
import { useTranslation } from "react-i18next";
import { AlertTriangle, Check, Globe, Search, Loader2 } from 'lucide-react';





import { useIsMobile } from "@/hooks/use-mobile";
import { useLanguage } from "@/context/LanguageContext";
import type { SupportedLanguage } from "@/context/LanguageContext";
import { useTranslationService } from "@/hooks/useTranslationService";
import {logErrorToProduction} from '@/utils/productionLogger';

export default function TranslationManager() {

  const { t, i18n } = useTranslation();
  const isMobile = useIsMobile();
  const { supportedLanguages } = useLanguage();
  const { translateContent, isTranslating } = useTranslationService();
  
  const [selectedNamespace, setSelectedNamespace] = useState("translation");
  const [searchQuery, setSearchQuery] = useState("");
  const [translations, setTranslations] = useState<Record<string, Record<string, string>>>({});
  const [filteredKeys, setFilteredKeys] = useState<string[]>([]);
  const [editingKey, setEditingKey] = useState<string | null>(null);
  const [editedTranslations, setEditedTranslations] = useState<Record<string, Record<SupportedLanguage, string>>>({});
  const [isSaving, setIsSaving] = useState(false);
  
  // Simulated translation data - in a real app, this would come from your backend
  useEffect(() => {
    // For demo purposes, we're using the loaded translations from i18next
    const currentTranslations: Record<string, Record<string, string>> = {};
    
    supportedLanguages.forEach(lang => {
      const res = i18n.getResourceBundle(lang.code, selectedNamespace);
      if (res) {
        // Flatten nested objects for easier management
        const flattenObject = (obj: unknown, prefix = ''): Record<string, string> => {
          if (typeof obj !== 'object' || obj === null) return {};
          return Object.keys(obj).reduce((acc, key) => {
            const pre = prefix.length ? `${prefix}.` : '';
            const value = (obj as Record<string, unknown>)[key];
            if (typeof value === 'object' && value !== null) {
              Object.assign(acc, flattenObject(value, `${pre}${key}`));
            } else if (typeof value === 'string') {
              acc[`${pre}${key}`] = value;
            }
            return acc;
          }, {} as Record<string, string>);
        };
        
        currentTranslations[lang.code] = flattenObject(res);
      }
    });
    
    setTranslations(currentTranslations);
    
    // Get all unique keys across all languages
    const allKeys = new Set<string>();
    Object.values(currentTranslations).forEach(langTranslations => {
      if (typeof langTranslations === 'object' && langTranslations !== null) {
        Object.keys(langTranslations as Record<string, string>).forEach(key => allKeys.add(key));
      }
    });
    
    setFilteredKeys(Array.from(allKeys));
  }, [selectedNamespace, i18n]);
  
  // Filter keys based on search query
  useEffect(() => {
    if (!searchQuery.trim()) {
      // Get all unique keys across all languages
      const allKeys = new Set<string>();
      Object.values(translations).forEach(langTranslations => {
        if (typeof langTranslations === 'object' && langTranslations !== null) {
          Object.keys(langTranslations as Record<string, string>).forEach(key => allKeys.add(key));
        }
      });
      setFilteredKeys(Array.from(allKeys));
      return;
    }
    
    const query = searchQuery.toLowerCase().trim();
    const filtered: string[] = [];
    
    // Search in keys and values
    Object.values(translations).forEach(langTranslations => {
      if (typeof langTranslations === 'object' && langTranslations !== null) {
        Object.entries(langTranslations as Record<string, string>).forEach(([key, value]) => {
          if (
            key.toLowerCase().includes(query) || 
            (typeof value === 'string' && value.toLowerCase().includes(query))
          ) {
            filtered.push(key);
          }
        });
      }
    });
    
    setFilteredKeys([...new Set(filtered)]);
  }, [searchQuery, translations]);
  
  const handleEdit = (key: string) => {
    setEditingKey(key);
    
    // Initialize edited translations for this key
    const initialEdits: Record<SupportedLanguage, string> = {} as Record<SupportedLanguage, string>;
    supportedLanguages.forEach(lang => {
      const langTranslations = translations[lang.code];
      initialEdits[lang.code] = (typeof langTranslations === 'object' && langTranslations !== null && langTranslations[key]) || '';
    });
    
    setEditedTranslations({
      ...editedTranslations,
      [key]: initialEdits
    });
  };
  
  const handleSave = (key: string) => {
    setIsSaving(true);
    
    // In a real application, you would save these to your backend
    setTimeout(() => {
      // Update translations with edited values
      const updatedTranslations = { ...translations };
      
      supportedLanguages.forEach(lang => {
        if (!updatedTranslations[lang.code]) {
          updatedTranslations[lang.code] = {};
        }
        const editedKey = editedTranslations[key];
        if (editedKey && typeof editedKey === 'object' && editedKey[lang.code] !== undefined) {
          updatedTranslations[lang.code][key] = editedKey[lang.code];
        }
      });
      
      setTranslations(updatedTranslations);
      setEditingKey(null);
      setIsSaving(false);
      
      toast({
        title: t("translation.saved"),
        description: t("translation.changes_saved"),
      });
    }, 1000);
  };
  
  const handleTranslateKey = async (key: string) => {
    // Find first non-empty translation to use as source
    let sourceLanguage: SupportedLanguage = 'en-US';
    let sourceText = '';
    
    for (const lang of supportedLanguages.map(l => l.code)) {
      const langTranslations = translations[lang];
      if (typeof langTranslations === 'object' && langTranslations !== null && langTranslations[key]) {
        sourceLanguage = lang;
        sourceText = langTranslations[key];
        break;
      }
    }
    
    if (!sourceText) {
      toast({
        title: t('translation.no_content'),
        description: t('translation.add_content_first'),
        variant: "destructive",
      });
      return;
    }
    
    try {
      const { translations: translatedText, error } = await translateContent(
        sourceText, 
        'general', 
        sourceLanguage
      );
      
      if (error) {
        toast({
          title: t('translation.translation_failed'),
          description: error,
          variant: "destructive",
        });
        return;
      }
      
      // Update edited translations with auto-translated content
      setEditedTranslations({
        ...editedTranslations,
        [key]: translatedText
      });
      
      toast({
        title: t('translation.translation_success'),
        description: t('translation.content_translated'),
      });
    } catch (error) {
      logErrorToProduction('Error translating key ${key}:', { data: error });
      toast({
        title: t('translation.translation_failed'),
        description: error instanceof Error ? error.message : t('translation.unknown_error'),
        variant: "destructive",
      });
    }
  };
  
  const handleCancel = () => {
    setEditingKey(null);
  };
  
  const handleChange = (lang: SupportedLanguage, key: string, value: string) => {
    setEditedTranslations({
      ...editedTranslations,
      [key]: {
        ...(editedTranslations[key] || {} as Record<SupportedLanguage, string>),
        [lang]: value
      }
    } as Record<string, Record<SupportedLanguage, string>>);
  };
  
  const getMissingLanguages = (key: string): SupportedLanguage[] => {
    return supportedLanguages
      .map(lang => lang.code)
      .filter(lang => {
        const langTranslations = translations[lang];
        return !(typeof langTranslations === 'object' && langTranslations !== null && langTranslations[key]);
      });
  };
  
=======
import React from 'react';
export function TranslationManager() {
>>>>>>> origin/automation-error-fixes
  return (
    <div>
      <h1>Component</h1>
      <p>Component placeholder</p>
    </div>
  );
}
