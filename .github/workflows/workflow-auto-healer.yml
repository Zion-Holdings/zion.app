name: 🔧 Workflow Auto-Healer

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:
    inputs:
      force_repair:
        description: 'Force repair all workflows'
        required: false
        default: false
        type: boolean
  workflow_run:
    workflows: ['CI', 'Test Suite', 'Commitlint']
    types: [completed]
    branches: [main]

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  detect-broken-workflows:
    name: 🔍 Detect Broken Workflows
    runs-on: ubuntu-latest
    outputs:
      broken_count: ${{ steps.count.outputs.broken_count }}
      broken_files: ${{ steps.count.outputs.broken_files }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install PyYAML
        run: pip install pyyaml
      
      - name: Detect broken workflows
        id: count
        run: |
          BROKEN_COUNT=0
          BROKEN_FILES=""
          
          for file in .github/workflows/*.yml; do
            if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
              BROKEN_COUNT=$((BROKEN_COUNT + 1))
              BROKEN_FILES="$BROKEN_FILES $file"
              echo "❌ Broken workflow: $file"
            fi
          done
          
          echo "broken_count=$BROKEN_COUNT" >> $GITHUB_OUTPUT
          echo "broken_files=$BROKEN_FILES" >> $GITHUB_OUTPUT
          echo "Total broken workflows: $BROKEN_COUNT"
      
      - name: Create issue if workflows are broken
        if: steps.count.outputs.broken_count > 0
        uses: actions/github-script@v7
        with:
          script: |
            const title = `🚨 ${context.job} detected ${context.job.outputs.broken_count} broken workflows`;
            const body = `## Workflow Health Alert
            
            The workflow auto-healer detected **${context.job.outputs.broken_count}** broken GitHub Actions workflows.
            
            ### Broken Workflows:
            ${context.job.outputs.broken_files.split(' ').filter(f => f).map(f => `- \`${f}\``).join('\n')}
            
            ### Next Steps:
            1. The auto-healer will attempt to fix these workflows
            2. Review the fixes before merging
            3. Test the repaired workflows
            
            ---
            *This issue was automatically created by the Workflow Auto-Healer*`;
            
            // Check if issue already exists
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['workflow-auto-healer']
            });
            
            if (!issues.find(i => i.title === title)) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['workflow-auto-healer', 'automation', 'urgent']
              });
            }

  repair-workflows:
    name: 🔧 Repair Broken Workflows
    runs-on: ubuntu-latest
    needs: detect-broken-workflows
    if: needs.detect-broken-workflows.outputs.broken_count > 0 || github.event.inputs.force_repair == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install PyYAML
        run: pip install pyyaml
      
      - name: Create workflow repair script
        run: |
          cat > repair_workflows.py << 'EOF'
          #!/usr/bin/env python3
          """
          GitHub Actions Workflow Auto-Repair Script
          Fixes common YAML syntax errors and structural issues
          """
          
          import yaml
          import os
          import sys
          import re
          from pathlib import Path
          
          def fix_workflow_file(file_path):
              """Fix a single workflow file"""
              print(f"🔧 Repairing: {file_path}")
              
              try:
                  # Read the file
                  with open(file_path, 'r', encoding='utf-8') as f:
                      content = f.read()
                  
                  # Create backup
                  backup_path = f"{file_path}.backup"
                  with open(backup_path, 'w', encoding='utf-8') as f:
                      f.write(content)
                  
                  # Fix common issues
                  fixed_content = fix_common_issues(content)
                  
                  # Validate the fixed content
                  try:
                      yaml.safe_load(fixed_content)
                      print(f"  ✅ YAML validation passed")
                  except yaml.YAMLError as e:
                      print(f"  ❌ YAML validation failed: {e}")
                      return False
                  
                  # Write the fixed content
                  with open(file_path, 'w', encoding='utf-8') as f:
                      f.write(fixed_content)
                  
                  print(f"  ✅ Fixed: {file_path}")
                  return True
                  
              except Exception as e:
                  print(f"  ❌ Error fixing {file_path}: {e}")
                  return False
          
          def fix_common_issues(content):
              """Fix common workflow issues"""
              lines = content.split('\n')
              fixed_lines = []
              in_jobs = False
              in_steps = False
              current_job = None
              job_indent = 0
              
              for i, line in enumerate(lines):
                  stripped = line.strip()
                  
                  # Detect jobs section
                  if stripped == 'jobs:':
                      in_jobs = True
                      in_steps = False
                      fixed_lines.append(line)
                      continue
                  
                  # Detect individual job
                  if in_jobs and stripped and not stripped.startswith('-') and ':' in stripped and not stripped.startswith('#'):
                      if ':' in stripped and not stripped.endswith(':'):
                          # This is a job name, add proper structure
                          job_name = stripped.split(':')[0].strip()
                          current_job = job_name
                          job_indent = len(line) - len(line.lstrip())
                          
                          fixed_lines.append(line)
                          # Add runs-on if missing
                          next_line = lines[i + 1] if i + 1 < len(lines) else ""
                          if 'runs-on:' not in next_line:
                              fixed_lines.append(' ' * (job_indent + 2) + 'runs-on: ubuntu-latest')
                          continue
                      
                      if stripped.endswith(':'):
                          # This is a job section start
                          current_job = stripped[:-1].strip()
                          job_indent = len(line) - len(line.lstrip())
                          fixed_lines.append(line)
                          continue
                  
                  # Detect steps section
                  if in_jobs and stripped == 'steps:':
                      in_steps = True
                      fixed_lines.append(line)
                      continue
                  
                  # Fix step indentation and structure
                  if in_steps and stripped.startswith('- name:'):
                      # Ensure proper step structure
                      step_indent = ' ' * (job_indent + 4)
                      fixed_lines.append(step_indent + stripped)
                      continue
                  
                  if in_steps and stripped.startswith('uses:') or stripped.startswith('run:') or stripped.startswith('if:'):
                      # Ensure proper indentation for step properties
                      step_indent = ' ' * (job_indent + 6)
                      fixed_lines.append(step_indent + stripped)
                      continue
                  
                  if in_steps and stripped.startswith('with:'):
                      # Ensure proper indentation for with section
                      step_indent = ' ' * (job_indent + 6)
                      fixed_lines.append(step_indent + stripped)
                      continue
                  
                  # Handle other lines
                  if line.strip() == '':
                      fixed_lines.append('')
                  elif line.startswith(' '):
                      # Preserve existing indentation for other content
                      fixed_lines.append(line)
                  else:
                      # Reset context for top-level sections
                      if stripped and not stripped.startswith('#') and ':' in stripped:
                          in_jobs = False
                          in_steps = False
                          current_job = None
                      fixed_lines.append(line)
              
              # Ensure proper structure
              result = '\n'.join(fixed_lines)
              
              # Add missing permissions if not present
              if 'permissions:' not in result:
                  result = result.replace('on:', 'on:\n\npermissions:\n  contents: read\n  actions: read')
              
              # Add missing concurrency if not present
              if 'concurrency:' not in result:
                  result = result.replace('permissions:', 'permissions:\n\nconcurrency:\n  group: "github.workflow-${{ github.ref }}"\n  cancel-in-progress: true')
              
              return result
          
          def main():
              """Main repair function"""
              workflows_dir = Path('.github/workflows')
              if not workflows_dir.exists():
                  print("❌ .github/workflows directory not found")
                  return
              
              repaired_count = 0
              total_files = len(list(workflows_dir.glob('*.yml')))
              
              print(f"🔍 Found {total_files} workflow files")
              
              for workflow_file in workflows_dir.glob('*.yml'):
                  if fix_workflow_file(workflow_file):
                      repaired_count += 1
              
              print(f"\n🎉 Repair completed!")
              print(f"📊 Summary:")
              print(f"   - Total files: {total_files}")
              print(f"   - Repaired: {repaired_count}")
              print(f"   - Already working: {total_files - repaired_count}")
              
              if repaired_count > 0:
                  print(f"\n📝 Next steps:")
                  print(f"1. Review the repaired workflows")
                  print(f"2. Test the workflows")
                  print(f"3. Remove .backup files if everything works")
                  print(f"4. Commit and push the changes")
          
          if __name__ == '__main__':
              main()
          EOF
      
      - name: Repair workflows
        run: python3 repair_workflows.py
      
      - name: Validate repaired workflows
        run: |
          echo "🔍 Validating repaired workflows..."
          BROKEN_COUNT=0
          
          for file in .github/workflows/*.yml; do
            if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
              BROKEN_COUNT=$((BROKEN_COUNT + 1))
              echo "❌ Still broken: $file"
            fi
          done
          
          if [ $BROKEN_COUNT -gt 0 ]; then
            echo "❌ $BROKEN_COUNT workflows still have issues"
            exit 1
          else
            echo "✅ All workflows are now valid!"
          fi
      
      - name: Create Pull Request with fixes
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "🔧 fix(workflows): auto-repair broken GitHub Actions workflows"
          title: "🔧 Auto-repair broken GitHub Actions workflows"
          body: |
            ## Workflow Auto-Repair
            
            This PR automatically fixes **${{ needs.detect-broken-workflows.outputs.broken_count }}** broken GitHub Actions workflows.
            
            ### What was fixed:
            - Missing `runs-on:` specifications
            - Missing `steps:` sections
            - Incorrect indentation
            - Malformed YAML structure
            - Missing permissions and concurrency sections
            
            ### Files repaired:
            ${{ needs.detect-broken-workflows.outputs.broken_files }}
            
            ### Validation:
            ✅ All workflows now pass YAML validation
            
            ---
            *This PR was automatically created by the Workflow Auto-Healer*
          branch: automation/workflow-auto-repair
          delete-branch: true
          labels: |
            automation
            workflow-fix
            urgent
      
      - name: Enable Auto-merge
        if: success()
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
          merge-method: squash

  monitor-workflow-health:
    name: 📊 Monitor Workflow Health
    runs-on: ubuntu-latest
    needs: [detect-broken-workflows, repair-workflows]
    if: always()
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install PyYAML
        run: pip install pyyaml
      
      - name: Generate health report
        run: |
          echo "📊 Generating workflow health report..."
          
          TOTAL_WORKFLOWS=$(find .github/workflows -name "*.yml" | wc -l)
          BROKEN_WORKFLOWS=0
          WORKING_WORKFLOWS=0
          
          for file in .github/workflows/*.yml; do
            if python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
              WORKING_WORKFLOWS=$((WORKING_WORKFLOWS + 1))
            else
              BROKEN_WORKFLOWS=$((BROKEN_WORKFLOWS + 1))
            fi
          done
          
          HEALTH_PERCENTAGE=$((WORKING_WORKFLOWS * 100 / TOTAL_WORKFLOWS))
          
          echo "## Workflow Health Report" > workflow-health-report.md
          echo "Generated: $(date)" >> workflow-health-report.md
          echo "" >> workflow-health-report.md
          echo "- Total Workflows: $TOTAL_WORKFLOWS" >> workflow-health-report.md
          echo "- Working: $WORKING_WORKFLOWS" >> workflow-health-report.md
          echo "- Broken: $BROKEN_WORKFLOWS" >> workflow-health-report.md
          echo "- Health Score: $HEALTH_PERCENTAGE%" >> workflow-health-report.md
          echo "" >> workflow-health-report.md
          
          if [ $HEALTH_PERCENTAGE -eq 100 ]; then
            echo "🎉 All workflows are healthy!" >> workflow-health-report.md
          elif [ $HEALTH_PERCENTAGE -ge 80 ]; then
            echo "✅ Workflows are mostly healthy" >> workflow-health-report.md
          elif [ $HEALTH_PERCENTAGE -ge 60 ]; then
            echo "⚠️  Some workflow issues detected" >> workflow-health-report.md
          else
            echo "🚨 Critical workflow health issues" >> workflow-health-report.md
          fi
          
          cat workflow-health-report.md
      
      - name: Upload health report
        uses: actions/upload-artifact@v4
        with:
          name: workflow-health-report
          path: workflow-health-report.md