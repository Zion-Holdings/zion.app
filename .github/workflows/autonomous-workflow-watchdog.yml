name: Autonomous Workflow Watchdog

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  actions: write
  issues: write
  contents: read

concurrency:
  group: workflow-watchdog-${{ github.ref }}
  cancel-in-progress: true

jobs:

  watchdog:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Scan and remediate failed workflow runs
        id: scan
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const now = Date.now();
            const ageMs = 60 * 60 * 1000; // 1 hour window

            const { data } = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              per_page: 100,
              status: 'failure',
            });

            let rerunCount = 0;
            let issueCount = 0;

            for (const run of data.workflow_runs) {
              const createdMs = new Date(run.created_at).getTime();
              const tooOld = (now - createdMs) > ageMs;
              if (tooOld) continue;

              // Skip this very watchdog workflow to avoid self-trigger loops
              if ((run.name || '').toLowerCase().includes('watchdog')) continue;

              // Only consider completed failures
              if (run.status !== 'completed' || run.conclusion !== 'failure') continue;

              try {
                if ((run.run_attempt || 1) === 1) {
                  await github.rest.actions.reRunWorkflow({ owner, repo, run_id: run.id });
                  rerunCount++;
                } else {
                  const title = `[Watchdog] Investigate failing workflow: ${run.name} (#${run.run_number})`;
                  const q = `repo:${owner}/${repo} is:issue in:title "${title.replace(/"/g, '\\"')}"`;
                  const search = await github.rest.search.issuesAndPullRequests({ q });
                  const exists = (search.data.total_count || 0) > 0;
                  if (!exists) {
                    await github.rest.issues.create({
                      owner,
                      repo,
                      title,
                      body: `The workflow [${run.name}](${run.html_url}) continues to fail after a retry.\n\n- Run ID: ${run.id}\n- Run Number: ${run.run_number}\n- Event: ${run.event}\n- Head: ${run.head_branch}@${run.head_sha}\n\nPlease inspect logs and remediate.`,
                      labels: ['automation', 'watchdog', 'needs-investigation']
                    });
                    issueCount++;
                  }
                }
              } catch (e) {
                core.warning(`Error handling run ${run.id}: ${e.message}`);
              }
            }

            core.setOutput('reruns', rerunCount);
            core.setOutput('issues', issueCount);

      - name: Summary
        run: |
          echo "Reruns: ${{ steps.scan.outputs.reruns }}" >> $GITHUB_STEP_SUMMARY
          echo "Issues: ${{ steps.scan.outputs.issues }}" >> $GITHUB_STEP_SUMMARY
