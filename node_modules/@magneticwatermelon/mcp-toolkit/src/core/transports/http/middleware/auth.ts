import { IncomingMessage, ServerResponse } from "node:http";
import { parse as parseUrl } from "node:url";
import {
  type AuthConfig,
  type AuthProvider,
  type ResourceServerMetadata,
  type AuthResult,
  OAuthAuthProvider,
} from "../../../../auth";
import { logger } from "../../../../logger";

/**
 * MCP 2025-06-18 Authentication Middleware
 * Supports OAuth 2.1, Resource Server Metadata, and Dynamic Client Registration
 */
export class AuthMiddleware {
  constructor(private config: AuthConfig) {}

  // ADD a symbol to store authentication results on the request object
  private static readonly AUTH_RESULT_SYMBOL = Symbol.for("mcp.authResult");

  /**
   * Main authentication middleware handler
   */
  async handle(
    req: IncomingMessage,
    res: ServerResponse,
    next: () => Promise<void>
  ): Promise<void> {
    const url = new URL(req.url!, `http://${req.headers.host}`);

    // Handle OAuth discovery endpoints first
    if (await this.handleOAuthDiscovery(req, res, url)) {
      return;
    }

    // Apply authentication based on endpoint configuration
    const shouldAuthenticate = this.shouldAuthenticateEndpoint(
      url.pathname,
      req.method
    );

    if (!shouldAuthenticate) {
      await next();
      return;
    }

    // Perform authentication
    const authResult = await this.config.provider.authenticate(req);

    if (!authResult) {
      await this.handleAuthenticationFailure(req, res);
      return;
    }

    // Authentication successful, attach the result to the request for downstream middlewares
    (req as any)[AuthMiddleware.AUTH_RESULT_SYMBOL] =
      typeof authResult === "object" ? authResult : { data: {} };

    // Authentication successful, continue to next middleware
    logger.debug(`Authentication successful for ${req.socket.remoteAddress}`);
    await next();
  }

  /**
   * Handle OAuth 2.0 Protected Resource Metadata discovery (RFC 9728)
   */
  private async handleOAuthDiscovery(
    req: IncomingMessage,
    res: ServerResponse,
    url: URL
  ): Promise<boolean> {
    // OAuth 2.0 Protected Resource Metadata endpoint
    if (url.pathname === "/.well-known/oauth-protected-resource") {
      if (req.method !== "GET") {
        res.writeHead(405, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Method not allowed" }));
        return true;
      }

      if (this.config.provider instanceof OAuthAuthProvider) {
        const metadata = this.config.provider.getProtectedResourceMetadata();

        res.writeHead(200, {
          "Content-Type": "application/json",
          "Cache-Control": "public, max-age=3600", // Cache for 1 hour
        });
        res.end(JSON.stringify(metadata, null, 2));
        return true;
      }
    }

    // OAuth Authorization Server Metadata endpoint (if hosting authorization server)
    if (url.pathname === "/.well-known/oauth-authorization-server") {
      if (req.method !== "GET") {
        res.writeHead(405, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Method not allowed" }));
        return true;
      }

      // This would return authorization server metadata if we're hosting the auth server
      // For now, we'll return 404 as we're typically just a resource server
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(
        JSON.stringify({ error: "Authorization server metadata not available" })
      );
      return true;
    }

    return false;
  }

  /**
   * Determine if endpoint should be authenticated based on configuration
   */
  private shouldAuthenticateEndpoint(
    pathname: string,
    method?: string
  ): boolean {
    // Default authentication behavior
    const defaultAuth = {
      sse: false, // SSE connections typically don't require auth
      messages: true, // Message endpoints require auth by default
    };

    const authConfig = { ...defaultAuth, ...this.config.endpoints };

    // SSE connection endpoint (GET requests to MCP endpoint)
    if (method === "GET" && pathname.endsWith("/mcp")) {
      return authConfig.sse;
    }

    // Message endpoints (POST requests to MCP endpoint)
    if (method === "POST" && pathname.endsWith("/mcp")) {
      return authConfig.messages;
    }

    // DELETE requests for session termination
    if (method === "DELETE" && pathname.endsWith("/mcp")) {
      return authConfig.messages;
    }

    // Default to requiring authentication for other endpoints
    return true;
  }

  /**
   * Handle authentication failure with proper OAuth headers
   */
  private async handleAuthenticationFailure(
    req: IncomingMessage,
    res: ServerResponse
  ): Promise<void> {
    const authError = this.config.provider.getAuthError?.() || {
      status: 401,
      message: "Unauthorized",
    };

    // Add WWW-Authenticate header for OAuth providers
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };

    if (this.config.provider instanceof OAuthAuthProvider) {
      headers["WWW-Authenticate"] =
        this.config.provider.getWWWAuthenticateHeader();
    }

    res.writeHead(authError.status, headers);
    res.end(
      JSON.stringify({
        error: authError.message,
        error_description:
          "Valid authorization required to access this resource",
      })
    );

    logger.debug(
      `Authentication failed for ${req.socket.remoteAddress}: ${authError.message}`
    );
  }

  /**
   * Extract session ID from request headers
   */
  private getSessionId(req: IncomingMessage): string | undefined {
    return req.headers["mcp-session-id"] as string | undefined;
  }

  /**
   * Validate session binding for security (prevents session hijacking)
   */
  private validateSessionBinding(
    req: IncomingMessage,
    expectedUserId?: string
  ): boolean {
    const sessionId = this.getSessionId(req);

    if (!sessionId) {
      return true; // No session ID means no binding required
    }

    // In a real implementation, you'd validate the session ID
    // against the authenticated user and ensure it belongs to them
    if (expectedUserId) {
      // Validate session belongs to the authenticated user
      logger.debug(
        `Validating session ${sessionId} for user ${expectedUserId}`
      );
    }

    return true;
  }

  /**
   * Public helper for Express-style integration â€“ authenticates the request
   * without invoking the built-in `handle` method.
   * Returns `true` when the request is allowed to continue.
   */
  async authenticate(
    req: IncomingMessage,
    res: ServerResponse,
    endpoint: "sse" | "messages" | string = "messages"
  ): Promise<boolean> {
    // Determine if authentication is required for the given endpoint
    let shouldAuthenticate = true;
    if (endpoint === "sse") {
      shouldAuthenticate = this.config.endpoints?.sse ?? false;
    } else if (endpoint === "messages") {
      shouldAuthenticate = this.config.endpoints?.messages ?? true;
    }

    if (!shouldAuthenticate) {
      return true;
    }

    const authResult = await this.config.provider.authenticate(req);
    if (!authResult) {
      await this.handleAuthenticationFailure(req, res);
      return false;
    }

    // Persist authentication result on the request object
    (req as any)[AuthMiddleware.AUTH_RESULT_SYMBOL] =
      typeof authResult === "object" ? authResult : { data: {} };

    logger.debug(`Authentication successful for ${req.socket.remoteAddress}`);
    return true;
  }

  /**
   * Handle OAuth resource metadata (RFC 9728) discovery requests.
   * Returns `true` if the request was fully handled.
   */
  async handleResourceMetadata(
    req: IncomingMessage,
    res: ServerResponse
  ): Promise<boolean> {
    const url = new URL(req.url || "", `http://${req.headers.host}`);
    return this.handleOAuthDiscovery(req, res, url);
  }

  /**
   * Retrieve the previously attached authentication result for a request.
   */
  static getAuthResult(req: IncomingMessage): AuthResult | undefined {
    return (req as any)[AuthMiddleware.AUTH_RESULT_SYMBOL] as
      | AuthResult
      | undefined;
  }
}

/**
 * Helper function to create authentication middleware
 */
export function createAuthMiddleware(config: AuthConfig): AuthMiddleware {
  return new AuthMiddleware(config);
}

/**
 * Express-style middleware wrapper
 */
export function createExpressAuthMiddleware(config: AuthConfig) {
  const middleware = new AuthMiddleware(config);

  return async (
    req: IncomingMessage,
    res: ServerResponse,
    next: () => void
  ) => {
    // Check for OAuth metadata request first
    if (await middleware.handleResourceMetadata(req, res)) {
      return; // Request handled
    }

    // Determine endpoint type based on URL
    const url = parseUrl(req.url ?? "", true);
    const endpoint = url.pathname?.includes("/sse") ? "sse" : "messages";

    const authenticated = await middleware.authenticate(req, res, endpoint);
    if (authenticated) {
      next();
    }
    // If not authenticated, response is already sent by middleware
  };
}

/**
 * Middleware for validating OAuth scopes
 */
export class ScopeValidationMiddleware {
  constructor(private requiredScopes: string[]) {}

  validate(req: IncomingMessage, res: ServerResponse): boolean {
    const authResult = AuthMiddleware.getAuthResult(req);

    if (!authResult || typeof authResult !== "object" || !authResult.data) {
      return false;
    }

    const scopeString = (authResult.data as Record<string, any>).scope as
      | string
      | undefined;
    const tokenScopes = scopeString ? scopeString.split(" ") : [];
    const hasRequiredScopes = this.requiredScopes.every((scope) =>
      tokenScopes.includes(scope)
    );

    if (!hasRequiredScopes) {
      res.writeHead(403, { "Content-Type": "application/json" });
      res.end(
        JSON.stringify({
          error: "Insufficient scope",
          required_scopes: this.requiredScopes,
          provided_scopes: tokenScopes,
        })
      );
      return false;
    }

    return true;
  }
}

/**
 * Create scope validation middleware
 */
export function createScopeMiddleware(requiredScopes: string[]) {
  return new ScopeValidationMiddleware(requiredScopes);
}
