import { StdioServerTransport as SDKStdioTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { type BaseTransport } from "../../base";
import type { JSONRPCMessage } from "@modelcontextprotocol/sdk/types.js";
import { logger } from "../../../logger";

type ExtendedJSONRPCMessage = JSONRPCMessage & {
  result?: {
    content?: Array<{ type: string; [key: string]: unknown }>;
    [key: string]: unknown;
  };
};

export class StdioServerTransport implements BaseTransport {
  readonly type = "stdio";
  private transport: SDKStdioTransport;
  private running: boolean = false;

  constructor() {
    this.transport = new SDKStdioTransport();
  }

  async start(): Promise<void> {
    await this.transport.start();
    this.running = true;
  }

  async send(message: ExtendedJSONRPCMessage): Promise<void> {
    try {
      // Log outgoing raw JSON message
      logger.debug(
        `[STDIO] Outgoing raw JSON: ${JSON.stringify(message, null, 2)}`
      );
      await this.transport.send(message);
    } catch (error) {
      logger.error(`Error sending message through stdio transport: ${error}`);
      throw error;
    }
  }

  async close(): Promise<void> {
    await this.transport.close();
    this.running = false;
  }

  isRunning(): boolean {
    return this.running;
  }

  set onclose(handler: (() => void) | undefined) {
    this.transport.onclose = handler;
  }

  set onerror(handler: ((error: Error) => void) | undefined) {
    this.transport.onerror = handler;
  }

  set onmessage(handler: ((message: JSONRPCMessage) => void) | undefined) {
    if (handler) {
      // Wrap the handler to log incoming messages
      this.transport.onmessage = (message: JSONRPCMessage) => {
        // Log incoming raw JSON message
        logger.debug(
          `[STDIO] Incoming raw JSON: ${JSON.stringify(message, null, 2)}`
        );
        handler(message);
      };
    } else {
      this.transport.onmessage = handler;
    }
  }
}
