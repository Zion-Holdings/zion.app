import { readFile } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import type { SecretConfig } from "../cli/commands/env";

/**
 * Load environment variables from a file with optional validation
 */
export async function loadEnvFile(
  filePath: string
): Promise<Record<string, string>> {
  if (!existsSync(filePath)) {
    return {};
  }

  try {
    const content = await readFile(filePath, "utf-8");
    return parseEnvContent(content);
  } catch (error) {
    console.warn(`Warning: Failed to load env file ${filePath}:`, error);
    return {};
  }
}

/**
 * Parse environment file content into key-value pairs
 */
export function parseEnvContent(content: string): Record<string, string> {
  const env: Record<string, string> = {};

  const lines = content.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith("#")) {
      continue;
    }

    // Parse key=value format
    const equalIndex = trimmed.indexOf("=");
    if (equalIndex === -1) {
      continue;
    }

    const key = trimmed.substring(0, equalIndex).trim();
    let value = trimmed.substring(equalIndex + 1).trim();

    // Remove quotes if present
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    env[key] = value;
  }

  return env;
}

/**
 * Validate environment variables against secret configuration
 */
export function validateSecrets(
  env: Record<string, string>,
  secrets: Record<string, SecretConfig>
): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  const missing: string[] = [];

  for (const [name, config] of Object.entries(secrets)) {
    const value = env[name];

    // Check if required secret is missing
    if (config.required && (!value || value.trim() === "")) {
      missing.push(name);
      errors.push(`Required secret '${name}' is missing or empty`);
      continue;
    }

    // Skip validation if value is not provided (optional secrets)
    if (!value) {
      continue;
    }

    // Type validation
    const typeError = validateSecretType(name, value, config.type);
    if (typeError) {
      errors.push(typeError);
    }

    // Custom validation rules
    if (config.validation) {
      const validationError = validateSecretRules(
        name,
        value,
        config.validation
      );
      if (validationError) {
        errors.push(validationError);
      }
    }

    // Warnings for potentially insecure values
    const warning = checkSecretSecurity(name, value, config.type);
    if (warning) {
      warnings.push(warning);
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    missing,
  };
}

/**
 * Validate secret value type
 */
function validateSecretType(
  name: string,
  value: string,
  type?: string
): string | null {
  if (!type) return null;

  switch (type) {
    case "number":
      if (isNaN(Number(value))) {
        return `Secret '${name}' must be a valid number, got: ${value}`;
      }
      break;

    case "boolean":
      if (
        !["true", "false", "0", "1", "yes", "no"].includes(value.toLowerCase())
      ) {
        return `Secret '${name}' must be a boolean value (true/false), got: ${value}`;
      }
      break;

    case "url":
      try {
        new URL(value);
      } catch {
        return `Secret '${name}' must be a valid URL, got: ${value}`;
      }
      break;

    case "api_key":
      // Only validate length if explicit validation rules are provided
      // Otherwise, leave length validation to the warning system
      break;
  }

  return null;
}

/**
 * Validate secret against custom rules
 */
function validateSecretRules(
  name: string,
  value: string,
  rules: NonNullable<SecretConfig["validation"]>
): string | null {
  if (rules.pattern) {
    const regex = new RegExp(rules.pattern);
    if (!regex.test(value)) {
      return `Secret '${name}' does not match required pattern: ${rules.pattern}`;
    }
  }

  if (rules.minLength && value.length < rules.minLength) {
    return `Secret '${name}' must be at least ${rules.minLength} characters long`;
  }

  if (rules.maxLength && value.length > rules.maxLength) {
    return `Secret '${name}' must be no more than ${rules.maxLength} characters long`;
  }

  return null;
}

/**
 * Check for potential security issues with secret values
 */
function checkSecretSecurity(
  name: string,
  value: string,
  type?: string
): string | null {
  // Check for type-specific warnings first (more specific)

  // Check for API keys that look like examples
  if (
    type === "api_key" &&
    (value.includes("example") ||
      value.includes("test") ||
      value.includes("demo"))
  ) {
    return `Secret '${name}' appears to be a test/example API key`;
  }

  // Check for common insecure values (more general)
  const insecureValues = [
    "password",
    "123456",
    "admin",
    "test",
    "demo",
    "example",
    "your_key_here",
    "your_value_here",
    "changeme",
    "secret",
  ];

  if (insecureValues.includes(value.toLowerCase())) {
    return `Secret '${name}' appears to use a placeholder or insecure value: ${value}`;
  }

  // Check for URLs that point to localhost or example domains
  if (type === "url") {
    try {
      const url = new URL(value);
      if (
        url.hostname.includes("example.com") ||
        url.hostname.includes("localhost")
      ) {
        return `Secret '${name}' points to an example or local URL: ${value}`;
      }
    } catch {
      // URL validation already handled in type validation
    }
  }

  return null;
}

/**
 * Load environment variables with cascading priority
 * Priority: .env.local > .env.{NODE_ENV} > .env
 */
export async function loadEnvironment(
  projectRoot: string
): Promise<Record<string, string>> {
  const nodeEnv = process.env.NODE_ENV || "development";

  const envFiles = [
    join(projectRoot, ".env"),
    join(projectRoot, `.env.${nodeEnv}`),
    join(projectRoot, ".env.local"),
  ];

  let mergedEnv: Record<string, string> = {};

  // Load in priority order (later files override earlier ones)
  for (const envFile of envFiles) {
    const env = await loadEnvFile(envFile);
    mergedEnv = { ...mergedEnv, ...env };
  }

  return mergedEnv;
}

/**
 * Apply environment variables to process.env with validation
 */
export async function applyEnvironment(
  projectRoot: string,
  secretsConfig?: Record<string, SecretConfig>
): Promise<ApplyResult> {
  const env = await loadEnvironment(projectRoot);

  let validationResult: ValidationResult | null = null;

  if (secretsConfig) {
    validationResult = validateSecrets(env, secretsConfig);

    if (!validationResult.isValid) {
      return {
        success: false,
        validationResult,
        appliedCount: 0,
      };
    }
  }

  // Apply to process.env
  let appliedCount = 0;
  for (const [key, value] of Object.entries(env)) {
    if (value !== undefined) {
      process.env[key] = value;
      appliedCount++;
    }
  }

  return {
    success: true,
    validationResult,
    appliedCount,
  };
}

/**
 * Create a type-safe environment getter function
 */
export function createEnvGetter(secrets: Record<string, SecretConfig>) {
  return function getEnv<T = string>(key: string, defaultValue?: T): T {
    const value = process.env[key];
    const config = secrets[key];

    if (value === undefined) {
      if (config?.required && defaultValue === undefined) {
        throw new Error(`Required environment variable '${key}' is not set`);
      }
      return defaultValue as T;
    }

    // Type conversion based on secret configuration
    if (config?.type) {
      switch (config.type) {
        case "number":
          return Number(value) as T;
        case "boolean":
          return ["true", "1", "yes"].includes(value.toLowerCase()) as T;
        default:
          return value as T;
      }
    }

    return value as T;
  };
}

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  missing: string[];
}

export interface ApplyResult {
  success: boolean;
  validationResult: ValidationResult | null;
  appliedCount: number;
}
