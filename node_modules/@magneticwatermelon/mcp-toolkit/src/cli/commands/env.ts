import { writeFile, readFile, mkdir } from "fs/promises";
import { join, resolve } from "path";
import { existsSync } from "fs";
import promptsModule from "prompts";

// Helper function to get prompts (can be mocked in tests)
function getPrompts() {
  return (global as any).prompts || promptsModule;
}

export interface SecretConfig {
  name: string;
  description?: string;
  required?: boolean;
  type?: "string" | "number" | "boolean" | "url" | "api_key";
  defaultValue?: string;
  validation?: {
    pattern?: string;
    minLength?: number;
    maxLength?: number;
  };
}

export interface EnvConfigFile {
  secrets: Record<string, SecretConfig>;
  environments?: string[];
}

const SECRET_TYPES = {
  string: "Generic string value",
  number: "Numeric value",
  boolean: "Boolean value (true/false)",
  url: "URL/endpoint",
  api_key: "API key or token",
};

export async function envCommand(action: string, name?: string, options?: any) {
  const projectRoot = process.cwd();
  const envConfigPath = join(projectRoot, ".env.config.json");

  switch (action) {
    case "add":
      await addSecret(envConfigPath, name || undefined, options);
      break;
    case "remove":
      await removeSecret(envConfigPath, name || undefined, options);
      break;
    case "list":
      await listSecrets(envConfigPath);
      break;
    case "generate":
      await generateEnvFiles(envConfigPath, options?.env);
      break;
    case "init":
      await initSecretsConfig(envConfigPath, options);
      break;
    default:
      showEnvHelp();
  }
}

async function addSecret(configPath: string, name?: string, options: any = {}) {
  if (!existsSync(configPath)) {
    console.log(
      "No secrets configuration found. Run 'mcp-toolkit env init' first."
    );
    return;
  }

  let secretName = name;

  // Validate provided name if given
  if (secretName && !/^[A-Z][A-Z0-9_]*$/.test(secretName)) {
    console.log(
      `Invalid secret name '${secretName}'. Use UPPER_SNAKE_CASE format (e.g., API_KEY, DATABASE_URL)`
    );
    return;
  }

  if (!secretName) {
    const response = await getPrompts()({
      type: "text",
      name: "name",
      message: "Secret name (use UPPER_SNAKE_CASE):",
      validate: (value: string) =>
        /^[A-Z][A-Z0-9_]*$/.test(value) ||
        "Use UPPER_SNAKE_CASE format (e.g., API_KEY, DATABASE_URL)",
    });

    if (!response.name) {
      console.log("Operation cancelled");
      return;
    }
    secretName = response.name;
  }

  const configData = await readEnvConfig(configPath);

  if (configData.secrets[secretName!]) {
    console.log(
      `Secret '${secretName}' already exists. Use 'mcp-toolkit env remove ${secretName}' first.`
    );
    return;
  }

  // Check if we're in non-interactive mode (all essential options provided)
  const isNonInteractive =
    options.type !== undefined &&
    options.required !== undefined &&
    options.description !== undefined;

  // Use provided options or prompt for missing values
  let secretConfig: any = {};

  // Description
  if (options.description !== undefined) {
    secretConfig.description = options.description;
  } else if (!isNonInteractive) {
    const response = await getPrompts()({
      type: "text",
      name: "description",
      message: "Description (optional):",
      initial: "",
    });
    secretConfig.description = response.description;
  } else {
    secretConfig.description = "";
  }

  // Type
  if (options.type !== undefined) {
    if (!Object.keys(SECRET_TYPES).includes(options.type)) {
      console.log(
        `Invalid type '${options.type}'. Valid types: ${Object.keys(
          SECRET_TYPES
        ).join(", ")}`
      );
      return;
    }
    secretConfig.type = options.type;
  } else if (!isNonInteractive) {
    const response = await getPrompts()({
      type: "select",
      name: "type",
      message: "Secret type:",
      choices: Object.entries(SECRET_TYPES).map(([value, label]) => ({
        title: `${value} - ${label}`,
        value,
      })),
      initial: 0,
    });
    if (!response.type) {
      console.log("Operation cancelled");
      return;
    }
    secretConfig.type = response.type;
  } else {
    console.log("Type is required in non-interactive mode");
    return;
  }

  // Required
  if (options.required !== undefined) {
    secretConfig.required =
      options.required === true || options.required === "true";
  } else if (!isNonInteractive) {
    const response = await getPrompts()({
      type: "confirm",
      name: "required",
      message: "Is this secret required?",
      initial: true,
    });
    secretConfig.required = response.required;
  } else {
    secretConfig.required = true; // Default to required in non-interactive mode
  }

  // Default value
  if (options.default !== undefined) {
    secretConfig.defaultValue = options.default;
  } else if (!isNonInteractive) {
    const response = await getPrompts()({
      type: "text",
      name: "defaultValue",
      message: "Default value (optional, will be shown in .env.example):",
      initial: "",
    });
    secretConfig.defaultValue = response.defaultValue;
  } else {
    secretConfig.defaultValue = ""; // Empty default in non-interactive mode
  }

  const newSecret: SecretConfig = {
    name: secretName!,
    description: secretConfig.description || undefined,
    type: secretConfig.type,
    required: secretConfig.required,
    defaultValue: secretConfig.defaultValue || undefined,
  };

  // Add validation based on type
  if (secretConfig.type === "api_key") {
    newSecret.validation = { minLength: 8 };
  } else if (secretConfig.type === "url") {
    newSecret.validation = { pattern: "^https?://.*" };
  }

  configData.secrets[secretName!] = newSecret;
  await writeFile(configPath, JSON.stringify(configData, null, 2));

  console.log(`âœ… Secret '${secretName}' added successfully!`);
  console.log(`ðŸ’¡ Run 'mcp-toolkit env generate' to update your .env files`);
}

async function removeSecret(
  configPath: string,
  name?: string,
  options: any = {}
) {
  if (!name) {
    console.log("Please specify a secret name to remove");
    return;
  }

  if (!existsSync(configPath)) {
    console.log("No secrets configuration found.");
    return;
  }

  const configData = await readEnvConfig(configPath);

  if (!configData.secrets[name]) {
    console.log(`Secret '${name}' not found.`);
    return;
  }

  // Check if confirmation is provided in options
  if (options.force === true) {
    // Force removal without prompting
  } else if (options.remove !== undefined) {
    if (!options.remove) {
      console.log("Operation cancelled");
      return;
    }
  } else {
    // Prompt for confirmation
    const confirm = await getPrompts()({
      type: "confirm",
      name: "remove",
      message: `Remove secret '${name}'?`,
      initial: false,
    });

    if (!confirm.remove) {
      console.log("Operation cancelled");
      return;
    }
  }

  delete configData.secrets[name];
  await writeFile(configPath, JSON.stringify(configData, null, 2));

  console.log(`âœ… Secret '${name}' removed successfully!`);
  console.log(
    `ðŸ’¡ Don't forget to update your .env files and remove the actual values`
  );
}

async function listSecrets(configPath: string) {
  if (!existsSync(configPath)) {
    console.log(
      "No secrets configuration found. Run 'mcp-toolkit env init' first."
    );
    return;
  }

  const configData = await readEnvConfig(configPath);
  const secrets = Object.values(configData.secrets);

  if (secrets.length === 0) {
    console.log(
      "No secrets configured. Use 'mcp-toolkit env add' to add secrets."
    );
    return;
  }

  console.log("\nðŸ“‹ Configured Secrets:\n");

  secrets.forEach((secret) => {
    console.log(`${secret.name}`);
    if (secret.description) console.log(`  Description: ${secret.description}`);
    console.log(`  Type: ${secret.type}`);
    console.log(`  Required: ${secret.required ? "Yes" : "No"}`);
    if (secret.defaultValue) console.log(`  Default: ${secret.defaultValue}`);
    console.log("");
  });
}

async function generateEnvFiles(configPath: string, environment?: string) {
  if (!existsSync(configPath)) {
    console.log(
      "No secrets configuration found. Run 'mcp-toolkit env init' first."
    );
    return;
  }

  const configData = await readEnvConfig(configPath);
  const secrets = Object.values(configData.secrets);

  if (secrets.length === 0) {
    console.log(
      "No secrets configured. Use 'mcp-toolkit env add' to add secrets first."
    );
    return;
  }

  const projectRoot = process.cwd();

  // Generate .env.example
  await generateEnvExample(projectRoot, secrets);

  // Generate .env.local if it doesn't exist
  const envLocalPath = join(projectRoot, ".env.local");
  if (!existsSync(envLocalPath)) {
    await generateEnvTemplate(envLocalPath, secrets, false);
    console.log("ðŸ“„ Created .env.local template");
  }

  // Generate environment-specific files if requested
  if (environment) {
    const envFilePath = join(projectRoot, `.env.${environment}`);
    await generateEnvTemplate(envFilePath, secrets, false);
    console.log(`ðŸ“„ Created .env.${environment}`);
  }

  console.log("âœ… Environment files generated successfully!");
}

async function generateEnvExample(
  projectRoot: string,
  secrets: SecretConfig[]
) {
  const examplePath = join(projectRoot, ".env.example");

  let content = "# Environment Variables Configuration\n";
  content +=
    "# Copy this file to .env.local and fill in your actual values\n\n";

  const groupedSecrets = groupSecretsByType(secrets);

  Object.entries(groupedSecrets).forEach(([type, typeSecrets]) => {
    content += `# ${type.toUpperCase()} SECRETS\n`;
    typeSecrets.forEach((secret) => {
      if (secret.description) {
        content += `# ${secret.description}\n`;
      }
      content += `# Type: ${secret.type}${
        secret.required ? " (required)" : " (optional)"
      }\n`;

      const exampleValue = getExampleValue(secret);
      content += `${secret.name}=${exampleValue}\n\n`;
    });
  });

  await writeFile(examplePath, content);
  console.log("ðŸ“„ Updated .env.example");
}

async function generateEnvTemplate(
  filePath: string,
  secrets: SecretConfig[],
  includeExamples: boolean
) {
  let content = "# Environment Variables\n";
  content += `# Generated on ${new Date().toISOString()}\n\n`;

  secrets.forEach((secret) => {
    if (secret.description) {
      content += `# ${secret.description}\n`;
    }

    const value = includeExamples
      ? getExampleValue(secret)
      : secret.defaultValue || "";
    content += `${secret.name}=${value}\n\n`;
  });

  await writeFile(filePath, content);
}

function groupSecretsByType(
  secrets: SecretConfig[]
): Record<string, SecretConfig[]> {
  return secrets.reduce((groups, secret) => {
    const type = secret.type || "string";
    if (!groups[type]) groups[type] = [];
    groups[type].push(secret);
    return groups;
  }, {} as Record<string, SecretConfig[]>);
}

function getExampleValue(secret: SecretConfig): string {
  // Use the secret's default value if available
  if (secret.defaultValue) {
    return secret.defaultValue;
  }

  switch (secret.type) {
    case "api_key":
      return "your_api_key_here";
    case "url":
      return "https://api.example.com";
    case "boolean":
      return "true";
    case "number":
      return "3000";
    default:
      return "your_value_here";
  }
}

async function initSecretsConfig(configPath: string, options: any = {}) {
  if (existsSync(configPath)) {
    // Check if overwrite option is provided
    if (options.force === true) {
      // Force overwrite without prompting
    } else if (options.overwrite !== undefined) {
      if (!options.overwrite) {
        console.log("Operation cancelled");
        return;
      }
    } else {
      // Prompt for confirmation
      const overwrite = await getPrompts()({
        type: "confirm",
        name: "overwrite",
        message: "Secrets configuration already exists. Overwrite?",
        initial: false,
      });

      if (!overwrite.overwrite) {
        console.log("Operation cancelled");
        return;
      }
    }
  }

  const initialConfig: EnvConfigFile = {
    secrets: {},
    environments: ["development", "staging", "production"],
  };

  await writeFile(configPath, JSON.stringify(initialConfig, null, 2));
  console.log("âœ… Initialized secrets configuration at .env.config.json");
  console.log("ðŸ’¡ Use 'mcp-toolkit env add' to start adding secrets");
}

async function readEnvConfig(configPath: string): Promise<EnvConfigFile> {
  try {
    const content = await readFile(configPath, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    return { secrets: {} };
  }
}

function showEnvHelp() {
  console.log(`
mcp-toolkit env - Environment variables and secrets management

Usage:
  mcp-toolkit env <command> [options]

Commands:
  init                          Initialize secrets configuration
  add [secret-name]             Add a new secret interactively or with options
  remove <secret-name>          Remove a secret
  list                          List all configured secrets  
  generate [--env <name>]       Generate .env files from configuration

Options for 'add' command:
  --description <text>          Secret description
  --type <type>                 Secret type (string|number|boolean|url|api_key)
  --required <bool>             Whether secret is required (true|false)
  --default <value>             Default value for the secret

Examples:
  mcp-toolkit env init
  mcp-toolkit env add API_KEY
  mcp-toolkit env add API_KEY --type api_key --required true --description "OpenAI API key"
  mcp-toolkit env add DATABASE_URL --type url --description "PostgreSQL connection string"
  mcp-toolkit env add DEBUG_MODE --type boolean --required false --default false
  mcp-toolkit env list
  mcp-toolkit env generate
  mcp-toolkit env generate --env production
  mcp-toolkit env remove API_KEY
`);
}
