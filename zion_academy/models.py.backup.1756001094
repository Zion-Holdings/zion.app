from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    is_premium = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    profile_badge_url = db.Column(db.String(200), nullable=True)
    last_visit = db.Column(db.DateTime, default=datetime.utcnow)

    enrollments = db.relationship('Enrollment', back_populates='user', cascade="all, delete-orphan")
    certificates = db.relationship('Certificate', backref='user', lazy=True, cascade="all, delete-orphan")
<<<<<<< HEAD
    analytics_events = db.relationship('AnalyticsEvent', backref='user', lazy='dynamic', cascade="all, delete-orphan")
    feedback_submissions = db.relationship('FeedbackSubmission', backref='user', lazy='dynamic', cascade="all, delete-orphan")
=======
    update_reactions = db.relationship('UpdateReaction', backref='user', lazy=True, cascade="all, delete-orphan")
    update_comments = db.relationship('UpdateComment', backref='user', lazy=True, cascade="all, delete-orphan")
>>>>>>> origin/cursor/add-context-and-interaction-to-updates-4760

    def __repr__(self):
        return f'<User {self.username}>'

class Category(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False)
    courses = db.relationship('Course', backref='category', lazy=True)

    def __repr__(self):
        return f'<Category {self.name}>'

class Course(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(150), nullable=False)
    description = db.Column(db.Text, nullable=True)
    category_id = db.Column(db.Integer, db.ForeignKey('category.id'), nullable=False)
    is_premium_tier = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    lessons = db.relationship('Lesson', backref='course', lazy='dynamic', cascade="all, delete-orphan")
    quizzes = db.relationship('Quiz', backref='course', lazy='dynamic', cascade="all, delete-orphan")
    enrollments = db.relationship('Enrollment', back_populates='course', cascade="all, delete-orphan")
    certificates = db.relationship('Certificate', backref='course', lazy=True)
    analytics_events = db.relationship('AnalyticsEvent', backref='course', lazy='dynamic', cascade="all, delete-orphan")
    feedback_submissions = db.relationship('FeedbackSubmission', backref='course', lazy='dynamic', cascade="all, delete-orphan")

    def __repr__(self):
        return f'<Course {self.title}>'

class Lesson(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(150), nullable=False)
    content_type = db.Column(db.String(50), default='text') # e.g. 'video', 'text', 'exercise'
    content_data = db.Column(db.Text) # URL for video, markdown for text, JSON for exercise
    lesson_order = db.Column(db.Integer, nullable=False)
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    completions = db.relationship('LessonCompletion', backref='lesson', lazy='dynamic', cascade="all, delete-orphan")
    analytics_events = db.relationship('AnalyticsEvent', backref='lesson', lazy='dynamic', cascade="all, delete-orphan")
    feedback_submissions = db.relationship('FeedbackSubmission', backref='lesson', lazy='dynamic', cascade="all, delete-orphan")

    def __repr__(self):
        return f'<Lesson {self.title} - Course {self.course_id}>'

class Quiz(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(150), nullable=False)
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)
    lesson_id = db.Column(db.Integer, db.ForeignKey('lesson.id'), nullable=True) # Optional: if quiz is for a specific lesson
    is_final_exam = db.Column(db.Boolean, default=False)

    questions = db.relationship('Question', backref='quiz', lazy='dynamic', cascade="all, delete-orphan")

    def __repr__(self):
        return f'<Quiz {self.title} - Course {self.course_id}>'

class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'), nullable=False)
    text = db.Column(db.Text, nullable=False)
    question_type = db.Column(db.String(50), default='multiple_choice') # e.g. 'multiple_choice', 'true_false'
    options = db.Column(db.JSON, nullable=True) # Store options as JSON: e.g. [{"text": "Option A", "is_correct": false}, ...]

    def __repr__(self):
        return f'<Question {self.id} for Quiz {self.quiz_id}>'

class Enrollment(db.Model):
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), primary_key=True)
    enrolled_on = db.Column(db.DateTime, default=datetime.utcnow)
    progress = db.Column(db.Integer, default=0) # e.g. percentage or last completed lesson_id

    user = db.relationship("User", back_populates="enrollments")
    course = db.relationship("Course", back_populates="enrollments")
    lesson_completions = db.relationship('LessonCompletion', backref='enrollment', lazy='dynamic', cascade="all, delete-orphan")

    def __repr__(self):
        return f'<Enrollment User {self.user_id} in Course {self.course_id}>'

class LessonCompletion(db.Model):
    id = db.Column(db.Integer, primary_key=True) # Explicit PKey for LessonCompletion
    enrollment_user_id = db.Column(db.Integer, nullable=False)
    enrollment_course_id = db.Column(db.Integer, nullable=False)
    lesson_id = db.Column(db.Integer, db.ForeignKey('lesson.id'), nullable=False)
    completed_at = db.Column(db.DateTime, default=datetime.utcnow)

    __table_args__ = (
        db.ForeignKeyConstraint(
            ['enrollment_user_id', 'enrollment_course_id'],
            ['enrollment.user_id', 'enrollment.course_id']
        ),
    )

    def __repr__(self):
        return f'<LessonCompletion {self.id} - User {self.enrollment_user_id} completed Lesson {self.lesson_id} in Course {self.enrollment_course_id}>'

class Certificate(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)
    issued_at = db.Column(db.DateTime, default=datetime.utcnow)
    certificate_url = db.Column(db.String(200), nullable=True)

    def __repr__(self):
<<<<<<< HEAD
        return f'<Certificate {self.id} - User {self.user_id} for Course {self.course_id}>'

# New Analytics Models
class AnalyticsEvent(db.Model):
    """Track user interactions and behavior patterns"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)  # Nullable for anonymous users
    session_id = db.Column(db.String(100), nullable=False)  # Track anonymous sessions
    event_type = db.Column(db.String(50), nullable=False)  # 'view', 'click', 'scroll', 'time_spent'
    event_data = db.Column(db.JSON, nullable=True)  # Additional event-specific data
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Content tracking
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=True)
    lesson_id = db.Column(db.Integer, db.ForeignKey('lesson.id'), nullable=True)
    
    # User context
    user_agent = db.Column(db.String(500), nullable=True)
    ip_address = db.Column(db.String(45), nullable=True)  # IPv6 compatible
    referrer = db.Column(db.String(500), nullable=True)
    
    def __repr__(self):
        return f'<AnalyticsEvent {self.event_type} by User {self.user_id} at {self.timestamp}>'

class FeedbackSubmission(db.Model):
    """Collect user feedback for content improvement"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)  # Nullable for anonymous feedback
    feedback_type = db.Column(db.String(50), nullable=False)  # 'outdated', 'request_detail', 'bug_report', 'suggestion'
    content_type = db.Column(db.String(50), nullable=False)  # 'course', 'lesson', 'general'
    content_id = db.Column(db.Integer, nullable=True)  # ID of the specific content (course_id, lesson_id, etc.)
    
    # Feedback details
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text, nullable=False)
    priority = db.Column(db.String(20), default='medium')  # 'low', 'medium', 'high', 'critical'
    status = db.Column(db.String(20), default='open')  # 'open', 'in_progress', 'resolved', 'closed'
    
    # Metadata
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Admin response
    admin_response = db.Column(db.Text, nullable=True)
    resolved_at = db.Column(db.DateTime, nullable=True)
    
    # Relationships
    course = db.relationship('Course', backref='feedback_submissions', lazy='dynamic')
    lesson = db.relationship('Lesson', backref='feedback_submissions', lazy='dynamic')
    
    def __repr__(self):
        return f'<FeedbackSubmission {self.feedback_type} - {self.title}>'

class ContentAnalytics(db.Model):
    """Aggregated analytics for content performance"""
    id = db.Column(db.Integer, primary_key=True)
    content_type = db.Column(db.String(50), nullable=False)  # 'course', 'lesson'
    content_id = db.Column(db.Integer, nullable=False)
    date = db.Column(db.Date, nullable=False)
    
    # Metrics
    views = db.Column(db.Integer, default=0)
    unique_views = db.Column(db.Integer, default=0)
    clicks = db.Column(db.Integer, default=0)
    time_spent_seconds = db.Column(db.Integer, default=0)
    completion_rate = db.Column(db.Float, default=0.0)  # Percentage
    
    # Engagement metrics
    bounce_rate = db.Column(db.Float, default=0.0)
    avg_session_duration = db.Column(db.Float, default=0.0)
    
    # Feedback metrics
    feedback_count = db.Column(db.Integer, default=0)
    positive_feedback_ratio = db.Column(db.Float, default=0.0)
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    __table_args__ = (
        db.UniqueConstraint('content_type', 'content_id', 'date', name='unique_content_date'),
    )
    
    def __repr__(self):
        return f'<ContentAnalytics {self.content_type} {self.content_id} on {self.date}>'
=======
        return f'<Certificate {self.id} for U{self.user_id} - C{self.course_id}>'

class Update(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    summary = db.Column(db.String(300), nullable=True)  # Preview snippet
    update_type = db.Column(db.String(50), default='general')  # e.g., 'course', 'system', 'announcement'
    priority = db.Column(db.String(20), default='normal')  # 'low', 'normal', 'high', 'urgent'
    is_published = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    reactions = db.relationship('UpdateReaction', backref='update', lazy='dynamic', cascade="all, delete-orphan")
    comments = db.relationship('UpdateComment', backref='update', lazy='dynamic', cascade="all, delete-orphan")
    
    def __repr__(self):
        return f'<Update {self.title}>'
    
    def get_reaction_count(self, reaction_type):
        """Get count of specific reaction type"""
        return self.reactions.filter_by(reaction_type=reaction_type).count()
    
    def get_total_reactions(self):
        """Get total reaction count"""
        return self.reactions.count()

class UpdateReaction(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    update_id = db.Column(db.Integer, db.ForeignKey('update.id'), nullable=False)
    reaction_type = db.Column(db.String(20), nullable=False)  # 'useful', 'informative', 'urgent'
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Ensure one reaction per user per update
    __table_args__ = (db.UniqueConstraint('user_id', 'update_id', 'reaction_type'),)
    
    def __repr__(self):
        return f'<UpdateReaction {self.reaction_type} by User {self.user_id} on Update {self.update_id}>'

class UpdateComment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    update_id = db.Column(db.Integer, db.ForeignKey('update.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f'<UpdateComment {self.id} by User {self.user_id} on Update {self.update_id}>'
>>>>>>> origin/cursor/add-context-and-interaction-to-updates-4760
