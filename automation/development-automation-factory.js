const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');
const { v4: uuidv4 } = require('uuid');
const chokidar = require('chokidar');

class DevelopmentAutomationFactory {
  constructor() {
    this.agents = new Map();
    this.watchers = new Map();
    this.agentTypes = {
      'code-improvement': {
        capabilities: ['code-analysis', 'refactoring-suggestions', 'best-practices'],
        services: ['code-review', 'optimization-suggestions', 'pattern-detection'],
        dependencies: ['eslint', 'prettier', 'typescript'],
        config: {
          maxFileSize: 1000000,
          analysisDepth: 'deep',
          autoFix: false,
          suggestRefactoring: true
        }
      },
      'test-automation': {
        capabilities: ['test-generation', 'test-execution', 'coverage-analysis'],
        services: ['unit-tests', 'integration-tests', 'e2e-tests'],
        dependencies: ['jest', 'cypress', 'playwright'],
        config: {
          autoGenerateTests: true,
          coverageThreshold: 80,
          parallelExecution: true,
          testRetries: 2
        }
      },
      'deployment-automation': {
        capabilities: ['ci-cd', 'build-optimization', 'deployment-management'],
        services: ['automated-deployment', 'build-monitoring', 'rollback-management'],
        dependencies: ['github-actions', 'netlify-cli', 'vercel-cli'],
        config: {
          autoDeploy: true,
          buildOptimization: true,
          healthChecks: true,
          rollbackOnFailure: true
        }
      },
      'security-automation': {
        capabilities: ['vulnerability-scanning', 'security-auditing', 'dependency-checking'],
        services: ['security-scanning', 'vulnerability-reports', 'security-patches'],
        dependencies: ['npm-audit', 'snyk', 'semgrep'],
        config: {
          autoScan: true,
          vulnerabilityThreshold: 'high',
          autoPatch: false,
          securityReports: true
        }
      },
      'performance-optimization': {
        capabilities: ['performance-monitoring', 'optimization-suggestions', 'bundle-analysis'],
        services: ['performance-tracking', 'optimization-recommendations', 'bundle-optimization'],
        dependencies: ['lighthouse', 'webpack-bundle-analyzer', 'next-bundle-analyzer'],
        config: {
          performanceThreshold: 90,
          autoOptimize: true,
          bundleAnalysis: true,
          performanceReports: true
        }
      },
      'documentation-automation': {
        capabilities: ['doc-generation', 'api-documentation', 'readme-updates'],
        services: ['auto-documentation', 'api-docs', 'code-comments'],
        dependencies: ['jsdoc', 'typedoc', 'swagger'],
        config: {
          autoGenerateDocs: true,
          updateReadme: true,
          apiDocumentation: true,
          codeComments: true
        }
      },
      'code-review-automation': {
        capabilities: ['automated-review', 'quality-checks', 'code-standards'],
        services: ['pr-review', 'quality-analysis', 'standards-enforcement'],
        dependencies: ['eslint', 'prettier', 'husky'],
        config: {
          autoReview: true,
          qualityThreshold: 0.8,
          enforceStandards: true,
          prChecks: true
        }
      },
      'dependency-management': {
        capabilities: ['package-updates', 'security-patches', 'dependency-analysis'],
        services: ['auto-updates', 'security-scanning', 'dependency-reports'],
        dependencies: ['npm-check-updates', 'snyk', 'npm-audit'],
        config: {
          autoUpdate: false,
          securityPatches: true,
          dependencyReports: true,
          updateStrategy: 'conservative'
        }
      },
      'git-automation': {
        capabilities: ['commit-management', 'branch-strategy', 'merge-automation'],
        services: ['auto-commits', 'branch-cleanup', 'merge-assistance'],
        dependencies: ['simple-git', 'husky'],
        config: {
          autoCommit: false,
          branchCleanup: true,
          mergeStrategy: 'squash',
          commitConvention: 'conventional'
        }
      },
      'monitoring-automation': {
        capabilities: ['error-tracking', 'performance-monitoring', 'alert-management'],
        services: ['error-reports', 'performance-alerts', 'system-health'],
        dependencies: ['sentry', 'new-relic', 'datadog'],
        config: {
          errorTracking: true,
          performanceAlerts: true,
          healthChecks: true,
          alertThreshold: 0.1
        }
      }
    };
    this.loadAgentRegistry();
  }

  async createAgent(type, config = {}) {
    if (!this.agentTypes[type]) {
      throw new Error(`Unknown agent type: ${type}`);
    }

    const agentId = uuidv4();
    const agentConfig = {
      ...this.agentTypes[type].config,
      ...config,
      id: agentId,
      type,
      createdAt: new Date().toISOString(),
      status: 'created'
    };

    const agent = {
      id: agentId,
      type,
      config: agentConfig,
      status: 'created',
      process: null,
      logs: [],
      performance: {
        tasksCompleted: 0,
        errors: 0,
        lastActivity: null,
        averageResponseTime: 0
      }
    };

    this.agents.set(agentId, agent);
    await this.saveAgentRegistry();
    
    console.log(`Created development automation agent: ${agentId} (${type})`);
    return agentId;
  }

  async startAgent(agentId) {
    const agent = this.agents.get(agentId);
    if (!agent) {
      throw new Error(`Agent not found: ${agentId}`);
    }

    if (agent.status === 'running') {
      console.log(`Agent ${agentId} is already running`);
      return;
    }

    const scriptPath = this.getAgentScript(agent.type);
    if (!scriptPath) {
      throw new Error(`Script not found for agent type: ${agent.type}`);
    }

    try {
      const process = spawn('node', [scriptPath, agentId], {
        stdio: ['pipe', 'pipe', 'pipe'],
        env: {
          ...process.env,
          AGENT_ID: agentId,
          AGENT_TYPE: agent.type,
          AGENT_CONFIG: JSON.stringify(agent.config)
        }
      });

      agent.process = process;
      agent.status = 'running';
      agent.startedAt = new Date().toISOString();

      process.stdout.on('data', (data) => {
        this.logAgentOutput(agentId, 'stdout', data.toString());
      });

      process.stderr.on('data', (data) => {
        this.logAgentOutput(agentId, 'stderr', data.toString());
      });

      process.on('exit', (code) => {
        this.handleAgentExit(agentId, code);
      });

      process.on('error', (error) => {
        this.handleAgentError(agentId, error);
      });

      console.log(`Started development automation agent: ${agentId}`);
      await this.saveAgentRegistry();
    } catch (error) {
      console.error(`Failed to start agent ${agentId}:`, error);
      throw error;
    }
  }

  async stopAgent(agentId) {
    const agent = this.agents.get(agentId);
    if (!agent) {
      throw new Error(`Agent not found: ${agentId}`);
    }

    if (agent.process) {
      agent.process.kill('SIGTERM');
      agent.status = 'stopped';
      agent.stoppedAt = new Date().toISOString();
      await this.saveAgentRegistry();
      console.log(`Stopped development automation agent: ${agentId}`);
    }
  }

  async restartAgent(agentId) {
    await this.stopAgent(agentId);
    await new Promise(resolve => setTimeout(resolve, 1000));
    await this.startAgent(agentId);
  }

  async deleteAgent(agentId) {
    await this.stopAgent(agentId);
    this.agents.delete(agentId);
    await this.saveAgentRegistry();
    console.log(`Deleted development automation agent: ${agentId}`);
  }

  getAgent(agentId) {
    return this.agents.get(agentId);
  }

  getAllAgents() {
    return Array.from(this.agents.values());
  }

  getAgentsByType(type) {
    return Array.from(this.agents.values()).filter(agent => agent.type === type);
  }

  getRunningAgents() {
    return Array.from(this.agents.values()).filter(agent => agent.status === 'running');
  }

  async updateAgentConfig(agentId, newConfig) {
    const agent = this.agents.get(agentId);
    if (!agent) {
      throw new Error(`Agent not found: ${agentId}`);
    }

    agent.config = { ...agent.config, ...newConfig };
    await this.saveAgentRegistry();
    console.log(`Updated config for development automation agent: ${agentId}`);
  }

  async getAgentPerformance(agentId) {
    const agent = this.agents.get(agentId);
    if (!agent) {
      throw new Error(`Agent not found: ${agentId}`);
    }

    return {
      id: agentId,
      type: agent.type,
      status: agent.status,
      performance: agent.performance,
      uptime: agent.startedAt ? Date.now() - new Date(agent.startedAt).getTime() : 0,
      logs: agent.logs.slice(-100) // Last 100 log entries
    };
  }

  async getSystemMetrics() {
    const agents = Array.from(this.agents.values());
    const runningAgents = agents.filter(agent => agent.status === 'running');
    const totalTasks = agents.reduce((sum, agent) => sum + agent.performance.tasksCompleted, 0);
    const totalErrors = agents.reduce((sum, agent) => sum + agent.performance.errors, 0);

    return {
      totalAgents: agents.length,
      runningAgents: runningAgents.length,
      totalTasksCompleted: totalTasks,
      totalErrors: totalErrors,
      errorRate: totalTasks > 0 ? (totalErrors / totalTasks) * 100 : 0,
      averageResponseTime: agents.length > 0 ? 
        agents.reduce((sum, agent) => sum + agent.performance.averageResponseTime, 0) / agents.length : 0
    };
  }

  calculateSystemHealth() {
    const metrics = this.getSystemMetrics();
    const errorRate = metrics.errorRate;
    
    if (errorRate < 5) return 'good';
    if (errorRate < 15) return 'warning';
    return 'critical';
  }

  getAgentScript(type) {
    const scriptMap = {
      'code-improvement': 'agents/code-improvement-agent.js',
      'test-automation': 'agents/test-automation-agent.js',
      'deployment-automation': 'agents/deployment-automation-agent.js',
      'security-automation': 'agents/security-automation-agent.js',
      'performance-optimization': 'agents/performance-optimization-agent.js',
      'documentation-automation': 'agents/documentation-automation-agent.js',
      'code-review-automation': 'agents/code-review-automation-agent.js',
      'dependency-management': 'agents/dependency-management-agent.js',
      'git-automation': 'agents/git-automation-agent.js',
      'monitoring-automation': 'agents/monitoring-automation-agent.js'
    };

    return scriptMap[type] ? path.join(__dirname, scriptMap[type]) : null;
  }

  handleAgentExit(agentId, code) {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.status = 'stopped';
      agent.exitCode = code;
      agent.stoppedAt = new Date().toISOString();
      console.log(`Development automation agent ${agentId} exited with code ${code}`);
    }
  }

  handleAgentError(agentId, error) {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.performance.errors++;
      this.logAgentOutput(agentId, 'error', error.message);
      console.error(`Development automation agent ${agentId} error:`, error);
    }
  }

  logAgentOutput(agentId, type, data) {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.logs.push({
        timestamp: new Date().toISOString(),
        type,
        data: data.trim()
      });

      // Keep only last 1000 log entries
      if (agent.logs.length > 1000) {
        agent.logs = agent.logs.slice(-1000);
      }
    }
  }

  async loadAgentRegistry() {
    const registryPath = path.join(__dirname, 'development-agents-registry.json');
    try {
      if (fs.existsSync(registryPath)) {
        const data = fs.readFileSync(registryPath, 'utf8');
        const registry = JSON.parse(data);
        this.agents = new Map(registry.map(agent => [agent.id, agent]));
      }
    } catch (error) {
      console.error('Failed to load development agents registry:', error);
    }
  }

  async saveAgentRegistry() {
    const registryPath = path.join(__dirname, 'development-agents-registry.json');
    try {
      const registry = Array.from(this.agents.values());
      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2));
    } catch (error) {
      console.error('Failed to save development agents registry:', error);
    }
  }

  async createAgentTemplate(type, templateConfig) {
    const template = {
      type,
      config: templateConfig,
      createdAt: new Date().toISOString()
    };

    const templatesPath = path.join(__dirname, 'templates', 'development-templates.json');
    let templates = [];
    
    try {
      if (fs.existsSync(templatesPath)) {
        templates = JSON.parse(fs.readFileSync(templatesPath, 'utf8'));
      }
    } catch (error) {
      console.error('Failed to load templates:', error);
    }

    templates.push(template);
    fs.writeFileSync(templatesPath, JSON.stringify(templates, null, 2));
    
    console.log(`Created development automation template: ${type}`);
    return template;
  }

  async createAgentFromTemplate(templateName, config = {}) {
    const templatesPath = path.join(__dirname, 'templates', 'development-templates.json');
    let templates = [];
    
    try {
      if (fs.existsSync(templatesPath)) {
        templates = JSON.parse(fs.readFileSync(templatesPath, 'utf8'));
      }
    } catch (error) {
      throw new Error('Failed to load templates');
    }

    const template = templates.find(t => t.type === templateName);
    if (!template) {
      throw new Error(`Template not found: ${templateName}`);
    }

    const mergedConfig = { ...template.config, ...config };
    return await this.createAgent(templateName, mergedConfig);
  }

  async batchCreateAgents(agentSpecs) {
    const agentIds = [];
    for (const spec of agentSpecs) {
      try {
        const agentId = await this.createAgent(spec.type, spec.config);
        agentIds.push(agentId);
        
        if (spec.autoStart) {
          await this.startAgent(agentId);
        }
      } catch (error) {
        console.error(`Failed to create agent ${spec.type}:`, error);
      }
    }
    return agentIds;
  }

  async healthCheck() {
    const metrics = await this.getSystemMetrics();
    const health = this.calculateSystemHealth();
    
    return {
      status: health,
      metrics,
      timestamp: new Date().toISOString(),
      agents: Array.from(this.agents.values()).map(agent => ({
        id: agent.id,
        type: agent.type,
        status: agent.status,
        performance: agent.performance
      }))
    };
  }

  async checkAgentHealth(agentId) {
    const agent = this.agents.get(agentId);
    if (!agent) {
      return { status: 'not_found' };
    }

    const health = {
      id: agentId,
      type: agent.type,
      status: agent.status,
      performance: agent.performance,
      lastActivity: agent.performance.lastActivity,
      uptime: agent.startedAt ? Date.now() - new Date(agent.startedAt).getTime() : 0
    };

    return health;
  }

  // Development-specific methods
  async setupFileWatchers() {
    const projectRoot = path.resolve(__dirname, '..');
    
    // Watch for code changes
    const codeWatcher = chokidar.watch([
      path.join(projectRoot, 'src/**/*.{js,ts,jsx,tsx}'),
      path.join(projectRoot, 'pages/**/*.{js,ts,jsx,tsx}'),
      path.join(projectRoot, 'components/**/*.{js,ts,jsx,tsx}')
    ], {
      ignored: /node_modules|\.git|\.next/,
      persistent: true
    });

    codeWatcher.on('change', (filePath) => {
      this.handleCodeChange(filePath);
    });

    this.watchers.set('code', codeWatcher);
    console.log('Development file watchers setup complete');
  }

  async handleCodeChange(filePath) {
    console.log(`Code change detected: ${filePath}`);
    
    // Trigger code improvement agent
    const codeImprovementAgents = this.getAgentsByType('code-improvement');
    for (const agent of codeImprovementAgents) {
      if (agent.status === 'running') {
        // Send file change notification to agent
        this.logAgentOutput(agent.id, 'info', `File changed: ${filePath}`);
      }
    }
  }

  async setupContinuousIntegration() {
    // Setup CI/CD automation
    const deploymentAgents = this.getAgentsByType('deployment-automation');
    for (const agent of deploymentAgents) {
      if (agent.status === 'running') {
        await this.updateAgentConfig(agent.id, {
          ciEnabled: true,
          autoDeploy: true,
          buildOptimization: true
        });
      }
    }
  }

  async setupQualityGates() {
    // Setup quality gates for code review
    const reviewAgents = this.getAgentsByType('code-review-automation');
    for (const agent of reviewAgents) {
      if (agent.status === 'running') {
        await this.updateAgentConfig(agent.id, {
          qualityGates: true,
          enforceStandards: true,
          prChecks: true
        });
      }
    }
  }
}

module.exports = DevelopmentAutomationFactory; 