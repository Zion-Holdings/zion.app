#!/usr/bin/env node
"use strict";

const { spawnSync, execSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
<<<<<<< HEAD

class ComprehensiveRedundancySystem {
  constructor() {
    this.config = {
      pm2: {
        ecosystemFiles: ["ecosystem.pm2.cjs", "ecosystem.redundancy.cjs"],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
=======
const https = require("https");

class ComprehensiveRedundancySystem {
  constructor() {
    this.workspace = process.cwd();
    this.config = {
      pm2: {
        ecosystemFile: "ecosystem.pm2.cjs",
        redundancyEcosystemFile: "ecosystem.redundancy.cjs",
        processes: ["zion-auto-sync", "zion-auto-sync-cron"],
        redundancyProcesses: [
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor"
        ],
        healthCheckInterval: 30000,
        maxRestartAttempts: 5,
        restartDelay: 5000,
        autoRecovery: true
      },
      githubActions: {
        workflows: [
          ".github/workflows/marketing-sync.yml",
          ".github/workflows/sync-health.yml"
        ],
        healthCheckInterval: 60000,
        maxFailureThreshold: 3,
        autoTrigger: true,
<<<<<<< HEAD
        backupWorkflows: true
=======
        backupTriggers: true
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
      },
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        healthCheckInterval: 120000,
        maxFailureThreshold: 2,
        autoRegenerate: true,
        deploymentCheck: true
      },
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024,
        maxLogFiles: 30,
        logLevel: "INFO"
      },
      monitoring: {
        enabled: true,
        checkInterval: 30000,
        alertThreshold: 3,
        autoRestart: true
      }
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
    this.startComprehensiveMonitoring();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `comprehensive-redundancy-${new Date().toISOString().split('T')[0]}.log`);
<<<<<<< HEAD
    fs.appendFileSync(logFile, logEntry + "\n");
=======
    try {
      fs.appendFileSync(logFile, logEntry + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
<<<<<<< HEAD
        cwd: process.cwd(),
=======
        cwd: this.workspace,
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
<<<<<<< HEAD
=======
        timeout: options.timeout || 30000,
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

  async checkPM2ComprehensiveHealth() {
<<<<<<< HEAD
    this.log("üîç Performing comprehensive PM2 health check...");
=======
    this.log("üîç Checking comprehensive PM2 process health...");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
    
    try {
      // Check PM2 daemon status
      const statusResult = await this.runCommand("pm2", ["status", "--no-daemon"]);
      
      if (statusResult.status !== 0) {
<<<<<<< HEAD
        this.log("‚ö†Ô∏è PM2 daemon not responding, attempting restart", "WARN");
        await this.runCommand("pm2", ["kill"]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFiles[0]]);
        return false;
      }

      // Check each ecosystem file
      for (const ecosystemFile of this.config.pm2.ecosystemFiles) {
        if (!fs.existsSync(ecosystemFile)) {
          this.log(`‚ùå Ecosystem file ${ecosystemFile} not found`, "ERROR");
          continue;
        }
        
        this.log(`‚úÖ Found ecosystem file: ${ecosystemFile}`);
      }

      // Check each process
      const processes = this.config.pm2.processes;
      let allHealthy = true;
      let healthyCount = 0;

      for (const processName of processes) {
        const processStatus = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
        
        if (processStatus.status !== 0) {
          this.log(`‚ö†Ô∏è PM2 process ${processName} not found, attempting restart...`, "WARN");
          
          if (this.config.pm2.autoRecovery) {
            await this.runCommand("pm2", ["restart", processName]);
            await this.runCommand("pm2", ["save"]);
          }
          
          allHealthy = false;
        } else {
          healthyCount++;
          this.log(`‚úÖ Process ${processName} is healthy`);
        }
      }

      this.log(`üìä PM2 Health Summary: ${healthyCount}/${processes.length} processes healthy`);
      
      // Check PM2 logs for errors
      await this.checkPM2Logs();
      
      return allHealthy;
    } catch (error) {
      this.log(`‚ùå PM2 health check failed: ${error.message}`, "ERROR");
=======
        this.log("‚ö†Ô∏è PM2 daemon not running, attempting to restart", "WARN");
        await this.runCommand("pm2", ["kill"]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFile]);
        await this.runCommand("pm2", ["start", this.config.pm2.redundancyEcosystemFile]);
        return false;
      }

      // Check primary PM2 processes
      const primaryProcesses = this.config.pm2.processes;
      let primaryHealthy = true;

      for (const processName of primaryProcesses) {
        const processStatus = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
        
        if (processStatus.status !== 0) {
          this.log(`‚ö†Ô∏è Primary PM2 process ${processName} not found, restarting...`, "WARN");
          await this.runCommand("pm2", ["restart", processName]);
          primaryHealthy = false;
        } else {
          this.log(`‚úÖ Primary PM2 process ${processName} is healthy`);
        }
      }

      // Check redundancy PM2 processes
      const redundancyProcesses = this.config.pm2.redundancyProcesses;
      let redundancyHealthy = true;

      for (const processName of redundancyProcesses) {
        const processStatus = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
        
        if (processStatus.status !== 0) {
          this.log(`‚ö†Ô∏è Redundancy PM2 process ${processName} not found, restarting...`, "WARN");
          await this.runCommand("pm2", ["restart", processName]);
          redundancyHealthy = false;
        } else {
          this.log(`‚úÖ Redundancy PM2 process ${processName} is healthy`);
        }
      }

      return primaryHealthy && redundancyHealthy;
    } catch (error) {
      this.log(`‚ùå Error checking PM2 health: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
      return false;
    }
  }

<<<<<<< HEAD
  async checkPM2Logs() {
    try {
      const logResult = await this.runCommand("pm2", ["logs", "--lines", "50", "--nostream"]);
      
      if (logResult.status === 0) {
        const logs = logResult.stdout;
        const errorLines = logs.split('\n').filter(line => 
          line.toLowerCase().includes('error') || 
          line.toLowerCase().includes('failed') ||
          line.toLowerCase().includes('exception')
        );
        
        if (errorLines.length > 0) {
          this.log(`‚ö†Ô∏è Found ${errorLines.length} error lines in PM2 logs`, "WARN");
          errorLines.slice(0, 5).forEach(line => {
            this.log(`   ${line.trim()}`, "WARN");
          });
        }
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not check PM2 logs: ${error.message}`, "WARN");
    }
  }

  async checkGitHubActionsComprehensive() {
    this.log("üîç Performing comprehensive GitHub Actions health check...");
    
    try {
      // Check workflows directory
      const workflowsDir = ".github/workflows";
=======
  async checkGitHubActionsComprehensiveHealth() {
    this.log("üîç Checking comprehensive GitHub Actions health...");
    
    try {
      // Check workflows directory
      const workflowsDir = path.join(this.workspace, ".github/workflows");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
      if (!fs.existsSync(workflowsDir)) {
        this.log("‚ùå GitHub workflows directory not found", "ERROR");
        return false;
      }

<<<<<<< HEAD
      // Check each workflow file
      const workflows = this.config.githubActions.workflows;
      let allHealthy = true;
      let healthyCount = 0;

      for (const workflow of workflows) {
        const workflowPath = path.join(workflowsDir, workflow);
        
        if (!fs.existsSync(workflowPath)) {
          this.log(`‚ùå Workflow file ${workflow} not found`, "ERROR");
          allHealthy = false;
=======
      // Validate each workflow file
      const workflows = this.config.githubActions.workflows;
      let allWorkflowsHealthy = true;

      for (const workflow of workflows) {
        const workflowPath = path.join(this.workspace, workflow);
        if (!fs.existsSync(workflowPath)) {
          this.log(`‚ùå Workflow ${workflow} not found`, "ERROR");
          allWorkflowsHealthy = false;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
          continue;
        }

        try {
<<<<<<< HEAD
          const workflowContent = fs.readFileSync(workflowPath, 'utf8');
          
          // Basic YAML validation
          if (workflowContent.includes('name:') && workflowContent.includes('on:')) {
            healthyCount++;
            this.log(`‚úÖ Workflow ${workflow} is valid`);
          } else {
            this.log(`‚ö†Ô∏è Workflow ${workflow} appears to be invalid`, "WARN");
            allHealthy = false;
          }
        } catch (error) {
          this.log(`‚ùå Error reading workflow ${workflow}: ${error.message}`, "ERROR");
          allHealthy = false;
        }
      }

      this.log(`üìä GitHub Actions Health Summary: ${healthyCount}/${workflows.length} workflows healthy`);

      // Check for backup workflows
      if (this.config.githubActions.backupWorkflows) {
        await this.createBackupWorkflows();
      }

      return allHealthy;
    } catch (error) {
      this.log(`‚ùå GitHub Actions health check failed: ${error.message}`, "ERROR");
=======
          const workflowContent = fs.readFileSync(workflowPath, "utf8");
          if (!workflowContent.includes("name:") || !workflowContent.includes("on:")) {
            this.log(`‚ö†Ô∏è Workflow ${workflow} appears to be malformed`, "WARN");
            allWorkflowsHealthy = false;
          } else {
            this.log(`‚úÖ Workflow ${workflow} is valid`);
          }
        } catch (error) {
          this.log(`‚ùå Error reading workflow ${workflow}: ${error.message}`, "ERROR");
          allWorkflowsHealthy = false;
        }
      }

      // Check if workflows can be triggered manually
      if (this.config.githubActions.backupTriggers) {
        this.log("üîÑ Setting up backup triggers for GitHub Actions...");
        await this.setupGitHubActionsBackupTriggers();
      }

      return allWorkflowsHealthy;
    } catch (error) {
      this.log(`‚ùå Error checking GitHub Actions health: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
      return false;
    }
  }

<<<<<<< HEAD
    setInterval(async () => {
      await this.checkBuildHealth();
    }, this.config.build.healthCheckInterval);
    
    setInterval(async () => {
      await this.updateSystemHealth();
      
      if (this.config.monitoring.recoveryMode) {
        await this.performRecoveryActions();
      }
      
      await this.generateHealthReport();
    }, this.config.monitoring.overallHealthCheckInterval);
    
    this.log("‚úÖ Comprehensive redundancy monitoring started", "INFO");
  }

  async stopMonitoring() {
    this.log("üõë Stopping comprehensive redundancy monitoring...");
    // In a real implementation, you'd want to clear intervals
    this.log("‚úÖ Comprehensive redundancy monitoring stopped", "INFO");
  }

  async getStatus() {
    await this.updateSystemHealth();
    return {
      systemHealth: this.stats.systemHealth,
      stats: this.stats,
      lastRecovery: this.stats.lastRecovery,
      recoveryMode: this.config.monitoring.recoveryMode
    };
  }
}

// CLI interface
if (require.main === module) {
  const system = new ComprehensiveRedundancySystem();
  
  const command = process.argv[2];
  
  switch (command) {
    case 'start':
      system.startMonitoring();
      break;
    case 'stop':
      system.stopMonitoring();
      break;
    case 'status':
      system.getStatus().then(status => {
        console.log(JSON.stringify(status, null, 2));
        process.exit(0);
      });
      break;
    case 'health':
      Promise.all([
        system.checkPM2Health(),
        system.checkGitHubActionsHealth(),
        system.checkNetlifyFunctionsHealth(),
        system.checkBuildHealth()
      ]).then(results => {
        const [pm2, github, netlify, build] = results;
        console.log(`PM2: ${pm2 ? '‚úÖ' : '‚ùå'}`);
        console.log(`GitHub Actions: ${github ? '‚úÖ' : '‚ùå'}`);
        console.log(`Netlify Functions: ${netlify ? '‚úÖ' : '‚ùå'}`);
        console.log(`Build System: ${build ? '‚úÖ' : '‚ùå'}`);
        process.exit(0);
      });
      break;
    case 'recovery':
      system.performRecoveryActions().then(() => {
        console.log('Recovery completed');
        process.exit(0);
      });
      break;
    default:
      console.log('Usage: node comprehensive-redundancy-system.cjs [start|stop|status|health|recovery]');
      process.exit(1);
  }
=======
  async createBackupWorkflows() {
    try {
      const backupDir = ".github/workflows/backup";
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      const workflows = this.config.githubActions.workflows;
      for (const workflow of workflows) {
        const sourcePath = path.join(".github/workflows", workflow);
        const backupPath = path.join(backupDir, `${workflow}.backup`);
        
        if (fs.existsSync(sourcePath) && !fs.existsSync(backupPath)) {
          fs.copyFileSync(sourcePath, backupPath);
          this.log(`üíæ Created backup for workflow: ${workflow}`);
        }
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not create backup workflows: ${error.message}`, "WARN");
    }
  }

  async checkNetlifyFunctionsComprehensive() {
    this.log("üîç Performing comprehensive Netlify functions health check...");
    
    try {
      // Check Netlify directory structure
      const netlifyDir = "netlify";
=======
  async checkNetlifyFunctionsComprehensiveHealth() {
    this.log("üîç Checking comprehensive Netlify functions health...");
    
    try {
      // Check Netlify directory structure
      const netlifyDir = path.join(this.workspace, "netlify");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
      if (!fs.existsSync(netlifyDir)) {
        this.log("‚ùå Netlify directory not found", "ERROR");
        return false;
      }

      // Check functions directory
      const functionsDir = path.join(netlifyDir, "functions");
      if (!fs.existsSync(functionsDir)) {
        this.log("‚ùå Netlify functions directory not found", "ERROR");
        return false;
      }

      // Check functions manifest
<<<<<<< HEAD
      const manifestFile = this.config.netlifyFunctions.manifestFile;
      if (!fs.existsSync(manifestFile)) {
        this.log("‚ùå Netlify functions manifest not found", "ERROR");
        
        if (this.config.netlifyFunctions.autoRegenerate) {
          this.log("üîÑ Attempting to regenerate functions manifest...");
          await this.regenerateFunctionsManifest();
        }
        
        return false;
      }

      // Validate manifest
      try {
        const manifestContent = fs.readFileSync(manifestFile, 'utf8');
        const manifest = JSON.parse(manifestContent);
        
        if (manifest.functions && Array.isArray(manifest.functions)) {
          this.log(`‚úÖ Functions manifest is valid with ${manifest.functions.length} functions`);
          
          // Check for critical functions
          const criticalFunctions = [
            "netlify-auto-healer-runner",
            "marketing-scheduler",
            "homepage-updater-scheduler"
          ];
          
          let criticalCount = 0;
          for (const func of criticalFunctions) {
            if (manifest.functions.includes(func)) {
              criticalCount++;
              this.log(`‚úÖ Critical function found: ${func}`);
            } else {
              this.log(`‚ö†Ô∏è Critical function missing: ${func}`, "WARN");
            }
          }
          
          this.log(`üìä Critical Functions: ${criticalCount}/${criticalFunctions.length} present`);
        } else {
          this.log("‚ö†Ô∏è Functions manifest is invalid", "WARN");
          return false;
        }
      } catch (error) {
        this.log(`‚ùå Error parsing functions manifest: ${error.message}`, "ERROR");
        return false;
      }

      // Check deployment status if enabled
      if (this.config.netlifyFunctions.deploymentCheck) {
        await this.checkNetlifyDeployment();
      }

      return true;
    } catch (error) {
      this.log(`‚ùå Netlify functions health check failed: ${error.message}`, "ERROR");
=======
      const manifestPath = path.join(this.workspace, this.config.netlifyFunctions.manifestFile);
      if (!fs.existsSync(manifestPath)) {
        this.log("‚ö†Ô∏è Netlify functions manifest not found, regenerating...", "WARN");
        if (this.config.netlifyFunctions.autoRegenerate) {
          await this.regenerateNetlifyFunctionsManifest();
        }
        return false;
      }

      // Validate manifest content
      try {
        const manifestContent = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
        if (!manifestContent.functions || !Array.isArray(manifestContent.functions)) {
          this.log("‚ö†Ô∏è Netlify functions manifest is invalid, regenerating...", "WARN");
          if (this.config.netlifyFunctions.autoRegenerate) {
            await this.regenerateNetlifyFunctionsManifest();
          }
          return false;
        }

        this.log(`‚úÖ Netlify functions manifest is valid with ${manifestContent.functions.length} functions`);
        return true;
      } catch (error) {
        this.log(`‚ùå Error parsing Netlify functions manifest: ${error.message}`, "ERROR");
        return false;
      }
    } catch (error) {
      this.log(`‚ùå Error checking Netlify functions health: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
      return false;
    }
  }

<<<<<<< HEAD
  async regenerateFunctionsManifest() {
    try {
      const scriptPath = "scripts/generate-netlify-functions-manifest.cjs";
      
      if (fs.existsSync(scriptPath)) {
        const result = await this.runCommand("node", [scriptPath]);
        
        if (result.status === 0) {
          this.log("‚úÖ Successfully regenerated functions manifest");
        } else {
          this.log(`‚ö†Ô∏è Failed to regenerate manifest: ${result.stderr}`, "WARN");
        }
      } else {
        this.log("‚ö†Ô∏è Functions manifest generator script not found", "WARN");
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not regenerate functions manifest: ${error.message}`, "WARN");
    }
  }

  async checkNetlifyDeployment() {
    try {
      // Check if netlify CLI is available
      const netlifyResult = await this.runCommand("netlify", ["status"]);
      
      if (netlifyResult.status === 0) {
        this.log("‚úÖ Netlify CLI is available and deployment status checked");
      } else {
        this.log("‚ö†Ô∏è Netlify CLI not available or deployment check failed", "WARN");
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not check Netlify deployment: ${error.message}`, "WARN");
=======
  async setupGitHubActionsBackupTriggers() {
    this.log("üîÑ Setting up GitHub Actions backup triggers...");
    
    try {
      // Create backup trigger scripts for each workflow
      for (const workflow of this.config.githubActions.workflows) {
        const workflowName = workflow.replace('.yml', '').replace('.github/workflows/', '');
        const backupScriptPath = path.join(this.workspace, `automation/backup-trigger-${workflowName}.sh`);
        
        const backupScript = `#!/bin/bash
# Backup trigger for ${workflowName}
# This script provides redundancy for GitHub Actions workflows

WORKFLOW_NAME="${workflowName}"
WORKSPACE="${this.workspace}"

echo "[$(date)] Triggering backup execution for ${workflowName}"

# Check if we're in the right directory
cd "$WORKSPACE" || exit 1

# Run the equivalent of the workflow locally
case "$WORKFLOW_NAME" in
  "marketing-sync")
    echo "Running marketing sync backup..."
    node automation/marketing-sync.js
    ;;
  "sync-health")
    echo "Running sync health backup..."
    node automation/pm2-auto-sync.js
    ;;
  *)
    echo "Unknown workflow: $WORKFLOW_NAME"
    exit 1
    ;;
esac

echo "[$(date)] Backup execution for ${workflowName} completed"
`;

        fs.writeFileSync(backupScriptPath, backupScript);
        await this.runCommand("chmod", ["+x", backupScriptPath]);
        this.log(`‚úÖ Created backup trigger script for ${workflowName}`);
      }
    } catch (error) {
      this.log(`‚ùå Error setting up GitHub Actions backup triggers: ${error.message}`, "ERROR");
    }
  }

  async regenerateNetlifyFunctionsManifest() {
    this.log("üîÑ Regenerating Netlify functions manifest...");
    
    try {
      const result = await this.runCommand("node", ["scripts/generate-netlify-functions-manifest.cjs"]);
      
      if (result.status === 0) {
        this.log("‚úÖ Netlify functions manifest regenerated successfully");
        return true;
      } else {
        this.log(`‚ùå Failed to regenerate Netlify functions manifest: ${result.stderr}`, "ERROR");
        return false;
      }
    } catch (error) {
      this.log(`‚ùå Error regenerating Netlify functions manifest: ${error.message}`, "ERROR");
      return false;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
    }
  }

  async performComprehensiveHealthCheck() {
    this.log("üöÄ Starting comprehensive health check...");
    
    const results = {
      pm2: false,
      githubActions: false,
      netlifyFunctions: false,
      timestamp: new Date().toISOString()
    };

<<<<<<< HEAD
    // Check PM2
    try {
      results.pm2 = await this.checkPM2ComprehensiveHealth();
    } catch (error) {
      this.log(`‚ùå PM2 health check error: ${error.message}`, "ERROR");
    }

    // Check GitHub Actions
    try {
      results.githubActions = await this.checkGitHubActionsComprehensive();
    } catch (error) {
      this.log(`‚ùå GitHub Actions health check error: ${error.message}`, "ERROR");
    }

    // Check Netlify Functions
    try {
      results.netlifyFunctions = await this.checkNetlifyFunctionsComprehensive();
    } catch (error) {
      this.log(`‚ùå Netlify functions health check error: ${error.message}`, "ERROR");
    }

    // Generate health report
    const healthScore = Object.values(results).filter(Boolean).length;
    const totalChecks = Object.keys(results).length - 1; // Exclude timestamp
    
    this.log(`üìä Comprehensive Health Score: ${healthScore}/${totalChecks}`);
    
    if (healthScore === totalChecks) {
      this.log("üéâ All systems are healthy!");
    } else {
      this.log("‚ö†Ô∏è Some systems need attention", "WARN");
    }

    // Save health report
    await this.saveHealthReport(results);
    
    return results;
  }

  async saveHealthReport(results) {
    try {
      const reportPath = path.join(this.config.logging.logDir, "comprehensive-health-report.json");
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      this.log(`üíæ Health report saved to ${reportPath}`);
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not save health report: ${error.message}`, "WARN");
    }
  }

  async startComprehensiveMonitoring() {
    if (!this.config.monitoring.enabled) {
      this.log("üì¥ Comprehensive monitoring is disabled");
      return;
    }

    this.log("üîç Starting comprehensive monitoring...");
    
=======
    // Check PM2 health
    results.pm2 = await this.checkPM2ComprehensiveHealth();
    
    // Check GitHub Actions health
    results.githubActions = await this.checkGitHubActionsComprehensiveHealth();
    
    // Check Netlify functions health
    results.netlifyFunctions = await this.checkNetlifyFunctionsComprehensiveHealth();

    // Log results
    this.log(`üìä Health Check Results:
    - PM2: ${results.pm2 ? '‚úÖ Healthy' : '‚ùå Unhealthy'}
    - GitHub Actions: ${results.githubActions ? '‚úÖ Healthy' : '‚ùå Unhealthy'}
    - Netlify Functions: ${results.netlifyFunctions ? '‚úÖ Healthy' : '‚ùå Unhealthy'}`);

    // Save health check results
    const healthCheckFile = path.join(this.config.logging.logDir, `health-check-${new Date().toISOString().split('T')[0]}.json`);
    try {
      fs.writeFileSync(healthCheckFile, JSON.stringify(results, null, 2));
    } catch (error) {
      this.log(`‚ùå Failed to save health check results: ${error.message}`, "ERROR");
    }

    return results;
  }

  async startComprehensiveMonitoring() {
    this.log("üöÄ Starting comprehensive monitoring system...");
    
    if (!this.config.monitoring.enabled) {
      this.log("‚ö†Ô∏è Monitoring is disabled in configuration");
      return;
    }

    // Start monitoring loop
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
    setInterval(async () => {
      try {
        await this.performComprehensiveHealthCheck();
      } catch (error) {
<<<<<<< HEAD
        this.log(`‚ùå Monitoring cycle failed: ${error.message}`, "ERROR");
=======
        this.log(`‚ùå Error in monitoring loop: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
      }
    }, this.config.monitoring.checkInterval);

    this.log(`‚úÖ Comprehensive monitoring started with ${this.config.monitoring.checkInterval}ms intervals`);
  }

  async emergencyRecovery() {
<<<<<<< HEAD
    this.log("üö® Emergency recovery mode activated...");
    
    try {
      // Kill all PM2 processes
      await this.runCommand("pm2", ["kill"]);
      this.log("üîÑ Killed all PM2 processes");
      
      // Wait a moment
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // Restart with redundancy ecosystem
      await this.runCommand("pm2", ["start", "ecosystem.redundancy.cjs"]);
      this.log("üîÑ Restarted PM2 with redundancy ecosystem");
      
      // Save PM2 configuration
      await this.runCommand("pm2", ["save"]);
      this.log("üíæ Saved PM2 configuration");
      
      // Perform health check
      await this.performComprehensiveHealthCheck();
      
      this.log("‚úÖ Emergency recovery completed");
    } catch (error) {
      this.log(`‚ùå Emergency recovery failed: ${error.message}`, "ERROR");
    }
  }

  async gracefulShutdown() {
    this.log("üõë Graceful shutdown initiated...");
    
    try {
      // Save PM2 configuration
      await this.runCommand("pm2", ["save"]);
      
      // Stop monitoring
      this.log("üì¥ Monitoring stopped");
      
      this.log("‚úÖ Graceful shutdown completed");
      process.exit(0);
    } catch (error) {
      this.log(`‚ùå Graceful shutdown failed: ${error.message}`, "ERROR");
      process.exit(1);
=======
    this.log("üö® Starting emergency recovery procedures...");
    
    try {
      // Restart all PM2 processes
      this.log("üîÑ Restarting all PM2 processes...");
      await this.runCommand("pm2", ["kill"]);
      await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFile]);
      await this.runCommand("pm2", ["start", this.config.pm2.redundancyEcosystemFile]);
      
      // Regenerate Netlify functions manifest
      this.log("üîÑ Regenerating Netlify functions manifest...");
      await this.regenerateNetlifyFunctionsManifest();
      
      // Setup backup triggers
      this.log("üîÑ Setting up backup triggers...");
      await this.setupGitHubActionsBackupTriggers();
      
      this.log("‚úÖ Emergency recovery completed");
      return true;
    } catch (error) {
      this.log(`‚ùå Emergency recovery failed: ${error.message}`, "ERROR");
      return false;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
    }
  }

  initializeMonitoring() {
<<<<<<< HEAD
    // Handle process signals
    process.on('SIGINT', () => this.gracefulShutdown());
    process.on('SIGTERM', () => this.gracefulShutdown());
    
    // Handle uncaught exceptions
    process.on('uncaughtException', (error) => {
      this.log(`‚ùå Uncaught exception: ${error.message}`, "ERROR");
      this.emergencyRecovery();
    });
    
    // Handle unhandled rejections
    process.on('unhandledRejection', (reason, promise) => {
      this.log(`‚ùå Unhandled rejection at ${promise}: ${reason}`, "ERROR");
    });
    
    this.log("‚úÖ Process monitoring initialized");
=======
    this.log("üîß Initializing comprehensive redundancy monitoring system...");
    
    // Ensure all required directories exist
    const requiredDirs = [
      this.config.logging.logDir,
      path.join(this.workspace, "automation/logs"),
      path.join(this.workspace, ".github/workflows"),
      path.join(this.workspace, "netlify/functions")
    ];

    for (const dir of requiredDirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        this.log(`üìÅ Created directory: ${dir}`);
      }
    }

    this.log("‚úÖ Comprehensive redundancy monitoring system initialized");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
  }
}

// Start the comprehensive redundancy system
if (require.main === module) {
  const system = new ComprehensiveRedundancySystem();
  
<<<<<<< HEAD
  // Perform initial health check
  system.performComprehensiveHealthCheck().then(results => {
    console.log("üéØ Initial health check completed:", results);
  }).catch(error => {
    console.error("‚ùå Initial health check failed:", error);
=======
  // Handle graceful shutdown
  process.on('SIGINT', () => {
    system.log("üõë Shutting down comprehensive redundancy system...");
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    system.log("üõë Shutting down comprehensive redundancy system...");
    process.exit(0);
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
  });
}

module.exports = ComprehensiveRedundancySystem;