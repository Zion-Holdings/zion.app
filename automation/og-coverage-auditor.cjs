const fs = require('fs');
const path = require('path');
const fse = require('fs-extra');
const glob = require('glob');

function findTsxFiles(rootDir) {
  return glob.sync('**/*.tsx', {
    cwd: rootDir,
    absolute: true,
    ignore: ['**/.next/**', '**/node_modules/**']
  });
}

function analyzeFileForOg(headContent) {
  const required = ['og:title', 'og:description', 'og:image'];
  const found = {};
  for (const prop of required) {
    const re = new RegExp(`<meta[^>]+property=["']${prop}["']`, 'i');
    found[prop] = re.test(headContent);
  }
  return found;
}

function extractHeadBlocks(tsxContent) {
  // Very simple heuristic: capture content between <Head> ... </Head>
  const blocks = [];
  const headOpen = /<Head[^>]*>/gi;
  let match;
  while ((match = headOpen.exec(tsxContent)) !== null) {
    const startIdx = match.index + match[0].length;
    const rest = tsxContent.slice(startIdx);
    const closeIdxRel = rest.search(/<\/Head>/i);
    if (closeIdxRel !== -1) {
      const block = tsxContent.slice(startIdx, startIdx + closeIdxRel);
      blocks.push(block);
    }
  }
  return blocks;
}

function generateMarkdownReport(results) {
  const total = results.length;
  const withAny = results.filter(r => r.coverage.anyOg).length;
  const withAll = results.filter(r => r.coverage.allRequired).length;

  const lines = [];
  lines.push('# Open Graph Coverage Report');
  lines.push('');
  lines.push(`- Total TSX pages/components scanned: ${total}`);
  lines.push(`- With any og:* tags: ${withAny}`);
  lines.push(`- With all required (og:title, og:description, og:image): ${withAll}`);
  lines.push('');
  lines.push('## Missing Coverage');
  lines.push('');
  for (const r of results.filter(r => !r.coverage.allRequired)) {
    lines.push(`- ${r.relative} â€” missing: ${r.coverage.missing.join(', ') || 'none'}`);
  }
  lines.push('');
  lines.push('---');
  lines.push('Generated by og-coverage-auditor.cjs');
  return lines.join('\n');
}

function main() {
  const repoRoot = path.resolve(__dirname, '..');
  const pagesDir = path.join(repoRoot, 'pages');
  const componentsDir = path.join(repoRoot, 'components');

  const files = [
    ...findTsxFiles(pagesDir),
    ...findTsxFiles(componentsDir)
  ];

  const results = files.map(absPath => {
    const rel = path.relative(repoRoot, absPath);
    const content = fs.readFileSync(absPath, 'utf8');
    const headBlocks = extractHeadBlocks(content);

    let anyOg = false;
    let allRequired = false;
    let missing = [];

    if (headBlocks.length > 0) {
      // Combine all head blocks to check overall coverage
      const combined = headBlocks.join('\n');
      const found = analyzeFileForOg(combined);
      anyOg = Object.values(found).some(Boolean);
      allRequired = Object.values(found).every(Boolean);
      missing = Object.entries(found).filter(([, v]) => !v).map(([k]) => k);
    } else {
      anyOg = false;
      allRequired = false;
      missing = ['og:title', 'og:description', 'og:image'];
    }

    return {
      file: absPath,
      relative: rel,
      hasHead: headBlocks.length > 0,
      coverage: { anyOg, allRequired, missing }
    };
  });

  const outDir = path.join(repoRoot, 'docs', 'reports');
  fse.ensureDirSync(outDir);

  const jsonPath = path.join(outDir, 'og_coverage.json');
  const mdPath = path.join(outDir, 'og_coverage.md');
  fs.writeFileSync(jsonPath, JSON.stringify({ generatedAt: new Date().toISOString(), results }, null, 2));
  fs.writeFileSync(mdPath, generateMarkdownReport(results));

  console.log(`OG coverage written to: ${path.relative(repoRoot, mdPath)} and ${path.relative(repoRoot, jsonPath)}`);
}

if (require.main === module) {
  try {
    main();
    process.exit(0);
  } catch (err) {
    console.error('og-coverage-auditor failed:', err);
    process.exit(1);
  }
}