#!/usr/bin/env node
"use strict";

const { spawnSync, execSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

class ComprehensiveRedundancySystem {
  constructor() {
    this.config = {
      pm2: {
<<<<<<< HEAD
        ecosystemFiles: [
          "ecosystem.pm2.cjs",
          "ecosystem.redundancy.cjs", 
          "ecosystem-redundancy.pm2.cjs"
        ],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
          "zion-auto-sync-backup",
          "zion-auto-sync-cron-backup",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor",
          "redundancy-master-orchestrator",
          "redundancy-pm2-manager",
          "redundancy-github-manager",
          "redundancy-netlify-manager",
          "build-monitor-backup",
          "git-sync-backup",
          "netlify-healer-backup"
        ],
        healthCheckInterval: 30000,
        maxRestartAttempts: 10,
        restartDelay: 3000
=======
        ecosystemFiles: ["ecosystem.pm2.cjs", "ecosystem.redundancy.cjs"],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor"
        ],
        healthCheckInterval: 30000,
        maxRestartAttempts: 5,
        restartDelay: 5000,
        autoRecovery: true
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
      },
      githubActions: {
        workflows: [
          ".github/workflows/marketing-sync.yml",
<<<<<<< HEAD
          ".github/workflows/marketing-sync-backup.yml",
          ".github/workflows/sync-health.yml",
          ".github/workflows/sync-health-backup.yml"
        ],
        healthCheckInterval: 45000,
        maxFailureThreshold: 5,
        backupWorkflows: [
          "marketing-sync-backup",
          "sync-health-backup"
        ]
      },
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        functionsDir: "netlify/functions",
        healthCheckInterval: 90000,
        maxFailureThreshold: 3,
        criticalFunctions: [
          "netlify-auto-healer-runner",
          "continuous-orchestrator",
          "site-maintenance-orchestrator"
        ]
      },
      build: {
        healthCheckInterval: 120000,
        maxBuildFailures: 5,
        buildTimeout: 600000,
        scripts: [
          "build",
          "build:heal",
          "build:smart",
          "build:auto-fix"
        ]
      },
      logging: {
        logDir: "automation/logs",
        maxLogSize: 15 * 1024 * 1024,
        maxLogFiles: 50
      },
      monitoring: {
        overallHealthCheckInterval: 60000,
        alertThreshold: 3,
        recoveryMode: false
      }
    };
    
    this.stats = {
      pm2Restarts: 0,
      githubFailures: 0,
      netlifyFailures: 0,
      buildFailures: 0,
      lastRecovery: null,
      systemHealth: "healthy"
    };
    
    this.ensureLogDirectory();
=======
          ".github/workflows/sync-health.yml"
        ],
        healthCheckInterval: 60000,
        maxFailureThreshold: 3,
        autoTrigger: true,
        backupWorkflows: true
      },
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        healthCheckInterval: 120000,
        maxFailureThreshold: 2,
        autoRegenerate: true,
        deploymentCheck: true
      },
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024,
        maxLogFiles: 30,
        logLevel: "INFO"
      },
      monitoring: {
        enabled: true,
        checkInterval: 30000,
        alertThreshold: 3,
        autoRestart: true
      }
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
    this.startComprehensiveMonitoring();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `comprehensive-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
<<<<<<< HEAD
        maxBuffer: 1024 * 1024 * 25,
        timeout: 30000,
=======
        maxBuffer: 1024 * 1024 * 20,
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  async checkPM2Health() {
    this.log("üîç Checking PM2 process health...");
    
    try {
      const statusResult = await this.runCommand("pm2", ["status", "--no-daemon"]);
      
      if (statusResult.status !== 0) {
        this.log("‚ö†Ô∏è PM2 status check failed, attempting to restart PM2", "WARN");
        await this.runCommand("pm2", ["kill"]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFiles[0]]);
        this.stats.pm2Restarts++;
        return false;
      }

      const processes = this.config.pm2.processes;
      let allHealthy = true;
      let failedProcesses = [];
=======
  async checkPM2ComprehensiveHealth() {
    this.log("üîç Performing comprehensive PM2 health check...");
    
    try {
      // Check PM2 daemon status
      const statusResult = await this.runCommand("pm2", ["status", "--no-daemon"]);
      
      if (statusResult.status !== 0) {
        this.log("‚ö†Ô∏è PM2 daemon not responding, attempting restart", "WARN");
        await this.runCommand("pm2", ["kill"]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFiles[0]]);
        return false;
      }

      // Check each ecosystem file
      for (const ecosystemFile of this.config.pm2.ecosystemFiles) {
        if (!fs.existsSync(ecosystemFile)) {
          this.log(`‚ùå Ecosystem file ${ecosystemFile} not found`, "ERROR");
          continue;
        }
        
        this.log(`‚úÖ Found ecosystem file: ${ecosystemFile}`);
      }

      // Check each process
      const processes = this.config.pm2.processes;
      let allHealthy = true;
      let healthyCount = 0;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f

      for (const processName of processes) {
        const processStatus = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
        
        if (processStatus.status !== 0) {
<<<<<<< HEAD
          this.log(`‚ö†Ô∏è PM2 process ${processName} not found, restarting...`, "WARN");
          await this.runCommand("pm2", ["restart", processName]);
          failedProcesses.push(processName);
          allHealthy = false;
        } else {
          // Check if process is actually running
          const isRunning = await this.runCommand("pm2", ["jlist"]);
          if (isRunning.status === 0 && !isRunning.stdout.includes(`"name":"${processName}"`)) {
            this.log(`‚ö†Ô∏è PM2 process ${processName} not running, restarting...`, "WARN");
            await this.runCommand("pm2", ["restart", processName]);
            failedProcesses.push(processName);
            allHealthy = false;
          }
        }
      }

      if (failedProcesses.length > 0) {
        this.log(`üîÑ Restarted ${failedProcesses.length} PM2 processes: ${failedProcesses.join(", ")}`, "WARN");
        this.stats.pm2Restarts += failedProcesses.length;
      }

=======
          this.log(`‚ö†Ô∏è PM2 process ${processName} not found, attempting restart...`, "WARN");
          
          if (this.config.pm2.autoRecovery) {
            await this.runCommand("pm2", ["restart", processName]);
            await this.runCommand("pm2", ["save"]);
          }
          
          allHealthy = false;
        } else {
          healthyCount++;
          this.log(`‚úÖ Process ${processName} is healthy`);
        }
      }

      this.log(`üìä PM2 Health Summary: ${healthyCount}/${processes.length} processes healthy`);
      
      // Check PM2 logs for errors
      await this.checkPM2Logs();
      
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
      return allHealthy;
    } catch (error) {
      this.log(`‚ùå PM2 health check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

<<<<<<< HEAD
  async checkGitHubActionsHealth() {
    this.log("üîç Checking GitHub Actions health...");
    
    try {
      let allHealthy = true;
      let failedWorkflows = [];

      for (const workflow of this.config.githubActions.workflows) {
        if (!fs.existsSync(workflow)) {
          this.log(`‚ö†Ô∏è GitHub workflow ${workflow} not found`, "WARN");
          failedWorkflows.push(workflow);
=======
  async checkPM2Logs() {
    try {
      const logResult = await this.runCommand("pm2", ["logs", "--lines", "50", "--nostream"]);
      
      if (logResult.status === 0) {
        const logs = logResult.stdout;
        const errorLines = logs.split('\n').filter(line => 
          line.toLowerCase().includes('error') || 
          line.toLowerCase().includes('failed') ||
          line.toLowerCase().includes('exception')
        );
        
        if (errorLines.length > 0) {
          this.log(`‚ö†Ô∏è Found ${errorLines.length} error lines in PM2 logs`, "WARN");
          errorLines.slice(0, 5).forEach(line => {
            this.log(`   ${line.trim()}`, "WARN");
          });
        }
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not check PM2 logs: ${error.message}`, "WARN");
    }
  }

  async checkGitHubActionsComprehensive() {
    this.log("üîç Performing comprehensive GitHub Actions health check...");
    
    try {
      // Check workflows directory
      const workflowsDir = ".github/workflows";
      if (!fs.existsSync(workflowsDir)) {
        this.log("‚ùå GitHub workflows directory not found", "ERROR");
        return false;
      }

      // Check each workflow file
      const workflows = this.config.githubActions.workflows;
      let allHealthy = true;
      let healthyCount = 0;

      for (const workflow of workflows) {
        const workflowPath = path.join(workflowsDir, workflow);
        
        if (!fs.existsSync(workflowPath)) {
          this.log(`‚ùå Workflow file ${workflow} not found`, "ERROR");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
          allHealthy = false;
          continue;
        }

<<<<<<< HEAD
        // Check workflow syntax and validity
        try {
          const workflowContent = fs.readFileSync(workflow, 'utf8');
          if (!workflowContent.includes('name:') || !workflowContent.includes('on:')) {
            this.log(`‚ö†Ô∏è GitHub workflow ${workflow} has invalid syntax`, "WARN");
            failedWorkflows.push(workflow);
            allHealthy = false;
          }
        } catch (error) {
          this.log(`‚ö†Ô∏è Error reading GitHub workflow ${workflow}: ${error.message}`, "WARN");
          failedWorkflows.push(workflow);
=======
        try {
          const workflowContent = fs.readFileSync(workflowPath, 'utf8');
          
          // Basic YAML validation
          if (workflowContent.includes('name:') && workflowContent.includes('on:')) {
            healthyCount++;
            this.log(`‚úÖ Workflow ${workflow} is valid`);
          } else {
            this.log(`‚ö†Ô∏è Workflow ${workflow} appears to be invalid`, "WARN");
            allHealthy = false;
          }
        } catch (error) {
          this.log(`‚ùå Error reading workflow ${workflow}: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
          allHealthy = false;
        }
      }

<<<<<<< HEAD
      if (failedWorkflows.length > 0) {
        this.log(`üîÑ Found ${failedWorkflows.length} problematic GitHub workflows: ${failedWorkflows.join(", ")}`, "WARN");
        this.stats.githubFailures += failedWorkflows.length;
        
        // Attempt to restore from backup workflows
        await this.restoreGitHubWorkflows(failedWorkflows);
=======
      this.log(`üìä GitHub Actions Health Summary: ${healthyCount}/${workflows.length} workflows healthy`);

      // Check for backup workflows
      if (this.config.githubActions.backupWorkflows) {
        await this.createBackupWorkflows();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
      }

      return allHealthy;
    } catch (error) {
      this.log(`‚ùå GitHub Actions health check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

<<<<<<< HEAD
  async restoreGitHubWorkflows(failedWorkflows) {
    this.log("üîÑ Attempting to restore GitHub workflows from backups...");
    
    for (const workflow of failedWorkflows) {
      const backupWorkflow = workflow.replace('.yml', '-backup.yml');
      
      if (fs.existsSync(backupWorkflow)) {
        try {
          fs.copyFileSync(backupWorkflow, workflow);
          this.log(`‚úÖ Restored ${workflow} from backup`, "INFO");
        } catch (error) {
          this.log(`‚ùå Failed to restore ${workflow} from backup: ${error.message}`, "ERROR");
        }
      }
    }
  }

  async checkNetlifyFunctionsHealth() {
    this.log("üîç Checking Netlify Functions health...");
    
    try {
      let allHealthy = true;
      let failedFunctions = [];

      // Check manifest file
      if (!fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        this.log("‚ö†Ô∏è Netlify functions manifest not found", "WARN");
        allHealthy = false;
      } else {
        try {
          const manifest = JSON.parse(fs.readFileSync(this.config.netlifyFunctions.manifestFile, 'utf8'));
          if (!manifest.functions || manifest.functions.length === 0) {
            this.log("‚ö†Ô∏è Netlify functions manifest is empty", "WARN");
            allHealthy = false;
          }
        } catch (error) {
          this.log(`‚ö†Ô∏è Error parsing Netlify functions manifest: ${error.message}`, "WARN");
          allHealthy = false;
        }
      }

      // Check critical functions
      for (const functionName of this.config.netlifyFunctions.criticalFunctions) {
        const functionFile = path.join(this.config.netlifyFunctions.functionsDir, `${functionName}.js`);
        if (!fs.existsSync(functionFile)) {
          this.log(`‚ö†Ô∏è Critical Netlify function ${functionName} not found`, "WARN");
          failedFunctions.push(functionName);
          allHealthy = false;
        }
      }

      if (failedFunctions.length > 0) {
        this.log(`üîÑ Found ${failedFunctions.length} failed Netlify functions: ${failedFunctions.join(", ")}`, "WARN");
        this.stats.netlifyFailures += failedFunctions.length;
        
        // Attempt to regenerate functions
        await this.regenerateNetlifyFunctions();
      }

      return allHealthy;
    } catch (error) {
      this.log(`‚ùå Netlify Functions health check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async regenerateNetlifyFunctions() {
    this.log("üîÑ Attempting to regenerate Netlify functions...");
    
    try {
      const result = await this.runCommand("npm", ["run", "netlify:manifest"]);
      if (result.status === 0) {
        this.log("‚úÖ Successfully regenerated Netlify functions manifest", "INFO");
      } else {
        this.log(`‚ö†Ô∏è Failed to regenerate Netlify functions: ${result.stderr}`, "WARN");
      }
    } catch (error) {
      this.log(`‚ùå Error regenerating Netlify functions: ${error.message}`, "ERROR");
    }
  }

  async checkBuildHealth() {
    this.log("üîç Checking build system health...");
    
    try {
      let allHealthy = true;
      let failedBuilds = [];

      for (const buildScript of this.config.build.scripts) {
        try {
          // Check if build script exists in package.json
          const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          if (!packageJson.scripts[buildScript]) {
            this.log(`‚ö†Ô∏è Build script ${buildScript} not found in package.json`, "WARN");
            failedBuilds.push(buildScript);
            allHealthy = false;
          }
        } catch (error) {
          this.log(`‚ö†Ô∏è Error checking build script ${buildScript}: ${error.message}`, "WARN");
          failedBuilds.push(buildScript);
          allHealthy = false;
        }
      }

      if (failedBuilds.length > 0) {
        this.log(`üîÑ Found ${failedBuilds.length} problematic build scripts: ${failedBuilds.join(", ")}`, "WARN");
        this.stats.buildFailures += failedBuilds.length;
      }

      return allHealthy;
    } catch (error) {
      this.log(`‚ùå Build health check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async performRecoveryActions() {
    this.log("üö® Performing recovery actions...");
    
    try {
      // Restart PM2 processes
      await this.runCommand("pm2", ["restart", "all"]);
      
      // Regenerate Netlify functions
      await this.regenerateNetlifyFunctions();
      
      // Restore GitHub workflows
      const failedWorkflows = this.config.githubActions.workflows.filter(w => !fs.existsSync(w));
      if (failedWorkflows.length > 0) {
        await this.restoreGitHubWorkflows(failedWorkflows);
      }
      
      this.stats.lastRecovery = new Date().toISOString();
      this.config.monitoring.recoveryMode = false;
      
      this.log("‚úÖ Recovery actions completed", "INFO");
    } catch (error) {
      this.log(`‚ùå Recovery actions failed: ${error.message}`, "ERROR");
    }
  }

  async updateSystemHealth() {
    const totalFailures = this.stats.pm2Restarts + this.stats.githubFailures + 
                         this.stats.netlifyFailures + this.stats.buildFailures;
    
    if (totalFailures === 0) {
      this.stats.systemHealth = "healthy";
    } else if (totalFailures <= this.config.monitoring.alertThreshold) {
      this.stats.systemHealth = "warning";
    } else {
      this.stats.systemHealth = "critical";
      this.config.monitoring.recoveryMode = true;
    }
  }

  async generateHealthReport() {
    const report = {
      timestamp: new Date().toISOString(),
      systemHealth: this.stats.systemHealth,
      stats: this.stats,
      config: {
        pm2: {
          ecosystemFiles: this.config.pm2.ecosystemFiles.length,
          processes: this.config.pm2.processes.length
        },
        githubActions: {
          workflows: this.config.githubActions.workflows.length
        },
        netlifyFunctions: {
          criticalFunctions: this.config.netlifyFunctions.criticalFunctions.length
        },
        build: {
          scripts: this.config.build.scripts.length
        }
      }
    };

    const reportFile = path.join(this.config.logging.logDir, `health-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    return report;
  }

  async startMonitoring() {
    this.log("üöÄ Starting comprehensive redundancy monitoring...");
    
    // Initial health checks
    await this.checkPM2Health();
    await this.checkGitHubActionsHealth();
    await this.checkNetlifyFunctionsHealth();
    await this.checkBuildHealth();
    
    // Start monitoring loops
    setInterval(async () => {
      await this.checkPM2Health();
    }, this.config.pm2.healthCheckInterval);
    
    setInterval(async () => {
      await this.checkGitHubActionsHealth();
    }, this.config.githubActions.healthCheckInterval);
    
    setInterval(async () => {
      await this.checkNetlifyFunctionsHealth();
    }, this.config.netlifyFunctions.healthCheckInterval);
    

/**
 * üöÄ Comprehensive Redundancy Automation System
 * 
 * This system provides complete redundancy coverage for:
 * - PM2 automation processes
 * - GitHub Actions workflows
 * - Netlify functions
 * - Build automation
 * - Health monitoring
 * - Auto-recovery mechanisms
 */

const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');
const cron = require('node-cron');

class ComprehensiveRedundancySystem {
    constructor() {
        this.config = {
            logLevel: process.env.REDUNDANCY_LOG_LEVEL || 'INFO',
            pm2CheckInterval: parseInt(process.env.REDUNDANCY_PM2_CHECK_INTERVAL) || 30000,
            githubCheckInterval: parseInt(process.env.REDUNDANCY_GITHUB_CHECK_INTERVAL) || 60000,
            netlifyCheckInterval: parseInt(process.env.REDUNDANCY_NETLIFY_CHECK_INTERVAL) || 120000,
            buildCheckInterval: parseInt(process.env.REDUNDANCY_BUILD_CHECK_INTERVAL) || 300000,
            healthCheckInterval: parseInt(process.env.REDUNDANCY_HEALTH_CHECK_INTERVAL) || 600000,
            maxRetries: parseInt(process.env.REDUNDANCY_MAX_RETRIES) || 5,
            retryDelay: parseInt(process.env.REDUNDANCY_RETRY_DELAY) || 10000
        };
        
        this.status = {
            pm2: { healthy: false, processes: [], lastCheck: null },
            github: { healthy: false, workflows: [], lastCheck: null },
            netlify: { healthy: false, functions: [], lastCheck: null },
            build: { healthy: false, lastBuild: null, lastCheck: null },
            overall: { healthy: false, lastCheck: null }
        };
        
        this.logs = [];
        this.isRunning = false;
        this.schedulers = [];
        
        this.setupLogging();
    }

    setupLogging() {
        const logDir = path.join(__dirname, 'logs');
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
        
        this.logFile = path.join(logDir, 'comprehensive-redundancy.log');
    }

    log(level, message, data = null) {
        const timestamp = new Date().toISOString();
        const logEntry = {
            timestamp,
            level,
            message,
            data
        };
        
        this.logs.push(logEntry);
        
        // Keep only last 1000 log entries
        if (this.logs.length > 1000) {
            this.logs = this.logs.slice(-1000);
        }
        
        // Write to file
        const logLine = `[${timestamp}] ${level}: ${message}${data ? ' ' + JSON.stringify(data) : ''}\n`;
        fs.appendFileSync(this.logFile, logLine);
        
        // Console output
        const colors = {
            INFO: '\x1b[36m',
            WARN: '\x1b[33m',
            ERROR: '\x1b[31m',
            SUCCESS: '\x1b[32m'
        };
        
        console.log(`${colors[level] || ''}[${level}]${colors[level] ? '\x1b[0m' : ''} ${message}`);
    }

    async checkPM2Redundancy() {
        try {
            this.log('INFO', 'Checking PM2 redundancy status...');
            
            // Check PM2 processes
            const pm2List = execSync('pm2 list', { encoding: 'utf8' });
            
            // Parse PM2 list output manually since --format json is not available
            const lines = pm2List.split('\n');
            const pm2Processes = [];
            
            // Find the data line (contains actual process info)
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // Look for lines that contain process data (have id, name, etc.)
                if (line && line.includes('‚îÇ') && line.match(/\d+/)) {
                    // Split by ‚îÇ character and extract relevant parts
                    const parts = line.split('‚îÇ').map(part => part.trim()).filter(part => part);
                    if (parts.length >= 4) {
                        pm2Processes.push({
                            id: parts[0],
                            name: parts[1],
                            mode: parts[2] || 'unknown',
                            status: parts[3] || 'unknown'
                        });
                    }
                }
            }
            
            const redundancyProcesses = pm2Processes.filter(proc => 
                proc.name.includes('redundancy') || 
                proc.name.includes('backup') ||
                proc.name.includes('zion-auto-sync') ||
                proc.name.includes('comprehensive') ||
                proc.name.includes('ecosystem')
            );
            
            this.status.pm2.processes = redundancyProcesses;
            this.status.pm2.healthy = redundancyProcesses.length >= 4; // At least 4 redundancy processes
            this.status.pm2.lastCheck = new Date();
            
            if (this.status.pm2.healthy) {
                this.log('SUCCESS', `PM2 redundancy healthy: ${redundancyProcesses.length} processes running`);
            } else {
                this.log('WARN', `PM2 redundancy unhealthy: only ${redundancyProcesses.length} processes running`);
                await this.recoverPM2Redundancy();
            }
            
        } catch (error) {
            this.log('ERROR', 'Failed to check PM2 redundancy', error.message);
            this.status.pm2.healthy = false;
            await this.recoverPM2Redundancy();
        }
    }

    async recoverPM2Redundancy() {
        try {
            this.log('INFO', 'Attempting to recover PM2 redundancy...');
            
            // Stop all PM2 processes
            execSync('pm2 stop all', { stdio: 'pipe' });
            execSync('pm2 delete all', { stdio: 'pipe' });
            
            // Start comprehensive redundancy ecosystem
            execSync('pm2 start ecosystem-comprehensive-redundancy.pm2.js', { stdio: 'pipe' });
            execSync('pm2 save', { stdio: 'pipe' });
            
            this.log('SUCCESS', 'PM2 redundancy recovered successfully');
            
        } catch (error) {
            this.log('ERROR', 'Failed to recover PM2 redundancy', error.message);
        }
    }

    async checkGitHubActionsRedundancy() {
        try {
            this.log('INFO', 'Checking GitHub Actions redundancy...');
            
            const workflowsDir = path.join(process.cwd(), '.github', 'workflows');
            const workflowFiles = fs.readdirSync(workflowsDir);
            
            const backupWorkflows = workflowFiles.filter(file => file.includes('backup'));
            const primaryWorkflows = workflowFiles.filter(file => !file.includes('backup'));
            
            this.status.github.workflows = {
                primary: primaryWorkflows,
                backup: backupWorkflows
            };
            
            // Check if we have backup workflows for each primary workflow
            const hasBackups = primaryWorkflows.every(primary => 
                backupWorkflows.some(backup => 
                    backup.replace('-backup.yml', '.yml') === primary
                )
            );
            
            this.status.github.healthy = hasBackups && backupWorkflows.length >= 2;
            this.status.github.lastCheck = new Date();
            
            if (this.status.github.healthy) {
                this.log('SUCCESS', `GitHub Actions redundancy healthy: ${backupWorkflows.length} backup workflows`);
            } else {
                this.log('WARN', 'GitHub Actions redundancy unhealthy: missing backup workflows');
                await this.recoverGitHubActionsRedundancy();
            }
            
        } catch (error) {
            this.log('ERROR', 'Failed to check GitHub Actions redundancy', error.message);
            this.status.github.healthy = false;
        }
    }

    async recoverGitHubActionsRedundancy() {
        try {
            this.log('INFO', 'Attempting to recover GitHub Actions redundancy...');
            
            // Create backup workflows if they don't exist
            const workflowsDir = path.join(process.cwd(), '.github', 'workflows');
            const workflowFiles = fs.readdirSync(workflowsDir);
            
            workflowFiles.forEach(workflow => {
                if (!workflow.includes('backup') && workflow.endsWith('.yml')) {
                    const backupName = workflow.replace('.yml', '-backup.yml');
                    const backupPath = path.join(workflowsDir, backupName);
                    
                    if (!fs.existsSync(backupPath)) {
                        const primaryContent = fs.readFileSync(path.join(workflowsDir, workflow), 'utf8');
                        const backupContent = primaryContent.replace(
                            /name: /,
                            'name: Backup '
                        );
                        fs.writeFileSync(backupPath, backupContent);
                        this.log('INFO', `Created backup workflow: ${backupName}`);
                    }
                }
            });
            
            this.log('SUCCESS', 'GitHub Actions redundancy recovered successfully');
            
        } catch (error) {
            this.log('ERROR', 'Failed to recover GitHub Actions redundancy', error.message);
        }
    }

    async checkNetlifyFunctionsRedundancy() {
        try {
            this.log('INFO', 'Checking Netlify functions redundancy...');
            
            const manifestPath = path.join(process.cwd(), 'netlify', 'functions', 'functions-manifest.json');
            
            if (!fs.existsSync(manifestPath)) {
                this.status.netlify.healthy = false;
                this.log('WARN', 'Netlify functions manifest not found');
                await this.recoverNetlifyFunctionsRedundancy();
                return;
            }
            
            const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
            this.status.netlify.functions = manifest.functions || [];
            
            // Check if we have a good number of functions
            this.status.netlify.healthy = this.status.netlify.functions.length >= 50;
            this.status.netlify.lastCheck = new Date();
            
            if (this.status.netlify.healthy) {
                this.log('SUCCESS', `Netlify functions redundancy healthy: ${this.status.netlify.functions.length} functions`);
            } else {
                this.log('WARN', `Netlify functions redundancy unhealthy: only ${this.status.netlify.functions.length} functions`);
                await this.recoverNetlifyFunctionsRedundancy();
            }
            
        } catch (error) {
            this.log('ERROR', 'Failed to check Netlify functions redundancy', error.message);
            this.status.netlify.healthy = false;
        }
    }

    async recoverNetlifyFunctionsRedundancy() {
        try {
            this.log('INFO', 'Attempting to recover Netlify functions redundancy...');
            
            // Regenerate functions manifest
            execSync('npm run netlify:manifest', { stdio: 'pipe' });
            
            this.log('SUCCESS', 'Netlify functions redundancy recovered successfully');
            
        } catch (error) {
            this.log('ERROR', 'Failed to recover Netlify functions redundancy', error.message);
        }
    }

    async checkBuildHealth() {
        try {
            this.log('INFO', 'Checking build health...');
            
            // Check if build files exist
            const buildFiles = [
                '.next',
                'out',
                'public'
            ];
            
            const buildExists = buildFiles.every(file => 
                fs.existsSync(path.join(process.cwd(), file))
            );
            
            this.status.build.healthy = buildExists;
            this.status.build.lastCheck = new Date();
            
            if (this.status.build.healthy) {
                this.log('SUCCESS', 'Build health check passed');
            } else {
                this.log('WARN', 'Build health check failed');
                await this.recoverBuildHealth();
            }
            
        } catch (error) {
            this.log('ERROR', 'Failed to check build health', error.message);
            this.status.build.healthy = false;
        }
    }

    async recoverBuildHealth() {
        try {
            this.log('INFO', 'Attempting to recover build health...');
            
            // Try to run a simple build first
            try {
                execSync('npm run build:health-check', { stdio: 'pipe' });
                this.log('SUCCESS', 'Build health check passed');
            } catch (error) {
                // If that fails, try to run the build
                try {
                    execSync('npm run build:validate', { stdio: 'pipe' });
                    this.log('SUCCESS', 'Build validation passed');
                } catch (validationError) {
                    this.log('WARN', 'Build validation failed, attempting basic build...');
                    // Try a basic build
                    execSync('npm run build', { stdio: 'pipe' });
                    this.log('SUCCESS', 'Basic build completed');
                }
            }
            
            this.log('SUCCESS', 'Build health recovered successfully');
            
        } catch (error) {
            this.log('ERROR', 'Failed to recover build health', error.message);
        }
    }

    updateOverallHealth() {
        const allHealthy = [
            this.status.pm2.healthy,
            this.status.github.healthy,
            this.status.netlify.healthy,
            this.status.build.healthy
        ].every(healthy => healthy);
        
        this.status.overall.healthy = allHealthy;
        this.status.overall.lastCheck = new Date();
        
        if (this.status.overall.healthy) {
            this.log('SUCCESS', 'Overall system health: HEALTHY');
        } else {
            this.log('WARN', 'Overall system health: UNHEALTHY');
        }
    }

    async runHealthCheck() {
        this.log('INFO', 'Running comprehensive health check...');
        
        await this.checkPM2Redundancy();
        await this.checkGitHubActionsRedundancy();
        await this.checkNetlifyFunctionsRedundancy();
        await this.checkBuildHealth();
        
        this.updateOverallHealth();
        
        this.log('INFO', 'Comprehensive health check completed');
    }

    startSchedulers() {
        this.log('INFO', 'Starting redundancy schedulers...');
        
        // PM2 redundancy check (every 30 seconds)
        const pm2Scheduler = cron.schedule('*/1 * * * *', () => {
            this.checkPM2Redundancy();
        });
        this.schedulers.push(pm2Scheduler);
        
        // GitHub Actions redundancy check (every 1 minute)
        const githubScheduler = cron.schedule('*/1 * * * *', () => {
            this.checkGitHubActionsRedundancy();
        });
        this.schedulers.push(githubScheduler);
        
        // Netlify functions redundancy check (every 2 minutes)
        const netlifyScheduler = cron.schedule('*/2 * * * *', () => {
            this.checkNetlifyFunctionsRedundancy();
        });
        this.schedulers.push(netlifyScheduler);
        
        // Build health check (every 5 minutes)
        const buildScheduler = cron.schedule('*/5 * * * *', () => {
            this.checkBuildHealth();
        });
        this.schedulers.push(buildScheduler);
        
        // Overall health check (every 10 minutes)
        const healthScheduler = cron.schedule('*/10 * * * *', () => {
            this.runHealthCheck();
        });
        this.schedulers.push(healthScheduler);
        
        this.log('SUCCESS', `Started ${this.schedulers.length} redundancy schedulers`);
    }

    stopSchedulers() {
        this.log('INFO', 'Stopping redundancy schedulers...');
        
        this.schedulers.forEach(scheduler => {
            scheduler.stop();
        });
        
        this.schedulers = [];
        this.log('SUCCESS', 'All redundancy schedulers stopped');
    }

    async start() {
        if (this.isRunning) {
            this.log('WARN', 'System is already running');
            return;
        }
        
        this.log('INFO', 'Starting comprehensive redundancy system...');
        
        try {
            // Initial health check
            await this.runHealthCheck();
            
            // Start schedulers
            this.startSchedulers();
            
            this.isRunning = true;
            this.log('SUCCESS', 'Comprehensive redundancy system started successfully');
            
            // Keep the process alive
            this.log('INFO', 'System is running. Press Ctrl+C to stop.');
            
            // Set up process signal handlers
            process.on('SIGINT', () => {
                this.log('INFO', 'Received SIGINT, shutting down gracefully...');
                this.stop().then(() => process.exit(0));
            });
            
            process.on('SIGTERM', () => {
                this.log('INFO', 'Received SIGTERM, shutting down gracefully...');
                this.stop().then(() => process.exit(0));
            });
            
            // Keep the event loop alive
            setInterval(() => {
                // This interval keeps the process alive
            }, 60000); // Check every minute
            
        } catch (error) {
            this.log('ERROR', 'Failed to start comprehensive redundancy system', error.message);
            throw error;
        }
    }

    async stop() {
        if (!this.isRunning) {
            this.log('WARN', 'System is not running');
            return;
        }
        
        this.log('INFO', 'Stopping comprehensive redundancy system...');
        
        try {
            this.stopSchedulers();
            this.isRunning = false;
            this.log('SUCCESS', 'Comprehensive redundancy system stopped successfully');
            
        } catch (error) {
            this.log('ERROR', 'Failed to stop comprehensive redundancy system', error.message);
            throw error;
        }
    }

    getStatus() {
        return {
            isRunning: this.isRunning,
            config: this.config,
            status: this.status,
            logs: this.logs.slice(-100) // Last 100 log entries
        };
    }

    generateReport() {
        const report = {
            timestamp: new Date().toISOString(),
            systemStatus: this.getStatus(),
            recommendations: []
        };
        
        // Generate recommendations based on status
        if (!this.status.pm2.healthy) {
            report.recommendations.push('PM2 redundancy needs attention - check process count and restart if necessary');
        }
        
        if (!this.status.github.healthy) {
            report.recommendations.push('GitHub Actions redundancy needs attention - ensure backup workflows exist');
        }
        
        if (!this.status.netlify.healthy) {
            report.recommendations.push('Netlify functions redundancy needs attention - regenerate functions manifest');
        }
        
        if (!this.status.build.healthy) {
            report.recommendations.push('Build health needs attention - run build recovery');
        }
        
        return report;
    }
=======
    setInterval(async () => {
      await this.checkBuildHealth();
    }, this.config.build.healthCheckInterval);
    
    setInterval(async () => {
      await this.updateSystemHealth();
      
      if (this.config.monitoring.recoveryMode) {
        await this.performRecoveryActions();
      }
      
      await this.generateHealthReport();
    }, this.config.monitoring.overallHealthCheckInterval);
    
    this.log("‚úÖ Comprehensive redundancy monitoring started", "INFO");
  }

  async stopMonitoring() {
    this.log("üõë Stopping comprehensive redundancy monitoring...");
    // In a real implementation, you'd want to clear intervals
    this.log("‚úÖ Comprehensive redundancy monitoring stopped", "INFO");
  }

  async getStatus() {
    await this.updateSystemHealth();
    return {
      systemHealth: this.stats.systemHealth,
      stats: this.stats,
      lastRecovery: this.stats.lastRecovery,
      recoveryMode: this.config.monitoring.recoveryMode
    };
  }
}

// CLI interface
if (require.main === module) {
  const system = new ComprehensiveRedundancySystem();
  
  const command = process.argv[2];
  
  switch (command) {
    case 'start':
      system.startMonitoring();
      break;
    case 'stop':
      system.stopMonitoring();
      break;
    case 'status':
      system.getStatus().then(status => {
        console.log(JSON.stringify(status, null, 2));
        process.exit(0);
      });
      break;
    case 'health':
      Promise.all([
        system.checkPM2Health(),
        system.checkGitHubActionsHealth(),
        system.checkNetlifyFunctionsHealth(),
        system.checkBuildHealth()
      ]).then(results => {
        const [pm2, github, netlify, build] = results;
        console.log(`PM2: ${pm2 ? '‚úÖ' : '‚ùå'}`);
        console.log(`GitHub Actions: ${github ? '‚úÖ' : '‚ùå'}`);
        console.log(`Netlify Functions: ${netlify ? '‚úÖ' : '‚ùå'}`);
        console.log(`Build System: ${build ? '‚úÖ' : '‚ùå'}`);
        process.exit(0);
      });
      break;
    case 'recovery':
      system.performRecoveryActions().then(() => {
        console.log('Recovery completed');
        process.exit(0);
      });
      break;
    default:
      console.log('Usage: node comprehensive-redundancy-system.cjs [start|stop|status|health|recovery]');
      process.exit(1);
  }
=======
  async createBackupWorkflows() {
    try {
      const backupDir = ".github/workflows/backup";
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      const workflows = this.config.githubActions.workflows;
      for (const workflow of workflows) {
        const sourcePath = path.join(".github/workflows", workflow);
        const backupPath = path.join(backupDir, `${workflow}.backup`);
        
        if (fs.existsSync(sourcePath) && !fs.existsSync(backupPath)) {
          fs.copyFileSync(sourcePath, backupPath);
          this.log(`üíæ Created backup for workflow: ${workflow}`);
        }
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not create backup workflows: ${error.message}`, "WARN");
    }
  }

  async checkNetlifyFunctionsComprehensive() {
    this.log("üîç Performing comprehensive Netlify functions health check...");
    
    try {
      // Check Netlify directory structure
      const netlifyDir = "netlify";
      if (!fs.existsSync(netlifyDir)) {
        this.log("‚ùå Netlify directory not found", "ERROR");
        return false;
      }

      // Check functions directory
      const functionsDir = path.join(netlifyDir, "functions");
      if (!fs.existsSync(functionsDir)) {
        this.log("‚ùå Netlify functions directory not found", "ERROR");
        return false;
      }

      // Check functions manifest
      const manifestFile = this.config.netlifyFunctions.manifestFile;
      if (!fs.existsSync(manifestFile)) {
        this.log("‚ùå Netlify functions manifest not found", "ERROR");
        
        if (this.config.netlifyFunctions.autoRegenerate) {
          this.log("üîÑ Attempting to regenerate functions manifest...");
          await this.regenerateFunctionsManifest();
        }
        
        return false;
      }

      // Validate manifest
      try {
        const manifestContent = fs.readFileSync(manifestFile, 'utf8');
        const manifest = JSON.parse(manifestContent);
        
        if (manifest.functions && Array.isArray(manifest.functions)) {
          this.log(`‚úÖ Functions manifest is valid with ${manifest.functions.length} functions`);
          
          // Check for critical functions
          const criticalFunctions = [
            "netlify-auto-healer-runner",
            "marketing-scheduler",
            "homepage-updater-scheduler"
          ];
          
          let criticalCount = 0;
          for (const func of criticalFunctions) {
            if (manifest.functions.includes(func)) {
              criticalCount++;
              this.log(`‚úÖ Critical function found: ${func}`);
            } else {
              this.log(`‚ö†Ô∏è Critical function missing: ${func}`, "WARN");
            }
          }
          
          this.log(`üìä Critical Functions: ${criticalCount}/${criticalFunctions.length} present`);
        } else {
          this.log("‚ö†Ô∏è Functions manifest is invalid", "WARN");
          return false;
        }
      } catch (error) {
        this.log(`‚ùå Error parsing functions manifest: ${error.message}`, "ERROR");
        return false;
      }

      // Check deployment status if enabled
      if (this.config.netlifyFunctions.deploymentCheck) {
        await this.checkNetlifyDeployment();
      }

      return true;
    } catch (error) {
      this.log(`‚ùå Netlify functions health check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async regenerateFunctionsManifest() {
    try {
      const scriptPath = "scripts/generate-netlify-functions-manifest.cjs";
      
      if (fs.existsSync(scriptPath)) {
        const result = await this.runCommand("node", [scriptPath]);
        
        if (result.status === 0) {
          this.log("‚úÖ Successfully regenerated functions manifest");
        } else {
          this.log(`‚ö†Ô∏è Failed to regenerate manifest: ${result.stderr}`, "WARN");
        }
      } else {
        this.log("‚ö†Ô∏è Functions manifest generator script not found", "WARN");
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not regenerate functions manifest: ${error.message}`, "WARN");
    }
  }

  async checkNetlifyDeployment() {
    try {
      // Check if netlify CLI is available
      const netlifyResult = await this.runCommand("netlify", ["status"]);
      
      if (netlifyResult.status === 0) {
        this.log("‚úÖ Netlify CLI is available and deployment status checked");
      } else {
        this.log("‚ö†Ô∏è Netlify CLI not available or deployment check failed", "WARN");
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not check Netlify deployment: ${error.message}`, "WARN");
    }
  }

  async performComprehensiveHealthCheck() {
    this.log("üöÄ Starting comprehensive health check...");
    
    const results = {
      pm2: false,
      githubActions: false,
      netlifyFunctions: false,
      timestamp: new Date().toISOString()
    };

    // Check PM2
    try {
      results.pm2 = await this.checkPM2ComprehensiveHealth();
    } catch (error) {
      this.log(`‚ùå PM2 health check error: ${error.message}`, "ERROR");
    }

    // Check GitHub Actions
    try {
      results.githubActions = await this.checkGitHubActionsComprehensive();
    } catch (error) {
      this.log(`‚ùå GitHub Actions health check error: ${error.message}`, "ERROR");
    }

    // Check Netlify Functions
    try {
      results.netlifyFunctions = await this.checkNetlifyFunctionsComprehensive();
    } catch (error) {
      this.log(`‚ùå Netlify functions health check error: ${error.message}`, "ERROR");
    }

    // Generate health report
    const healthScore = Object.values(results).filter(Boolean).length;
    const totalChecks = Object.keys(results).length - 1; // Exclude timestamp
    
    this.log(`üìä Comprehensive Health Score: ${healthScore}/${totalChecks}`);
    
    if (healthScore === totalChecks) {
      this.log("üéâ All systems are healthy!");
    } else {
      this.log("‚ö†Ô∏è Some systems need attention", "WARN");
    }

    // Save health report
    await this.saveHealthReport(results);
    
    return results;
  }

  async saveHealthReport(results) {
    try {
      const reportPath = path.join(this.config.logging.logDir, "comprehensive-health-report.json");
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      this.log(`üíæ Health report saved to ${reportPath}`);
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not save health report: ${error.message}`, "WARN");
    }
  }

  async startComprehensiveMonitoring() {
    if (!this.config.monitoring.enabled) {
      this.log("üì¥ Comprehensive monitoring is disabled");
      return;
    }

    this.log("üîç Starting comprehensive monitoring...");
    
    setInterval(async () => {
      try {
        await this.performComprehensiveHealthCheck();
      } catch (error) {
        this.log(`‚ùå Monitoring cycle failed: ${error.message}`, "ERROR");
      }
    }, this.config.monitoring.checkInterval);

    this.log(`‚úÖ Comprehensive monitoring started with ${this.config.monitoring.checkInterval}ms intervals`);
  }

  async emergencyRecovery() {
    this.log("üö® Emergency recovery mode activated...");
    
    try {
      // Kill all PM2 processes
      await this.runCommand("pm2", ["kill"]);
      this.log("üîÑ Killed all PM2 processes");
      
      // Wait a moment
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // Restart with redundancy ecosystem
      await this.runCommand("pm2", ["start", "ecosystem.redundancy.cjs"]);
      this.log("üîÑ Restarted PM2 with redundancy ecosystem");
      
      // Save PM2 configuration
      await this.runCommand("pm2", ["save"]);
      this.log("üíæ Saved PM2 configuration");
      
      // Perform health check
      await this.performComprehensiveHealthCheck();
      
      this.log("‚úÖ Emergency recovery completed");
    } catch (error) {
      this.log(`‚ùå Emergency recovery failed: ${error.message}`, "ERROR");
    }
  }

  async gracefulShutdown() {
    this.log("üõë Graceful shutdown initiated...");
    
    try {
      // Save PM2 configuration
      await this.runCommand("pm2", ["save"]);
      
      // Stop monitoring
      this.log("üì¥ Monitoring stopped");
      
      this.log("‚úÖ Graceful shutdown completed");
      process.exit(0);
    } catch (error) {
      this.log(`‚ùå Graceful shutdown failed: ${error.message}`, "ERROR");
      process.exit(1);
    }
  }

  initializeMonitoring() {
    // Handle process signals
    process.on('SIGINT', () => this.gracefulShutdown());
    process.on('SIGTERM', () => this.gracefulShutdown());
    
    // Handle uncaught exceptions
    process.on('uncaughtException', (error) => {
      this.log(`‚ùå Uncaught exception: ${error.message}`, "ERROR");
      this.emergencyRecovery();
    });
    
    // Handle unhandled rejections
    process.on('unhandledRejection', (reason, promise) => {
      this.log(`‚ùå Unhandled rejection at ${promise}: ${reason}`, "ERROR");
    });
    
    this.log("‚úÖ Process monitoring initialized");
  }
}

// Start the comprehensive redundancy system
if (require.main === module) {
  const system = new ComprehensiveRedundancySystem();
  
  // Perform initial health check
  system.performComprehensiveHealthCheck().then(results => {
    console.log("üéØ Initial health check completed:", results);
  }).catch(error => {
    console.error("‚ùå Initial health check failed:", error);
  });
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
}

module.exports = ComprehensiveRedundancySystem;