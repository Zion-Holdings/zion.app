const DevelopmentAutomationFactory = require('./development-automation-factory');
const fs = require('fs');
const path = require('path');

class DevelopmentAutomationLauncher {
  constructor() {
    this.factory = new DevelopmentAutomationFactory();
    this.config = this.loadConfig();
    this.agents = new Map();
  }

  loadConfig() {
    const configPath = path.join(__dirname, 'development-automation-config.json');
    
    if (fs.existsSync(configPath)) {
      return JSON.parse(fs.readFileSync(configPath, 'utf8'));
    }
    
    // Default configuration
    return {
      agents: {
        'code-improvement': {
          enabled: true,
          config: {
            maxFileSize: 1000000,
            analysisDepth: 'deep',
            autoFix: false,
            suggestRefactoring: true
          }
        },
        'test-automation': {
          enabled: true,
          config: {
            autoGenerateTests: true,
            coverageThreshold: 80,
            parallelExecution: true,
            testRetries: 2
          }
        },
        'deployment-automation': {
          enabled: true,
          config: {
            autoDeploy: true,
            buildOptimization: true,
            healthChecks: true,
            rollbackOnFailure: true
          }
        },
        'security-automation': {
          enabled: true,
          config: {
            autoScan: true,
            vulnerabilityThreshold: 'high',
            autoPatch: false,
            securityReports: true
          }
        },
        'performance-optimization': {
          enabled: true,
          config: {
            performanceThreshold: 90,
            autoOptimize: true,
            bundleAnalysis: true,
            performanceReports: true
          }
        },
        'documentation-automation': {
          enabled: true,
          config: {
            autoGenerateDocs: true,
            updateReadme: true,
            apiDocumentation: true,
            codeComments: true
          }
        },
        'code-review-automation': {
          enabled: true,
          config: {
            autoReview: true,
            qualityThreshold: 0.8,
            enforceStandards: true,
            prChecks: true
          }
        },
        'dependency-management': {
          enabled: true,
          config: {
            autoUpdate: false,
            securityPatches: true,
            dependencyReports: true,
            updateStrategy: 'conservative'
          }
        },
        'git-automation': {
          enabled: true,
          config: {
            autoCommit: false,
            branchCleanup: true,
            mergeStrategy: 'squash',
            commitConvention: 'conventional'
          }
        },
        'monitoring-automation': {
          enabled: true,
          config: {
            errorTracking: true,
            performanceAlerts: true,
            healthChecks: true,
            alertThreshold: 0.1
          }
        }
      },
      system: {
        maxConcurrentAgents: 10,
        healthCheckInterval: 30000,
        logRetention: 7,
        autoRestart: true
      }
    };
  }

  async start() {
    console.log('ðŸš€ Starting Development Automation System...');
    
    try {
      // Initialize the factory
      await this.factory.loadAgentRegistry();
      
      // Start enabled agents
      await this.startEnabledAgents();
      
      // Setup system monitoring
      this.setupSystemMonitoring();
      
      // Setup file watchers
      await this.factory.setupFileWatchers();
      
      // Setup continuous integration
      await this.factory.setupContinuousIntegration();
      
      // Setup quality gates
      await this.factory.setupQualityGates();
      
      console.log('âœ… Development Automation System started successfully');
      
      // Start periodic health checks
      this.startHealthChecks();
      
    } catch (error) {
      console.error('âŒ Failed to start Development Automation System:', error);
      process.exit(1);
    }
  }

  async startEnabledAgents() {
    console.log('ðŸ“‹ Starting enabled development automation agents...');
    
    const enabledAgents = Object.entries(this.config.agents)
      .filter(([type, config]) => config.enabled);
    
    for (const [type, agentConfig] of enabledAgents) {
      try {
        console.log(`ðŸ”„ Starting ${type} agent...`);
        
        const agentId = await this.factory.createAgent(type, agentConfig.config);
        await this.factory.startAgent(agentId);
        
        this.agents.set(agentId, {
          type,
          config: agentConfig.config,
          status: 'running'
        });
        
        console.log(`âœ… ${type} agent started successfully (ID: ${agentId})`);
        
      } catch (error) {
        console.error(`âŒ Failed to start ${type} agent:`, error);
      }
    }
    
    console.log(`ðŸ“Š Started ${this.agents.size} development automation agents`);
  }

  setupSystemMonitoring() {
    console.log('ðŸ“Š Setting up system monitoring...');
    
    // Monitor agent health
    setInterval(async () => {
      await this.checkAgentHealth();
    }, this.config.system.healthCheckInterval);
    
    // Monitor system performance
    setInterval(async () => {
      await this.checkSystemPerformance();
    }, 60000); // Every minute
    
    // Auto-restart failed agents
    if (this.config.system.autoRestart) {
      setInterval(async () => {
        await this.autoRestartFailedAgents();
      }, 120000); // Every 2 minutes
    }
  }

  async checkAgentHealth() {
    try {
      const healthReport = await this.factory.healthCheck();
      
      // Log health status
      if (healthReport.status === 'critical') {
        console.warn('âš ï¸  System health is critical');
      } else if (healthReport.status === 'warning') {
        console.warn('âš ï¸  System health warning');
      } else {
        console.log('âœ… System health is good');
      }
      
      // Save health report
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const healthPath = path.join(__dirname, 'reports', 'system-health', `health-${timestamp}.json`);
      
      if (!fs.existsSync(path.dirname(healthPath))) {
        fs.mkdirSync(path.dirname(healthPath), { recursive: true });
      }
      
      fs.writeFileSync(healthPath, JSON.stringify(healthReport, null, 2));
      
    } catch (error) {
      console.error('Failed to check agent health:', error);
    }
  }

  async checkSystemPerformance() {
    try {
      const metrics = await this.factory.getSystemMetrics();
      
      // Log performance metrics
      console.log(`ðŸ“ˆ Performance - Tasks: ${metrics.totalTasksCompleted}, Errors: ${metrics.totalErrors}, Error Rate: ${metrics.errorRate.toFixed(2)}%`);
      
      // Alert if error rate is high
      if (metrics.errorRate > 10) {
        console.warn('âš ï¸  High error rate detected');
      }
      
    } catch (error) {
      console.error('Failed to check system performance:', error);
    }
  }

  async autoRestartFailedAgents() {
    try {
      const agents = this.factory.getAllAgents();
      
      for (const agent of agents) {
        if (agent.status === 'stopped' || agent.status === 'error') {
          console.log(`ðŸ”„ Auto-restarting failed agent: ${agent.type} (${agent.id})`);
          
          try {
            await this.factory.restartAgent(agent.id);
            console.log(`âœ… Successfully restarted agent: ${agent.type}`);
          } catch (error) {
            console.error(`âŒ Failed to restart agent ${agent.type}:`, error);
          }
        }
      }
      
    } catch (error) {
      console.error('Failed to auto-restart failed agents:', error);
    }
  }

  startHealthChecks() {
    console.log('ðŸ¥ Starting periodic health checks...');
    
    // Comprehensive health check every 5 minutes
    setInterval(async () => {
      await this.performComprehensiveHealthCheck();
    }, 300000);
  }

  async performComprehensiveHealthCheck() {
    try {
      console.log('ðŸ” Performing comprehensive health check...');
      
      const healthCheck = {
        timestamp: new Date().toISOString(),
        system: await this.factory.getSystemMetrics(),
        agents: [],
        recommendations: []
      };
      
      // Check each agent
      const agents = this.factory.getAllAgents();
      for (const agent of agents) {
        const agentHealth = await this.factory.checkAgentHealth(agent.id);
        healthCheck.agents.push(agentHealth);
        
        // Generate recommendations for unhealthy agents
        if (agentHealth.status === 'error' || agentHealth.status === 'stopped') {
          healthCheck.recommendations.push({
            type: 'agent_restart',
            agentId: agent.id,
            agentType: agent.type,
            message: `Agent ${agent.type} is not healthy. Consider restarting.`
          });
        }
      }
      
      // Save comprehensive health check
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const healthPath = path.join(__dirname, 'reports', 'system-health', `comprehensive-${timestamp}.json`);
      
      if (!fs.existsSync(path.dirname(healthPath))) {
        fs.mkdirSync(path.dirname(healthPath), { recursive: true });
      }
      
      fs.writeFileSync(healthPath, JSON.stringify(healthCheck, null, 2));
      
      console.log(`âœ… Health check completed. ${healthCheck.agents.length} agents checked.`);
      
    } catch (error) {
      console.error('Failed to perform comprehensive health check:', error);
    }
  }

  async stop() {
    console.log('ðŸ›‘ Stopping Development Automation System...');
    
    try {
      // Stop all agents
      const agents = this.factory.getAllAgents();
      for (const agent of agents) {
        if (agent.status === 'running') {
          await this.factory.stopAgent(agent.id);
          console.log(`ðŸ›‘ Stopped agent: ${agent.type}`);
        }
      }
      
      // Save final status
      await this.factory.saveAgentRegistry();
      
      console.log('âœ… Development Automation System stopped successfully');
      
    } catch (error) {
      console.error('âŒ Error stopping Development Automation System:', error);
    }
  }

  async getStatus() {
    try {
      const status = {
        timestamp: new Date().toISOString(),
        system: await this.factory.getSystemMetrics(),
        agents: this.factory.getAllAgents().map(agent => ({
          id: agent.id,
          type: agent.type,
          status: agent.status,
          performance: agent.performance
        })),
        health: await this.factory.healthCheck()
      };
      
      return status;
      
    } catch (error) {
      console.error('Failed to get system status:', error);
      return null;
    }
  }

  async generateReport() {
    try {
      console.log('ðŸ“Š Generating development automation report...');
      
      const report = {
        timestamp: new Date().toISOString(),
        system: await this.factory.getSystemMetrics(),
        agents: this.factory.getAllAgents(),
        health: await this.factory.healthCheck(),
        recommendations: []
      };
      
      // Generate recommendations
      const metrics = report.system;
      if (metrics.errorRate > 5) {
        report.recommendations.push({
          type: 'error_rate',
          priority: 'high',
          message: `High error rate (${metrics.errorRate.toFixed(2)}%). Review agent configurations.`
        });
      }
      
      if (metrics.runningAgents < metrics.totalAgents) {
        report.recommendations.push({
          type: 'agent_health',
          priority: 'medium',
          message: `${metrics.totalAgents - metrics.runningAgents} agents are not running.`
        });
      }
      
      // Save report
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const reportPath = path.join(__dirname, 'reports', `development-automation-report-${timestamp}.json`);
      
      if (!fs.existsSync(path.dirname(reportPath))) {
        fs.mkdirSync(path.dirname(reportPath), { recursive: true });
      }
      
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      
      console.log(`âœ… Report generated: ${reportPath}`);
      return report;
      
    } catch (error) {
      console.error('Failed to generate report:', error);
      return null;
    }
  }
}

// Handle command line arguments
const args = process.argv.slice(2);
const command = args[0];

const launcher = new DevelopmentAutomationLauncher();

async function main() {
  try {
    switch (command) {
      case 'start':
        await launcher.start();
        break;
        
      case 'stop':
        await launcher.stop();
        process.exit(0);
        break;
        
      case 'status':
        const status = await launcher.getStatus();
        console.log(JSON.stringify(status, null, 2));
        process.exit(0);
        break;
        
      case 'report':
        await launcher.generateReport();
        process.exit(0);
        break;
        
      default:
        console.log('Development Automation System Launcher');
        console.log('');
        console.log('Usage:');
        console.log('  node launch-development-automation.js start   - Start the system');
        console.log('  node launch-development-automation.js stop    - Stop the system');
        console.log('  node launch-development-automation.js status  - Get system status');
        console.log('  node launch-development-automation.js report  - Generate report');
        console.log('');
        process.exit(0);
    }
  } catch (error) {
    console.error('âŒ Launcher error:', error);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGTERM', async () => {
  console.log('Received SIGTERM, shutting down gracefully...');
  await launcher.stop();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('Received SIGINT, shutting down gracefully...');
  await launcher.stop();
  process.exit(0);
});

// Start the launcher if no command specified
if (!command) {
  launcher.start();
} else {
  main();
} 