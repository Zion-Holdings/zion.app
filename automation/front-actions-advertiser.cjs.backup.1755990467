#!/usr/bin/env node

'use strict';

const fs = require('fs');
const path = require('path');

const ROOT = process.cwd();
const FRONT_PAGE = path.join(ROOT, 'pages', 'main', 'front', 'index.tsx');
const START_MARKER = '/* AUTO-GENERATED: FRONT_ACTIONS_START */';
const END_MARKER = '/* AUTO-GENERATED: FRONT_ACTIONS_END */';

<<<<<<< HEAD
function readJsonSafe(file) {
  try { return JSON.parse(fs.readFileSync(file, 'utf8')); } catch { return null; }
}

function getRepoFromPackageJson() {
  const pkg = readJsonSafe(path.join(ROOT, 'package.json')) || {};
  const repoUrl = (pkg.repository && pkg.repository.url) || pkg.homepage || '';
  const m = repoUrl.match(/github\.com[/:]([^/]+)\/([^/#.]+)(?:\.git)?/i);
  if (!m) return null;
  return { owner: m[1], repo: m[2] };
}

function listWorkflows() {
  const dir = path.join(ROOT, '.github', 'workflows');
  if (!fs.existsSync(dir)) return [];
  return fs.readdirSync(dir).filter((f) => f.endsWith('.yml') || f.endsWith('.yaml'));
}

function toTitle(basename) {
  return basename
    .replace(/\.(yml|yaml)$/i, '')
    .replace(/[-_]+/g, ' ')
    .replace(/\b\w/g, (m) => m.toUpperCase());
}

function buildCards(repo, files) {
  const actionsBase = `https://github.com/${repo.owner}/${repo.repo}/actions/workflows`;
  const curatedOrder = [
    'dead-code-report.yml',
    'duplicate-media-finder.yml',
    'image-optimizer.yml',
    'todo-scanner.yml',
    'branch-cleanup.yml',
  ];
  const set = new Set(files);
  const chosen = curatedOrder.filter((f) => set.has(f));
  const finalList = chosen.length ? chosen : files.slice(0, 8);
  return finalList.map((f) => {
    const href = `${actionsBase}/${f}`;
    const title = toTitle(f);
    const desc = (
      f.includes('dead-code') ? 'Scans and reports unused code, hourly.' :
      f.includes('duplicate-media') ? 'Finds duplicate images by content hash.' :
      f.includes('image-optimizer') ? 'Optimizes images and commits savings.' :
      f.includes('todo-scanner') ? 'Aggregates TODO/FIXME into docs and JSON.' :
      f.includes('branch-cleanup') ? 'Prunes merged/stale ephemeral branches.' :
      'Autonomous GitHub Action'
    );
    return { title, desc, href };
  });
}

function generateSection(cards) {
  const items = cards.map((c) => (
`              <a href="${c.href}" target="_blank" rel="noopener" className="group relative overflow-hidden rounded-2xl border border-white/10 bg-gradient-to-br from-white/10 to-white/5 p-6 backdrop-blur-xl hover:border-cyan-400/30 tilt-on-hover">
                <div className="pointer-events-none absolute -inset-px -z-10 bg-gradient-to-r from-fuchsia-500/0 via-cyan-400/10 to-fuchsia-500/0 opacity-0 blur-2xl transition-opacity group-hover:opacity-100" />
                <div className="text-base font-semibold">${c.title}</div>
                <div className="mt-1 text-sm text-white/75">${c.desc}</div>
                <div className="mt-3 inline-flex items-center gap-1 text-xs text-cyan-300/90">Open <span aria-hidden>↗</span></div>
              </a>`)).join('\n');

  return [
    '<section className="mx-auto max-w-7xl px-6 pb-14">',
    '  <h2 className="text-center text-2xl font-bold tracking-wide text-white/90">GitHub Actions — Autonomous Automations</h2>',
    '  <p className="mx-auto mt-2 max-w-3xl text-center text-sm text-white/70">Runs fully in the cloud on a fast cadence, syncing changes to main automatically.</p>',
    '  <div className="mt-6 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">',
    items,
    '  </div>',
    '</section>'
  ].join('\n');
}

function replaceBetweenMarkers(source, startMarker, endMarker, replacement) {
  const startIdx = source.indexOf(startMarker);
  const endIdx = source.indexOf(endMarker);
  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
    throw new Error('Markers not found or invalid order in front index');
  }
  const before = source.slice(0, startIdx + startMarker.length);
  const after = source.slice(endIdx);
  return `${before}\n${replacement}\n${after}`;
=======
function getRepoSlug() {
  try {
    const pkg = JSON.parse(fs.readFileSync(path.join(ROOT, 'package.json'), 'utf8'));
    const url = (pkg.repository && pkg.repository.url) || '';
    const match = url.match(/github\.com[:/]+([^/]+)\/([^\.]+)(?:\.git)?/i);
    if (match) return `${match[1]}/${match[2]}`;
  } catch {}
  return '';
}

function listWorkflowFiles() {
  const results = [];
  const tryDirs = [path.join(ROOT, '.github', 'workflows'), path.join(ROOT, '.github')];
  for (const dir of tryDirs) {
    if (!fs.existsSync(dir)) continue;
    for (const name of fs.readdirSync(dir)) {
      if (!name.match(/\.(ya?ml)$/)) continue;
      if (name.toLowerCase().includes('dependabot')) continue;
      const full = path.join(dir, name);
      const key = `/${path.relative(ROOT, full).replace(/\\/g, '/')}`;
      if (!results.find((r) => r.key === key)) {
        results.push({ key, dir, name, full });
      }
    }
  }
  return results.sort((a, b) => a.name.localeCompare(b.name));
}

function readWorkflowMeta(filePath) {
  const src = fs.readFileSync(filePath, 'utf8');
  let name = '';
  let cron = '';
  const nameMatch = src.match(/^name:\s*(.+)$/m);
  if (nameMatch) name = nameMatch[1].trim();
  const cronMatch = src.match(/cron:\s*["']?([^"'\n]+)["']?/);
  if (cronMatch) cron = cronMatch[1].trim();
  return { name, cron };
}

function toTitle(fileName) {
  const base = fileName.replace(/\.(ya?ml)$/i, '').replace(/[-_]/g, ' ').trim();
  return base
    .split(' ')
    .map((w) => (w ? w[0].toUpperCase() + w.slice(1) : w))
    .join(' ');
}

function buildCards(repoSlug, workflows) {
  const items = workflows.map((w) => {
    const meta = readWorkflowMeta(w.full);
    const title = meta.name || toTitle(w.name);
    const href = repoSlug
      ? `https://github.com/${repoSlug}/actions/workflows/${w.name}`
      : `https://github.com/actions`;
    const desc = meta.cron ? `Scheduled: ${meta.cron}` : 'On push / schedule';
    return { title, href, desc };
  });
  return items.slice(0, 12)
    .map((it) => (
      `              <a href="${it.href}" target="_blank" rel="noopener" className="group relative overflow-hidden rounded-2xl border border-white/10 bg-gradient-to-br from-white/10 to-white/5 p-6 backdrop-blur-xl hover:border-cyan-400/30 tilt-on-hover">
                <div className="pointer-events-none absolute -inset-px -z-10 bg-gradient-to-r from-fuchsia-500/0 via-cyan-400/10 to-fuchsia-500/0 opacity-0 blur-2xl transition-opacity group-hover:opacity-100" />
                <div className="text-base font-semibold">${it.title}</div>
                <div className="mt-1 text-sm text-white/75">${it.desc}</div>
                <div className="mt-3 inline-flex items-center gap-1 text-xs text-cyan-300/90">Open <span aria-hidden>↗</span></div>
              </a>`
    ))
    .join('\n');
}

function buildSection(cardsHtml) {
  return [
    START_MARKER,
    '<section className="mx-auto max-w-7xl px-6 pb-14">',
    '  <h2 className="text-center text-2xl font-bold tracking-wide text-white/90">GitHub Actions — Live Automations</h2>',
    '  <p className="mx-auto mt-2 max-w-3xl text-center text-sm text-white/70">Cloud‑native workflows that maintain, heal, and evolve the repo automatically.</p>',
    '  <div className="mt-6 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">',
    cardsHtml,
    '  </div>',
    '</section>',
    END_MARKER
  ].join('\n');
}

function ensureMarkersAndInsert(source, block) {
  const hasStart = source.includes(START_MARKER);
  const hasEnd = source.includes(END_MARKER);
  if (hasStart && hasEnd) {
    const startIdx = source.indexOf(START_MARKER) + START_MARKER.length;
    const endIdx = source.indexOf(END_MARKER);
    return source.slice(0, startIdx) + '\n' + block.split('\n').slice(1, -1).join('\n') + '\n' + source.slice(endIdx);
  }
  const closingMain = source.lastIndexOf('</main>');
  const insertIdx = closingMain !== -1 ? closingMain : source.length;
  return source.slice(0, insertIdx) + '\n' + block + '\n' + source.slice(insertIdx);
>>>>>>> origin/cursor/invent-and-deploy-autonomous-github-actions-fa8c
}

(function main() {
  if (!fs.existsSync(FRONT_PAGE)) {
    console.log('Front page not found, skipping');
    process.exit(0);
  }
<<<<<<< HEAD
  const repo = getRepoFromPackageJson();
  if (!repo) {
    console.log('Could not parse repo from package.json, skipping');
    process.exit(0);
  }
  const workflows = listWorkflows();
  const cards = buildCards(repo, workflows);
  const block = generateSection(cards);
  const original = fs.readFileSync(FRONT_PAGE, 'utf8');
  let updated;
  try {
    updated = replaceBetweenMarkers(original, START_MARKER, END_MARKER, block);
  } catch (e) {
    console.log('Could not replace between markers:', e.message);
    process.exit(0);
  }
  if (updated !== original) {
    fs.writeFileSync(FRONT_PAGE, updated);
    console.log('Front index actions advertisement updated.');
  } else {
    console.log('No updates required.');
=======
  const workflows = listWorkflowFiles();
  if (!workflows.length) {
    console.log('No workflows found');
    process.exit(0);
  }
  const repoSlug = getRepoSlug();
  const cards = buildCards(repoSlug, workflows);
  const section = buildSection(cards, repoSlug);
  const src = fs.readFileSync(FRONT_PAGE, 'utf8');
  const updated = ensureMarkersAndInsert(src, section);
  if (updated !== src) {
    fs.writeFileSync(FRONT_PAGE, updated, 'utf8');
    console.log('Front page actions catalog updated.');
  } else {
    console.log('Front page actions catalog up-to-date.');
>>>>>>> origin/cursor/invent-and-deploy-autonomous-github-actions-fa8c
  }
})();