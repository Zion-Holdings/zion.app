const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function writeFile(filePath, content) {
  ensureDir(path.dirname(filePath));
  fs.writeFileSync(filePath, content);
}

function safeExec(cmd) {
  try {
    return execSync(cmd, { encoding: 'utf8', stdio: ['ignore', 'pipe', 'pipe'] });
  } catch (e) {
    return '';
  }
}

function getRecentCommits(limit = 200) {
  const raw = safeExec(`git log --date=short --pretty=format:%h|%ad|%s|%an -n ${limit}`);
  return raw
    .split('\n')
    .filter(Boolean)
    .map((line) => {
      const [hash, date, subject, author] = line.split('|');
      return { hash, date, subject, author };
    });
}

function getHotspots(limit = 15) {
  const raw = safeExec('git log --name-only --pretty=format:');
  const counts = new Map();
  raw
    .split('\n')
    .map((f) => f.trim())
    .filter((f) => f && !f.startsWith('.') && !f.startsWith('Merge '))
    .forEach((f) => {
      const top = f.split('/')[0];
      const key = top || f;
      counts.set(key, (counts.get(key) || 0) + 1);
    });
  const sorted = [...counts.entries()].sort((a, b) => b[1] - a[1]);
  return sorted.slice(0, limit).map(([area, changes]) => ({ area, changes }));
}

function scanTodos(root) {
  const results = [];
  const re = /(TODO|FIXME|NEXT|ROADMAP)\s*:?(.*)$/i;
  function walk(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.name === 'node_modules' || entry.name.startsWith('.git')) continue;
      const full = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        walk(full);
      } else if (/\.(js|jsx|ts|tsx|md|cjs|mjs)$/.test(entry.name)) {
        const content = fs.readFileSync(full, 'utf8');
        const lines = content.split('\n');
        lines.forEach((line, idx) => {
          const m = line.match(re);
          if (m) {
            results.push({ file: full.replace(root + path.sep, ''), line: idx + 1, tag: m[1].toUpperCase(), note: m[2].trim() });
          }
        });
      }
    }
  }
  walk(root);
  return results.slice(0, 500);
}

function generateSuggestions({ hotspots, todos }) {
  const suggestions = [];
  if (hotspots.length > 0) {
    const top = hotspots[0];
    suggestions.push({
      id: 'focus-top-hotspot',
      title: `Stabilize high-change area: ${top.area}`,
      action: `Add tests and a refactor pass for '${top.area}' to reduce churn (changes: ${top.changes}).`
    });
  }
  const todoTags = todos.reduce((acc, t) => ((acc[t.tag] = (acc[t.tag] || 0) + 1), acc), {});
  const todoSummary = Object.entries(todoTags)
    .map(([tag, count]) => `${tag}: ${count}`)
    .join(', ');
  if (todoSummary) {
    suggestions.push({
      id: 'address-todos',
      title: 'Address tracked TODOs',
      action: `Plan a sprint resolving highest-impact TODOs (${todoSummary}).`
    });
  }
  suggestions.push({
    id: 'autonomy-loop',
    title: 'Tighten autonomy loop',
    action: 'Schedule this curator every 10 minutes and auto-publish a public roadmap report.'
  });
  return suggestions;
}

function toMarkdown(data) {
  const lines = [];
  lines.push(`# Autonomous Roadmap (Living Document)`);
  lines.push('');
  lines.push(`Generated: ${new Date(data.generatedAt).toISOString()}`);
  lines.push('');
  lines.push('## Hotspots (most changed top-level areas)');
  lines.push('');
  data.hotspots.forEach((h) => lines.push(`- ${h.area}: ${h.changes} changes`));
  lines.push('');
  lines.push('## Suggestions');
  lines.push('');
  data.suggestions.forEach((s) => lines.push(`- ${s.title} â€” ${s.action}`));
  lines.push('');
  lines.push('## Recent Commits');
  lines.push('');
  data.recentCommits.slice(0, 50).forEach((c) => lines.push(`- ${c.date} ${c.hash}: ${c.subject} (${c.author})`));
  lines.push('');
  lines.push('_This roadmap is generated by an autonomous curator and updated continuously._');
  return lines.join('\n');
}

(function main() {
  const root = process.cwd();
  const recentCommits = getRecentCommits(120);
  const hotspots = getHotspots(20);
  const todos = scanTodos(root);
  const suggestions = generateSuggestions({ hotspots, todos });

  const data = {
    generatedAt: new Date().toISOString(),
    recentCommits,
    hotspots,
    todosSample: todos.slice(0, 50),
    suggestions
  };

  const outJson = path.join('data', 'reports', 'roadmap', 'auto-roadmap.json');
  const outMd = path.join('data', 'reports', 'roadmap', 'auto-roadmap.md');
  writeFile(outJson, JSON.stringify(data, null, 2));
  writeFile(outMd, toMarkdown(data));
  console.log(`[roadmap-curator] wrote ${outJson} and ${outMd}`);
})();