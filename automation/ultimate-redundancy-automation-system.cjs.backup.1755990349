#!/usr/bin/env node
<<<<<<< HEAD

/**
 * Ultimate Redundancy Automation System
 * Comprehensive redundancy for all PM2, GitHub Actions, and Netlify Functions automations
 * 
 * This system provides:
 * - PM2 process monitoring and auto-recovery
 * - GitHub Actions workflow monitoring and backup triggers
 * - Netlify Functions monitoring and auto-regeneration
 * - Cross-system health monitoring and failover
 * - Automated recovery and redundancy management
 */

const fs = require('fs');
const path = require('path');
const { exec, execSync } = require('child_process');
const cron = require('node-cron');

class UltimateRedundancyAutomationSystem {
    constructor() {
        this.config = {
            logLevel: process.env.REDUNDANCY_LOG_LEVEL || 'INFO',
            checkInterval: parseInt(process.env.REDUNDANCY_CHECK_INTERVAL) || 30000,
            maxRetries: parseInt(process.env.REDUNDANCY_MAX_RETRIES) || 3,
            autoRecovery: process.env.REDUNDANCY_AUTO_RECOVERY !== 'false',
            crossSystemMonitoring: process.env.REDUNDANCY_CROSS_SYSTEM !== 'false'
        };
        
        this.status = {
            pm2: { healthy: false, processes: [], lastCheck: null },
            github: { healthy: false, workflows: [], lastCheck: null },
            netlify: { healthy: false, functions: [], lastCheck: null },
            system: { healthy: false, lastCheck: null, uptime: Date.now() }
        };
        
        this.logs = [];
        this.metrics = {
            checks: 0,
            recoveries: 0,
            failures: 0,
            lastRecovery: null
        };
        
        this.setupLogging();
        this.ensureDirectories();
    }

    setupLogging() {
        this.logDir = path.join(__dirname, 'logs');
        this.logFile = path.join(this.logDir, 'ultimate-redundancy.log');
        
        if (!fs.existsSync(this.logDir)) {
            fs.mkdirSync(this.logDir, { recursive: true });
        }
    }

    ensureDirectories() {
        const dirs = [
            path.join(__dirname, 'logs'),
            path.join(__dirname, 'backups'),
            path.join(__dirname, 'reports')
        ];
        
        dirs.forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });
    }

    log(level, message, data = null) {
        const timestamp = new Date().toISOString();
        const logEntry = {
            timestamp,
            level,
            message,
            data
        };
        
        this.logs.push(logEntry);
        
        // Keep only last 1000 logs
        if (this.logs.length > 1000) {
            this.logs = this.logs.slice(-1000);
        }
        
        const logMessage = `[${timestamp}] [${level}] ${message}`;
        
        // Console output
        switch (level) {
            case 'ERROR':
                console.error(logMessage);
                break;
            case 'WARN':
                console.warn(logMessage);
                break;
            case 'INFO':
                console.log(logMessage);
                break;
            default:
                console.log(logMessage);
        }
        
        // File logging
        try {
            fs.appendFileSync(this.logFile, logMessage + '\n');
        } catch (error) {
            console.error('Failed to write to log file:', error.message);
        }
    }

    async checkPM2Health() {
        try {
            this.log('INFO', 'Checking PM2 health...');
            
            // Check if PM2 is running
            let pm2Processes = [];
            try {
                const pm2Status = execSync('pm2 status --no-daemon', { 
                    encoding: 'utf8',
                    timeout: 5000
                });
                pm2Processes = pm2Status.trim().split('\n').slice(1).map(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 4) {
                        return {
                            name: parts[0],
                            pm2_env: {
                                status: parts[3] === 'online' ? 'online' : 'offline'
                            }
                        };
                    }
                    return null;
                }).filter(Boolean);
            } catch (pm2Error) {
                this.log('WARN', `PM2 status check failed: ${pm2Error.message}`);
                // If PM2 is not running or times out, consider it healthy (no processes to fail)
                pm2Processes = [];
            }
            
            this.status.pm2.processes = pm2Processes;
            this.status.pm2.lastCheck = Date.now();
            
            // Check process health
            let healthyCount = 0;
            let totalCount = 0;
            
            for (const process of pm2Processes) {
                totalCount++;
                if (process.pm2_env && process.pm2_env.status === 'online') {
                    healthyCount++;
                }
            }
            
            // PM2 is healthy if there are no processes (nothing to fail) or all processes are healthy
            this.status.pm2.healthy = totalCount === 0 || (healthyCount > 0 && healthyCount === totalCount);
            
            this.log('INFO', `PM2 Health Check: ${healthyCount}/${totalCount} processes healthy`);
            
            return this.status.pm2.healthy;
        } catch (error) {
            this.log('ERROR', `PM2 health check failed: ${error.message}`);
            this.status.pm2.healthy = false;
            return false;
        }
    }

    async checkGitHubActionsHealth() {
        try {
            this.log('INFO', 'Checking GitHub Actions health...');
            
            // Check workflow files
            const workflowsDir = path.join(__dirname, '..', '.github', 'workflows');
            const workflows = [];
            
            if (fs.existsSync(workflowsDir)) {
                const workflowFiles = fs.readdirSync(workflowsDir).filter(f => f.endsWith('.yml'));
                
                for (const file of workflowFiles) {
                    const content = fs.readFileSync(path.join(workflowsDir, file), 'utf8');
                    workflows.push({
                        name: file,
                        content: content,
                        valid: content.includes('name:') && content.includes('on:')
                    });
                }
            }
            
            this.status.github.workflows = workflows;
            this.status.github.lastCheck = Date.now();
            
            // Check if workflows are valid
            const validWorkflows = workflows.filter(w => w.valid);
            this.status.github.healthy = validWorkflows.length > 0;
            
            this.log('INFO', `GitHub Actions Health Check: ${validWorkflows.length}/${workflows.length} workflows valid`);
            
            return this.status.github.healthy;
        } catch (error) {
            this.log('ERROR', `GitHub Actions health check failed: ${error.message}`);
            this.status.github.healthy = false;
            return false;
        }
    }

    async checkNetlifyFunctionsHealth() {
        try {
            this.log('INFO', 'Checking Netlify Functions health...');
            
            // Check functions manifest
            const manifestPath = path.join(__dirname, '..', 'netlify', 'functions', 'functions-manifest.json');
            const functions = [];
            
            if (fs.existsSync(manifestPath)) {
                const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
                functions.push(...manifest.functions || []);
            }
            
            // Check if functions directory exists and has files
            const functionsDir = path.join(__dirname, '..', 'netlify', 'functions');
            if (fs.existsSync(functionsDir)) {
                const functionFiles = fs.readdirSync(functionsDir).filter(f => f.endsWith('.js') || f.endsWith('.ts'));
                functions.push(...functionFiles);
            }
            
            this.status.netlify.functions = functions;
            this.status.netlify.lastCheck = Date.now();
            this.status.netlify.healthy = functions.length > 0;
            
            this.log('INFO', `Netlify Functions Health Check: ${functions.length} functions found`);
            
            return this.status.netlify.healthy;
        } catch (error) {
            this.log('ERROR', `Netlify Functions health check failed: ${error.message}`);
            this.status.netlify.healthy = false;
            return false;
        }
    }

    async performPM2Recovery() {
        try {
            this.log('WARN', 'Performing PM2 recovery...');
            
            // Stop all PM2 processes
            execSync('pm2 stop all', { stdio: 'pipe' });
            
            // Clear PM2 logs
            execSync('pm2 flush', { stdio: 'pipe' });
            
            // Start comprehensive redundancy system
            execSync('pm2 start ecosystem.comprehensive-redundancy.cjs --update-env', { stdio: 'pipe' });
            
            // Save PM2 configuration
            execSync('pm2 save', { stdio: 'pipe' });
            
            this.log('INFO', 'PM2 recovery completed');
            this.metrics.recoveries++;
            this.metrics.lastRecovery = Date.now();
            
            return true;
        } catch (error) {
            this.log('ERROR', `PM2 recovery failed: ${error.message}`);
            this.metrics.failures++;
            return false;
        }
    }

    async performGitHubActionsRecovery() {
        try {
            this.log('WARN', 'Performing GitHub Actions recovery...');
            
            // Backup current workflows
            const backupDir = path.join(__dirname, 'backups', 'github-actions');
            if (!fs.existsSync(backupDir)) {
                fs.mkdirSync(backupDir, { recursive: true });
            }
            
            const workflowsDir = path.join(__dirname, '..', '.github', 'workflows');
            if (fs.existsSync(workflowsDir)) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const backupPath = path.join(backupDir, `workflows-backup-${timestamp}`);
                fs.mkdirSync(backupPath, { recursive: true });
                
                const workflowFiles = fs.readdirSync(workflowsDir).filter(f => f.endsWith('.yml'));
                workflowFiles.forEach(file => {
                    const source = path.join(workflowsDir, file);
                    const dest = path.join(backupPath, file);
                    fs.copyFileSync(source, dest);
                });
                
                this.log('INFO', `GitHub Actions workflows backed up to ${backupPath}`);
            }
            
            // Trigger workflow regeneration if needed
            const backupWorkflows = [
                'marketing-sync-backup.yml',
                'sync-health-backup.yml'
            ];
            
            backupWorkflows.forEach(workflow => {
                const source = path.join(__dirname, '..', '.github', 'workflows', 'backups', workflow);
                const dest = path.join(__dirname, '..', '.github', 'workflows', workflow.replace('-backup', ''));
                
                if (fs.existsSync(source) && !fs.existsSync(dest)) {
                    fs.copyFileSync(source, dest);
                    this.log('INFO', `Restored workflow: ${workflow}`);
                }
            });
            
            this.log('INFO', 'GitHub Actions recovery completed');
            this.metrics.recoveries++;
            this.metrics.lastRecovery = Date.now();
            
            return true;
        } catch (error) {
            this.log('ERROR', `GitHub Actions recovery failed: ${error.message}`);
            this.metrics.failures++;
            return false;
        }
    }

    async performNetlifyFunctionsRecovery() {
        try {
            this.log('WARN', 'Performing Netlify Functions recovery...');
            
            // Backup current functions
            const backupDir = path.join(__dirname, 'backups', 'netlify-functions');
            if (!fs.existsSync(backupDir)) {
                fs.mkdirSync(backupDir, { recursive: true });
            }
            
            const functionsDir = path.join(__dirname, '..', 'netlify', 'functions');
            if (fs.existsSync(functionsDir)) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const backupPath = path.join(backupDir, `functions-backup-${timestamp}`);
                fs.mkdirSync(backupPath, { recursive: true });
                
                const functionFiles = fs.readdirSync(functionsDir).filter(f => f.endsWith('.js') || f.endsWith('.ts'));
                functionFiles.forEach(file => {
                    const source = path.join(functionsDir, file);
                    const dest = path.join(backupPath, file);
                    fs.copyFileSync(source, dest);
                });
                
                this.log('INFO', `Netlify Functions backed up to ${backupPath}`);
            }
            
            // Regenerate functions manifest
            try {
                execSync('npm run netlify:manifest', { stdio: 'pipe' });
                this.log('INFO', 'Netlify Functions manifest regenerated');
            } catch (error) {
                this.log('WARN', `Failed to regenerate manifest: ${error.message}`);
            }
            
            this.log('INFO', 'Netlify Functions recovery completed');
            this.metrics.recoveries++;
            this.metrics.lastRecovery = Date.now();
            
            return true;
        } catch (error) {
            this.log('ERROR', `Netlify Functions recovery failed: ${error.message}`);
            this.metrics.failures++;
            return false;
        }
    }

    async performCrossSystemRecovery() {
        try {
            this.log('WARN', 'Performing cross-system recovery...');
            
            // Check if we need to restart the entire system
            const allSystemsHealthy = this.status.pm2.healthy && 
                                    this.status.github.healthy && 
                                    this.status.netlify.healthy;
            
            if (!allSystemsHealthy) {
                this.log('INFO', 'Some systems are unhealthy, performing full recovery...');
                
                // Restart all systems
                await this.performPM2Recovery();
                await this.performGitHubActionsRecovery();
                await this.performNetlifyFunctionsRecovery();
                
                // Wait for systems to stabilize
                await new Promise(resolve => setTimeout(resolve, 10000));
                
                // Verify recovery
                await this.checkPM2Health();
                await this.checkGitHubActionsHealth();
                await this.checkNetlifyFunctionsHealth();
            }
            
            this.log('INFO', 'Cross-system recovery completed');
            return true;
        } catch (error) {
            this.log('ERROR', `Cross-system recovery failed: ${error.message}`);
            return false;
        }
    }

    async runHealthCheck() {
        this.metrics.checks++;
        this.log('INFO', `Running health check #${this.metrics.checks}...`);
        
        try {
            // Check all systems
            const pm2Healthy = await this.checkPM2Health();
            const githubHealthy = await this.checkGitHubActionsHealth();
            const netlifyHealthy = await this.checkNetlifyFunctionsHealth();
            
            // Update overall system health
            this.status.system.healthy = pm2Healthy && githubHealthy && netlifyHealthy;
            this.status.system.lastCheck = Date.now();
            
            // Log results
            this.log('INFO', `Health Check Results:`);
            this.log('INFO', `  PM2: ${pm2Healthy ? 'HEALTHY' : 'UNHEALTHY'}`);
            this.log('INFO', `  GitHub Actions: ${githubHealthy ? 'HEALTHY' : 'UNHEALTHY'}`);
            this.log('INFO', `  Netlify Functions: ${netlifyHealthy ? 'HEALTHY' : 'UNHEALTHY'}`);
            this.log('INFO', `  Overall System: ${this.status.system.healthy ? 'HEALTHY' : 'UNHEALTHY'}`);
            
            // Perform recovery if needed and auto-recovery is enabled
            if (!this.status.system.healthy && this.config.autoRecovery) {
                this.log('WARN', 'System unhealthy, initiating recovery...');
                
                if (!pm2Healthy) {
                    await this.performPM2Recovery();
                }
                
                if (!githubHealthy) {
                    await this.performGitHubActionsRecovery();
                }
                
                if (!netlifyHealthy) {
                    await this.performNetlifyFunctionsRecovery();
                }
                
                // Perform cross-system recovery if still unhealthy
                if (!this.status.system.healthy) {
                    await this.performCrossSystemRecovery();
                }
            }
            
            return this.status.system.healthy;
        } catch (error) {
            this.log('ERROR', `Health check failed: ${error.message}`);
            this.metrics.failures++;
            return false;
        }
    }

    async start() {
        this.log('INFO', 'Starting Ultimate Redundancy Automation System...');
        this.log('INFO', `Configuration: ${JSON.stringify(this.config, null, 2)}`);
        
        // Initial health check
        await this.runHealthCheck();
        
        // Start scheduled health checks
        this.scheduler = cron.schedule(`*/${Math.ceil(this.config.checkInterval / 60000)} * * * *`, async () => {
            await this.runHealthCheck();
        });
        
        this.log('INFO', 'Ultimate Redundancy Automation System started successfully');
        
        // Keep the process running
        process.on('SIGINT', () => this.stop());
        process.on('SIGTERM', () => this.stop());
    }

    async stop() {
        this.log('INFO', 'Stopping Ultimate Redundancy Automation System...');
        
        if (this.scheduler) {
            this.scheduler.stop();
        }
        
        this.log('INFO', 'Ultimate Redundancy Automation System stopped');
        process.exit(0);
    }

    getStatus() {
        return {
            config: this.config,
            status: this.status,
            metrics: this.metrics,
            logs: this.logs.slice(-100), // Last 100 logs
            uptime: Date.now() - this.status.system.uptime
        };
    }

    generateReport() {
        const report = {
            timestamp: new Date().toISOString(),
            system: {
                healthy: this.status.system.healthy,
                uptime: Date.now() - this.status.system.uptime,
                lastCheck: this.status.system.lastCheck
            },
            components: {
                pm2: {
                    healthy: this.status.pm2.healthy,
                    processCount: this.status.pm2.processes.length,
                    lastCheck: this.status.pm2.lastCheck
                },
                github: {
                    healthy: this.status.github.healthy,
                    workflowCount: this.status.github.workflows.length,
                    lastCheck: this.status.github.lastCheck
                },
                netlify: {
                    healthy: this.status.netlify.healthy,
                    functionCount: this.status.netlify.functions.length,
                    lastCheck: this.status.netlify.lastCheck
                }
            },
            metrics: this.metrics,
            recommendations: this.generateRecommendations()
        };
        
        return report;
    }

    generateRecommendations() {
        const recommendations = [];
        
        if (!this.status.pm2.healthy) {
            recommendations.push('PM2 system needs attention - check process status and logs');
        }
        
        if (!this.status.github.healthy) {
            recommendations.push('GitHub Actions workflows need validation - check workflow files');
        }
        
        if (!this.status.netlify.healthy) {
            recommendations.push('Netlify Functions need regeneration - run manifest generation');
        }
        
        if (this.metrics.failures > 5) {
            recommendations.push('High failure rate detected - consider system restart');
        }
        
        if (this.metrics.recoveries > 10) {
            recommendations.push('Multiple recoveries performed - investigate root cause');
        }
        
        return recommendations;
    }
=======
"use strict";

const { spawnSync, execSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

class UltimateRedundancyAutomationSystem {
  constructor() {
    this.config = {
      pm2: {
        ecosystemFiles: [
          "ecosystem.pm2.cjs",
          "ecosystem.redundancy.cjs", 
          "ecosystem.comprehensive-redundancy.cjs",
          "ecosystem.redundancy.pm2.cjs"
        ],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor",
          "master-redundancy-orchestrator",
          "enhanced-pm2-redundancy",
          "enhanced-github-actions-redundancy",
          "enhanced-netlify-functions-redundancy",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor"
        ],
        healthCheckInterval: 30000,
        maxRestartAttempts: 5,
        restartDelay: 5000,
        autoRecovery: true,
        processMonitoring: true,
        logRotation: true
      },
      githubActions: {
        workflows: [
          ".github/workflows/marketing-sync.yml",
          ".github/workflows/sync-health.yml",
          ".github/workflows/marketing-sync-backup.yml",
          ".github/workflows/sync-health-backup.yml"
        ],
        backupWorkflows: [
          ".github/workflows/marketing-sync-backup.yml",
          ".github/workflows/sync-health-backup.yml"
        ],
        healthCheckInterval: 60000,
        maxFailureThreshold: 3,
        autoTrigger: true,
        backupTriggers: true,
        workflowValidation: true,
        apiHealthCheck: true
      },
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        functions: [
          "a11y-alt-text-runner",
          "adaptive-orchestrator",
          "ai-changelog-runner",
          "ai-trends-radar-runner",
          "anchor-links-auto-fixer",
          "auto-discovery-runner",
          "auto-scheduler",
          "automation-matrix",
          "autonomous-invention-orchestrator",
          "autonomous-meta-orchestrator",
          "broken-image-scanner",
          "broken-image-scanner-runner",
          "canonical-auditor",
          "cloud_deep_research",
          "cloud_orchestrator",
          "code-smell-audit-runner",
          "component-coupling-graph-runner",
          "component-props-docs-runner",
          "component-size-report",
          "content-freshness-score-runner",
          "continuous-front-runner",
          "continuous-orchestrator",
          "dead-code-audit",
          "dead-code-report",
          "deps-auto-upgrade-runner",
          "docs-index-runner",
          "docs-search-index-runner",
          "duplicate-media-finder-runner",
          "external-link-check-runner",
          "fast-front-promoter",
          "fast-orchestrator",
          "feature-advertiser",
          "features-capabilities-benefits-advertiser",
          "front-ads-promoter",
          "front-enhancer",
          "front-index-futurizer",
          "front-index-orchestrator",
          "front-index-scheduler",
          "front-maximizer",
          "front-visionary-expander",
          "frontpage-enhancer",
          "frontpage-scheduler",
          "headers-enforcer",
          "home-visionary-expander",
          "homepage-advertiser-scheduler",
          "homepage-enhancer",
          "homepage-updater",
          "homepage-updater-scheduler",
          "homepage_advertiser",
          "hyper-front-index-accelerator",
          "image-optimizer-runner",
          "innovation-lab",
          "innovations-promoter",
          "intelligent-meta-orchestrator",
          "internal-link-graph-runner",
          "knowledge-pack-runner",
          "license-compliance-auditor",
          "link-and-health-scheduler",
          "link-crawler",
          "maintenance-scheduler",
          "marketing-and-features-promo",
          "marketing-scheduler",
          "media-og-and-optimize",
          "metadata-optimizer-runner",
          "netlify-auto-healer-runner",
          "newsroom-auto-publisher",
          "newsroom-runner",
          "og-image-update-runner",
          "orphan-pages-detector",
          "pagespeed-insights-runner",
          "readme-advertiser",
          "repo-knowledge-graph-runner",
          "repo-radar-and-graph",
          "repo-radar-runner",
          "revenue-ideas-lab",
          "roadmap-curator",
          "robots-auditor",
          "schedule-content-index",
          "schedule-homepage",
          "schedule-knowledge-graph",
          "schedule-site-health",
          "security-audit",
          "security-audit-runner",
          "seo-audit-runner",
          "site-404-map-runner",
          "site-crawler",
          "sitemap_runner",
          "stale-content-auditor-runner",
          "todo-scanner-runner",
          "todo-summary-runner",
          "topic-cluster-builder-runner",
          "topics-map-runner",
          "trigger-all-and-commit",
          "ui-enhancer",
          "ultrafast-front-orchestrator",
          "ultrafast-orchestrator",
          "unused-media-scanner"
        ],
        healthCheckInterval: 120000,
        maxFailureThreshold: 2,
        autoRegenerate: true,
        deploymentCheck: true,
        logRotation: true
      },
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024,
        maxLogFiles: 30
      },
      monitoring: {
        enabled: true,
        interval: 30000,
        alertThreshold: 3,
        autoRestart: true,
        loadBalancing: true
      }
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
    this.startUltimateMonitoring();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `ultimate-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

  async checkPM2UltimateHealth() {
    this.log("🔍 Checking ultimate PM2 process health...");
    
    try {
      const result = await this.runCommand("pm2", ["status"]);
      
      if (result.status !== 0) {
        this.log("❌ PM2 status check failed", "ERROR");
        return false;
      }

      const processes = this.config.pm2.processes;
      let healthyCount = 0;
      let failedProcesses = [];

      for (const processName of processes) {
        try {
          const processResult = await this.runCommand("pm2", ["show", processName]);
          if (processResult.status === 0 && processResult.stdout.includes("online")) {
            healthyCount++;
          } else {
            failedProcesses.push(processName);
          }
        } catch (error) {
          failedProcesses.push(processName);
        }
      }

      this.log(`📊 PM2 Health: ${healthyCount}/${processes.length} processes healthy`);

      if (failedProcesses.length > 0) {
        this.log(`⚠️ Failed processes: ${failedProcesses.join(", ")}`, "WARN");
        await this.recoverPM2Processes(failedProcesses);
      }

      return healthyCount === processes.length;
    } catch (error) {
      this.log(`❌ PM2 health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async recoverPM2Processes(failedProcesses) {
    this.log("🔄 Attempting to recover failed PM2 processes...");
    
    for (const processName of failedProcesses) {
      try {
        this.log(`🔄 Restarting ${processName}...`);
        
        // Try to restart the process
        const restartResult = await this.runCommand("pm2", ["restart", processName]);
        
        if (restartResult.status === 0) {
          this.log(`✅ Successfully restarted ${processName}`);
        } else {
          // If restart fails, try to start it
          const startResult = await this.runCommand("pm2", ["start", processName]);
          if (startResult.status === 0) {
            this.log(`✅ Successfully started ${processName}`);
          } else {
            this.log(`❌ Failed to start ${processName}`, "ERROR");
          }
        }
      } catch (error) {
        this.log(`❌ Error recovering ${processName}: ${error.message}`, "ERROR");
      }
    }
  }

  async checkGitHubActionsUltimateHealth() {
    this.log("🔍 Checking ultimate GitHub Actions health...");
    
    try {
      // Check if workflow files exist
      const workflows = this.config.githubActions.workflows;
      let existingWorkflows = [];
      let missingWorkflows = [];

      for (const workflow of workflows) {
        if (fs.existsSync(workflow)) {
          existingWorkflows.push(workflow);
        } else {
          missingWorkflows.push(workflow);
        }
      }

      this.log(`📊 GitHub Actions: ${existingWorkflows.length}/${workflows.length} workflows exist`);

      if (missingWorkflows.length > 0) {
        this.log(`⚠️ Missing workflows: ${missingWorkflows.join(", ")}`, "WARN");
        await this.recoverGitHubActionsWorkflows(missingWorkflows);
      }

      // Check backup workflows
      const backupWorkflows = this.config.githubActions.backupWorkflows;
      let existingBackups = [];
      let missingBackups = [];

      for (const backup of backupWorkflows) {
        if (fs.existsSync(backup)) {
          existingBackups.push(backup);
        } else {
          missingBackups.push(backup);
        }
      }

      this.log(`📊 Backup Workflows: ${existingBackups.length}/${backupWorkflows.length} exist`);

      if (missingBackups.length > 0) {
        this.log(`⚠️ Missing backup workflows: ${missingBackups.join(", ")}`, "WARN");
        await this.createBackupWorkflows(missingBackups);
      }

      return existingWorkflows.length === workflows.length && existingBackups.length === backupWorkflows.length;
    } catch (error) {
      this.log(`❌ GitHub Actions health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async recoverGitHubActionsWorkflows(missingWorkflows) {
    this.log("🔄 Attempting to recover missing GitHub Actions workflows...");
    
    for (const workflow of missingWorkflows) {
      try {
        if (workflow.includes("marketing-sync")) {
          await this.createMarketingSyncWorkflow(workflow);
        } else if (workflow.includes("sync-health")) {
          await this.createSyncHealthWorkflow(workflow);
        }
      } catch (error) {
        this.log(`❌ Error recovering workflow ${workflow}: ${error.message}`, "ERROR");
      }
    }
  }

  async createMarketingSyncWorkflow(workflowPath) {
    const workflowContent = `name: Marketing Sync

on:
  schedule:
    - cron: '0 */12 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  run-marketing-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run marketing-sync
        env:
          LINKEDIN_ACCESS_TOKEN: \${{ secrets.LINKEDIN_ACCESS_TOKEN }}
          LINKEDIN_URN: \${{ secrets.LINKEDIN_URN }}
          IG_USER_ID: \${{ secrets.IG_USER_ID }}
          IG_ACCESS_TOKEN: \${{ secrets.IG_ACCESS_TOKEN }}
        run: node automation/marketing-sync.js

      - name: Commit report if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [ -n "\$(git status --porcelain)" ]; then
            git add -A
            git commit -m "chore(marketing): update marketing-sync report"
            git push origin HEAD:main
          else
            echo "No changes to commit."
          fi`;

    try {
      fs.writeFileSync(workflowPath, workflowContent);
      this.log(`✅ Created marketing sync workflow: ${workflowPath}`);
    } catch (error) {
      this.log(`❌ Error creating workflow ${workflowPath}: ${error.message}`, "ERROR");
    }
  }

  async createSyncHealthWorkflow(workflowPath) {
    const workflowContent = `name: Sync Health

on:
  schedule:
    - cron: '*/15 * * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  check-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run pm2-auto-sync (safe mode)
        env:
          AUTO_SYNC_STRATEGY: hardreset
          AUTO_SYNC_CLEAN: '0'
        run: node automation/pm2-auto-sync.js || true

      - name: Push if repository is ahead
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          # Only push if we have local commits not on origin
          AHEAD=\$(git rev-list --left-right --count HEAD...origin/main | awk '{print \$1}')
          if [ "\$AHEAD" != "0" ]; then
            git push origin HEAD:main
          else
            echo "No push needed."
          fi`;

    try {
      fs.writeFileSync(workflowPath, workflowContent);
      this.log(`✅ Created sync health workflow: ${workflowPath}`);
    } catch (error) {
      this.log(`❌ Error creating workflow ${workflowPath}: ${error.message}`, "ERROR");
    }
  }

  async createBackupWorkflows(missingBackups) {
    this.log("🔄 Creating backup workflows...");
    
    for (const backup of missingBackups) {
      try {
        if (backup.includes("marketing-sync-backup")) {
          await this.createMarketingSyncBackupWorkflow(backup);
        } else if (backup.includes("sync-health-backup")) {
          await this.createSyncHealthBackupWorkflow(backup);
        }
      } catch (error) {
        this.log(`❌ Error creating backup workflow ${backup}: ${error.message}`, "ERROR");
      }
    }
  }

  async createMarketingSyncBackupWorkflow(workflowPath) {
    const workflowContent = `name: Marketing Sync Backup

on:
  schedule:
    - cron: '30 */12 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  run-marketing-sync-backup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run marketing-sync backup
        env:
          LINKEDIN_ACCESS_TOKEN: \${{ secrets.LINKEDIN_ACCESS_TOKEN }}
          LINKEDIN_URN: \${{ secrets.LINKEDIN_URN }}
          IG_USER_ID: \${{ secrets.IG_USER_ID }}
          IG_ACCESS_TOKEN: \${{ secrets.IG_ACCESS_TOKEN }}
        run: node automation/marketing-sync.js

      - name: Commit backup report if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [ -n "\$(git status --porcelain)" ]; then
            git add -A
            git commit -m "chore(marketing): update marketing-sync backup report"
            git push origin HEAD:main
          else
            echo "No changes to commit."
          fi`;

    try {
      fs.writeFileSync(workflowPath, workflowContent);
      this.log(`✅ Created marketing sync backup workflow: ${workflowPath}`);
    } catch (error) {
      this.log(`❌ Error creating backup workflow ${workflowPath}: ${error.message}`, "ERROR");
    }
  }

  async createSyncHealthBackupWorkflow(workflowPath) {
    const workflowContent = `name: Sync Health Backup

on:
  schedule:
    - cron: '45 */15 * * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  check-sync-backup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run pm2-auto-sync backup (safe mode)
        env:
          AUTO_SYNC_STRATEGY: hardreset
          AUTO_SYNC_CLEAN: '0'
        run: node automation/pm2-auto-sync.js || true

      - name: Push backup if repository is ahead
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          # Only push if we have local commits not on origin
          AHEAD=\$(git rev-list --left-right --count HEAD...origin/main | awk '{print \$1}')
          if [ "\$AHEAD" != "0" ]; then
            git push origin HEAD:main
          else
            echo "No push needed."
          fi`;

    try {
      fs.writeFileSync(workflowPath, workflowContent);
      this.log(`✅ Created sync health backup workflow: ${workflowPath}`);
    } catch (error) {
      this.log(`❌ Error creating backup workflow ${workflowPath}: ${error.message}`, "ERROR");
    }
  }

  async checkNetlifyFunctionsUltimateHealth() {
    this.log("🔍 Checking ultimate Netlify Functions health...");
    
    try {
      // Check if manifest file exists
      if (!fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        this.log("❌ Netlify Functions manifest file not found", "ERROR");
        await this.regenerateNetlifyFunctionsManifest();
        return false;
      }

      // Check manifest content
      const manifestContent = JSON.parse(fs.readFileSync(this.config.netlifyFunctions.manifestFile, 'utf8'));
      const expectedFunctions = this.config.netlifyFunctions.functions;
      const existingFunctions = manifestContent.functions || [];
      
      this.log(`📊 Netlify Functions: ${existingFunctions.length}/${expectedFunctions.length} functions in manifest`);

      // Check for missing functions
      const missingFunctions = expectedFunctions.filter(func => !existingFunctions.includes(func));
      
      if (missingFunctions.length > 0) {
        this.log(`⚠️ Missing functions: ${missingFunctions.join(", ")}`, "WARN");
        await this.recoverNetlifyFunctions(missingFunctions);
      }

      return missingFunctions.length === 0;
    } catch (error) {
      this.log(`❌ Netlify Functions health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async regenerateNetlifyFunctionsManifest() {
    this.log("🔄 Regenerating Netlify Functions manifest...");
    
    try {
      const result = await this.runCommand("node", ["scripts/generate-netlify-functions-manifest.cjs"]);
      
      if (result.status === 0) {
        this.log("✅ Successfully regenerated Netlify Functions manifest");
      } else {
        this.log(`❌ Failed to regenerate manifest: ${result.stderr}`, "ERROR");
      }
    } catch (error) {
      this.log(`❌ Error regenerating manifest: ${error.message}`, "ERROR");
    }
  }

  async recoverNetlifyFunctions(missingFunctions) {
    this.log("🔄 Attempting to recover missing Netlify Functions...");
    
    try {
      // Regenerate the manifest to include missing functions
      await this.regenerateNetlifyFunctionsManifest();
      
      // Check if functions directory exists
      const functionsDir = "netlify/functions";
      if (!fs.existsSync(functionsDir)) {
        fs.mkdirSync(functionsDir, { recursive: true });
        this.log("✅ Created Netlify functions directory");
      }
      
      this.log(`✅ Attempted to recover ${missingFunctions.length} missing functions`);
    } catch (error) {
      this.log(`❌ Error recovering functions: ${error.message}`, "ERROR");
    }
  }

  async runUltimateHealthCheck() {
    this.log("🚀 Starting ultimate health check...");
    
    const results = {
      pm2: false,
      githubActions: false,
      netlifyFunctions: false,
      timestamp: new Date().toISOString()
    };

    // Check PM2 health
    results.pm2 = await this.checkPM2UltimateHealth();
    
    // Check GitHub Actions health
    results.githubActions = await this.checkGitHubActionsUltimateHealth();
    
    // Check Netlify Functions health
    results.netlifyFunctions = await this.checkNetlifyFunctionsUltimateHealth();

    // Generate health report
    const healthyServices = Object.values(results).filter(Boolean).length - 1; // -1 for timestamp
    const totalServices = 3;
    
    this.log(`📊 Ultimate Health Report: ${healthyServices}/${totalServices} services healthy`);
    
    if (results.pm2) this.log("✅ PM2: Healthy");
    else this.log("❌ PM2: Unhealthy");
    
    if (results.githubActions) this.log("✅ GitHub Actions: Healthy");
    else this.log("❌ GitHub Actions: Unhealthy");
    
    if (results.netlifyFunctions) this.log("✅ Netlify Functions: Healthy");
    else this.log("❌ Netlify Functions: Unhealthy");

    // Save health report
    this.saveHealthReport(results);
    
    return results;
  }

  saveHealthReport(results) {
    try {
      const reportPath = path.join(this.config.logging.logDir, "ultimate-health-report.json");
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
    } catch (error) {
      this.log(`❌ Error saving health report: ${error.message}`, "ERROR");
    }
  }

  initializeMonitoring() {
    this.log("🔧 Initializing ultimate monitoring system...");
    
    // Ensure all required directories exist
    const requiredDirs = [
      this.config.logging.logDir,
      ".github/workflows",
      "netlify/functions"
    ];
    
    for (const dir of requiredDirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        this.log(`✅ Created directory: ${dir}`);
      }
    }
  }

  startUltimateMonitoring() {
    this.log("🚀 Starting ultimate monitoring system...");
    
    // Run initial health check
    this.runUltimateHealthCheck();
    
    // Set up continuous monitoring
    setInterval(async () => {
      await this.runUltimateHealthCheck();
    }, this.config.monitoring.interval);
    
    this.log(`✅ Ultimate monitoring started with ${this.config.monitoring.interval}ms interval`);
  }

  async getStatus() {
    return {
      status: "running",
      config: this.config,
      timestamp: new Date().toISOString(),
      logDirectory: this.config.logging.logDir
    };
  }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-1358
}

// CLI interface
if (require.main === module) {
<<<<<<< HEAD
    const system = new UltimateRedundancyAutomationSystem();
    
    const command = process.argv[2];
    
    switch (command) {
        case 'start':
            system.start();
            break;
        case 'status':
            console.log(JSON.stringify(system.getStatus(), null, 2));
            break;
        case 'report':
            console.log(JSON.stringify(system.generateReport(), null, 2));
            break;
        case 'health':
            system.runHealthCheck().then(healthy => {
                console.log(`Health check result: ${healthy ? 'HEALTHY' : 'UNHEALTHY'}`);
                process.exit(healthy ? 0 : 1);
            });
            break;
        default:
            console.log('Usage: node ultimate-redundancy-automation-system.cjs [start|status|report|health]');
            process.exit(1);
    }
=======
  const system = new UltimateRedundancyAutomationSystem();
  
  const command = process.argv[2];
  
  switch (command) {
    case "start":
      console.log("🚀 Ultimate Redundancy Automation System started");
      break;
    case "status":
      console.log(JSON.stringify(system.getStatus(), null, 2));
      break;
    case "health":
      system.runUltimateHealthCheck();
      break;
    case "test":
      console.log("🧪 Running ultimate redundancy tests...");
      system.runUltimateHealthCheck();
      break;
    default:
      console.log("Ultimate Redundancy Automation System");
      console.log("Usage: node ultimate-redundancy-automation-system.cjs [start|status|health|test]");
      break;
  }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-1358
}

module.exports = UltimateRedundancyAutomationSystem;