#!/usr/bin/env node
"use strict";

const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const https = require("https");

class EnhancedGitHubActionsRedundancy {
  constructor() {
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "enhanced-github-actions-redundancy.log");
    this.ensureLogDir();
    
    this.config = {
<<<<<<< HEAD
      workflows: [
        "marketing-sync.yml",
        "sync-health.yml"
      ],
      workflowPaths: [
        ".github/workflows/marketing-sync.yml",
        ".github/workflows/sync-health.yml"
      ],
      healthCheckInterval: 60000,
      maxFailures: 3,
      retryDelay: 30000,
      autoTrigger: true,
      backupTriggers: true,
      enableWorkflowValidation: true,
      enableAutoRecovery: true,
      enableMetricsCollection: true,
      workflowTemplates: {
        "marketing-sync.yml": this.getMarketingSyncTemplate(),
        "sync-health.yml": this.getSyncHealthTemplate()
      }
=======
      enabled: true,
      checkInterval: 60000,
      maxFailures: 3,
      retryDelay: 30000,
      autoTrigger: true,
      backupWorkflows: true,
      healthCheckWorkflow: "sync-health.yml",
      criticalWorkflows: [
        "marketing-sync.yml",
        "sync-health.yml"
      ],
      workflowValidation: true,
      yamlValidation: true,
      cronValidation: true,
      autoFix: true,
      maxFixAttempts: 3,
      alertThreshold: 3,
      logRotation: true,
      maxLogSize: 10 * 1024 * 1024, // 10MB
      maxLogFiles: 30
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    };
    
    this.monitoring = false;
    this.checkInterval = null;
<<<<<<< HEAD
    this.failureCounts = new Map();
    this.lastHealthCheck = null;
=======
    this.failureCount = 0;
    this.healthHistory = [];
    this.fixAttempts = new Map();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

<<<<<<< HEAD
  getMarketingSyncTemplate() {
    return `name: Marketing Sync

on:
  schedule:
    - cron: '0 */12 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  run-marketing-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run marketing-sync
        env:
          LINKEDIN_ACCESS_TOKEN: \${{ secrets.LINKEDIN_ACCESS_TOKEN }}
          LINKEDIN_URN: \${{ secrets.LINKEDIN_URN }}
          IG_USER_ID: \${{ secrets.IG_USER_ID }}
          IG_ACCESS_TOKEN: \${{ secrets.IG_ACCESS_TOKEN }}
        run: node automation/marketing-sync.js

      - name: Commit report if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [ -n "\$(git status --porcelain)" ]; then
            git add -A
            git commit -m "chore(marketing): update marketing-sync report"
            git push origin HEAD:main
          else
            echo "No changes to commit."
          fi`;
  }

  getSyncHealthTemplate() {
    return `name: Sync Health

on:
  schedule:
    - cron: '*/15 * * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  check-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run pm2-auto-sync (safe mode)
        env:
          AUTO_SYNC_STRATEGY: hardreset
          AUTO_SYNC_CLEAN: '0'
        run: node automation/pm2-auto-sync.js || true

      - name: Push if repository is ahead
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          AHEAD=\$(git rev-list --left-right --count HEAD...origin/main | awk '{print \$1}')
          if [ "\$AHEAD" != "0" ]; then
            git push origin HEAD:main
          else
            echo "No push needed."
          fi`;
  }

=======
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: this.workspace,
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 10,
        timeout: options.timeout || 30000,
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

  async checkWorkflowsDirectory() {
    try {
      const workflowsDir = path.join(this.workspace, ".github/workflows");
      if (!fs.existsSync(workflowsDir)) {
        this.log("‚ùå GitHub workflows directory not found", "ERROR");
<<<<<<< HEAD
        return { exists: false, workflows: [] };
      }

      const workflowFiles = fs.readdirSync(workflowsDir).filter(file => file.endsWith('.yml'));
      this.log(`üìã Found ${workflowFiles.length} workflow files`);
      
      return { exists: true, workflows: workflowFiles };
    } catch (error) {
      this.log(`‚ùå Error checking workflows directory: ${error.message}`, "ERROR");
      return { exists: false, workflows: [] };
=======
        return { exists: false, workflows: [], error: "Directory not found" };
      }

      const workflowFiles = fs.readdirSync(workflowsDir).filter(file => file.endsWith('.yml'));
      this.log(`üìã Found ${workflowFiles.length} workflow files in .github/workflows`);
      
      return { exists: true, workflows: workflowFiles, error: null };
    } catch (error) {
      this.log(`‚ùå Error checking workflows directory: ${error.message}`, "ERROR");
      return { exists: false, workflows: [], error: error.message };
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    }
  }

  async validateWorkflow(workflowPath) {
    try {
<<<<<<< HEAD
      const content = fs.readFileSync(workflowPath, 'utf8');
      
      // Basic YAML structure validation
      const requiredSections = ['on:', 'jobs:'];
      const hasRequiredSections = requiredSections.every(section => content.includes(section));
      
      if (!hasRequiredSections) {
        this.log(`‚ö†Ô∏è Workflow ${path.basename(workflowPath)} missing required sections`, "WARN");
        return { valid: false, errors: ["Missing required YAML sections"] };
      }

      // Check for common syntax issues
      const syntaxIssues = [];
      
      // Check for proper indentation
      const lines = content.split('\n');
      let indentLevel = 0;
      let hasIndentationIssues = false;
      
      for (const line of lines) {
        if (line.trim() === '') continue;
        
        const currentIndent = line.search(/\S/);
        if (currentIndent < 0) continue;
        
        if (currentIndent < indentLevel && currentIndent !== 0) {
          hasIndentationIssues = true;
          break;
        }
        indentLevel = currentIndent;
      }
      
      if (hasIndentationIssues) {
        syntaxIssues.push("Potential indentation issues");
      }

      // Check for unclosed quotes or brackets
      const quoteCount = (content.match(/"/g) || []).length;
      if (quoteCount % 2 !== 0) {
        syntaxIssues.push("Unclosed quotes detected");
      }

      const bracketCount = (content.match(/\{/g) || []).length;
      const closeBracketCount = (content.match(/\}/g) || []).length;
      if (bracketCount !== closeBracketCount) {
        syntaxIssues.push("Unclosed brackets detected");
      }

      if (syntaxIssues.length > 0) {
        this.log(`‚ö†Ô∏è Workflow ${path.basename(workflowPath)} has syntax issues: ${syntaxIssues.join(', ')}`, "WARN");
        return { valid: false, errors: syntaxIssues };
      }

      this.log(`‚úÖ Workflow ${path.basename(workflowPath)} is valid`);
      return { valid: true, errors: [] };
    } catch (error) {
      this.log(`‚ùå Error validating workflow ${path.basename(workflowPath)}: ${error.message}`, "ERROR");
      return { valid: false, errors: [error.message] };
    }
  }

  async checkWorkflowHealth(workflowName) {
    try {
      const workflowPath = path.join(this.workspace, ".github/workflows", workflowName);
      
      if (!fs.existsSync(workflowPath)) {
        this.log(`‚ùå Workflow ${workflowName} not found`, "ERROR");
        return { exists: false, valid: false, errors: ["Workflow file not found"] };
      }

      const validation = await this.validateWorkflow(workflowPath);
      
      return {
        exists: true,
        valid: validation.valid,
        errors: validation.errors,
        path: workflowPath
      };
    } catch (error) {
      this.log(`‚ùå Error checking workflow ${workflowName}: ${error.message}`, "ERROR");
      return { exists: false, valid: false, errors: [error.message] };
    }
  }

  async restoreWorkflow(workflowName) {
    this.log(`üîß Attempting to restore workflow: ${workflowName}`);
    
    try {
      const template = this.config.workflowTemplates[workflowName];
      if (!template) {
        this.log(`‚ùå No template available for workflow: ${workflowName}`, "ERROR");
        return false;
      }

      const workflowPath = path.join(this.workspace, ".github/workflows", workflowName);
      const workflowsDir = path.dirname(workflowPath);
      
      // Ensure workflows directory exists
      if (!fs.existsSync(workflowsDir)) {
        fs.mkdirSync(workflowsDir, { recursive: true });
        this.log(`üìÅ Created workflows directory: ${workflowsDir}`);
      }

      // Write the workflow file
      fs.writeFileSync(workflowPath, template);
      this.log(`‚úÖ Successfully restored workflow: ${workflowName}`);
      
      // Commit the restored workflow
      await this.commitWorkflowRestoration(workflowName);
      
      return true;
    } catch (error) {
      this.log(`‚ùå Failed to restore workflow ${workflowName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async commitWorkflowRestoration(workflowName) {
    try {
      // Add the restored workflow
      const addResult = await this.runCommand("git", ["add", `.github/workflows/${workflowName}`]);
      if (addResult.status !== 0) {
        this.log(`‚ö†Ô∏è Failed to add restored workflow to git: ${workflowName}`, "WARN");
        return false;
      }

      // Commit the restoration
      const commitResult = await this.runCommand("git", [
        "commit", 
        "-m", 
        `fix(workflows): restore missing workflow ${workflowName}`
      ]);
      
      if (commitResult.status !== 0) {
        this.log(`‚ö†Ô∏è Failed to commit workflow restoration: ${workflowName}`, "WARN");
        return false;
      }

      this.log(`‚úÖ Committed workflow restoration: ${workflowName}`);
      return true;
    } catch (error) {
      this.log(`‚ùå Error committing workflow restoration: ${error.message}`, "ERROR");
      return false;
    }
  }

  async triggerWorkflow(workflowName) {
    if (!this.config.autoTrigger) {
      this.log(`‚ö†Ô∏è Auto-triggering disabled for workflow: ${workflowName}`);
      return false;
    }

    this.log(`üöÄ Triggering workflow: ${workflowName}`);
    
    try {
      // This would typically use GitHub API to trigger workflows
      // For now, we'll simulate by checking if the workflow can be triggered manually
      const workflowPath = path.join(this.workspace, ".github/workflows", workflowName);
      
      if (fs.existsSync(workflowPath)) {
        const content = fs.readFileSync(workflowPath, 'utf8');
        if (content.includes('workflow_dispatch:')) {
          this.log(`‚úÖ Workflow ${workflowName} supports manual triggering`);
          return true;
        } else {
          this.log(`‚ö†Ô∏è Workflow ${workflowName} does not support manual triggering`);
          return false;
        }
      } else {
        this.log(`‚ùå Workflow ${workflowName} not found for triggering`);
        return false;
      }
    } catch (error) {
      this.log(`‚ùå Error triggering workflow ${workflowName}: ${error.message}`, "ERROR");
      return false;
    }
=======
      const workflowContent = fs.readFileSync(workflowPath, 'utf8');
      const validation = {
        valid: true,
        errors: [],
        warnings: [],
        hasName: false,
        hasTriggers: false,
        hasJobs: false,
        cronValid: true
      };

      // Check for required sections
      if (workflowContent.includes('name:')) {
        validation.hasName = true;
      } else {
        validation.errors.push("Missing 'name:' field");
        validation.valid = false;
      }

      if (workflowContent.includes('on:')) {
        validation.hasTriggers = true;
      } else {
        validation.errors.push("Missing 'on:' section");
        validation.valid = false;
      }

      if (workflowContent.includes('jobs:')) {
        validation.hasJobs = true;
      } else {
        validation.errors.push("Missing 'jobs:' section");
        validation.valid = false;
      }

      // Validate cron syntax if present
      if (workflowContent.includes('cron:')) {
        const cronMatches = workflowContent.match(/cron:\s*['"`]([^'"`]+)['"`]/g);
        if (cronMatches) {
          for (const match of cronMatches) {
            const cronExpression = match.match(/cron:\s*['"`]([^'"`]+)['"`]/)[1];
            if (!this.isValidCronExpression(cronExpression)) {
              validation.errors.push(`Invalid cron expression: ${cronExpression}`);
              validation.cronValid = false;
              validation.valid = false;
            }
          }
        }
      }

      // Check for common YAML issues
      if (workflowContent.includes('\t')) {
        validation.warnings.push("Contains tabs (should use spaces)");
      }

      if (workflowContent.includes('  - ')) {
        // Check for proper YAML list formatting
        const lines = workflowContent.split('\n');
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.trim().startsWith('-') && !line.startsWith('  -')) {
            validation.warnings.push(`List item at line ${i + 1} may have incorrect indentation`);
          }
        }
      }

      return validation;
    } catch (error) {
      return {
        valid: false,
        errors: [`Error reading workflow: ${error.message}`],
        warnings: [],
        hasName: false,
        hasTriggers: false,
        hasJobs: false,
        cronValid: false
      };
    }
  }

  isValidCronExpression(cron) {
    // Basic cron validation (5 or 6 fields)
    const parts = cron.split(' ');
    if (parts.length !== 5 && parts.length !== 6) {
      return false;
    }

    // Check each field
    for (let i = 0; i < Math.min(parts.length, 5); i++) {
      const part = parts[i];
      if (part === '*' || part === '?') continue;
      
      // Check for valid ranges and lists
      if (part.includes(',')) {
        const values = part.split(',');
        for (const value of values) {
          if (!this.isValidCronField(value, i)) {
            return false;
          }
        }
      } else if (part.includes('-')) {
        const [start, end] = part.split('-');
        if (!this.isValidCronField(start, i) || !this.isValidCronField(end, i)) {
          return false;
        }
      } else if (part.includes('/')) {
        const [value, step] = part.split('/');
        if (!this.isValidCronField(value, i) || !this.isValidCronField(step, i)) {
          return false;
        }
      } else {
        if (!this.isValidCronField(part, i)) {
          return false;
        }
      }
    }

    return true;
  }

  isValidCronField(field, position) {
    if (field === '*' || field === '?') return true;
    
    const num = parseInt(field);
    if (isNaN(num)) return false;
    
    // Field-specific validation
    switch (position) {
      case 0: // minute: 0-59
        return num >= 0 && num <= 59;
      case 1: // hour: 0-23
        return num >= 0 && num <= 23;
      case 2: // day of month: 1-31
        return num >= 1 && num <= 31;
      case 3: // month: 1-12
        return num >= 1 && num <= 12;
      case 4: // day of week: 0-7 (0 and 7 are Sunday)
        return num >= 0 && num <= 7;
      default:
        return true;
    }
  }

  async createBackupWorkflows() {
    try {
      const backupDir = path.join(this.workspace, ".github/workflows/backup");
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      const workflowsDir = path.join(this.workspace, ".github/workflows");
      const workflowFiles = fs.readdirSync(workflowsDir).filter(file => file.endsWith('.yml'));

      for (const workflow of workflowFiles) {
        const sourcePath = path.join(workflowsDir, workflow);
        const backupPath = path.join(backupDir, `${workflow}.backup`);
        
        if (fs.existsSync(sourcePath) && !fs.existsSync(backupPath)) {
          fs.copyFileSync(sourcePath, backupPath);
          this.log(`üíæ Created backup for workflow: ${workflow}`);
        }
      }

      this.log(`‚úÖ Created backups for ${workflowFiles.length} workflows`);
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not create backup workflows: ${error.message}`, "WARN");
    }
  }

  async validateAllWorkflows() {
    this.log("üîç Validating all GitHub Actions workflows...");
    
    const workflowsDir = path.join(this.workspace, ".github/workflows");
    const workflowFiles = fs.readdirSync(workflowsDir).filter(file => file.endsWith('.yml'));
    
    const validationResults = {};
    let totalValid = 0;
    let totalErrors = 0;
    let totalWarnings = 0;

    for (const workflow of workflowFiles) {
      const workflowPath = path.join(workflowsDir, workflow);
      const validation = await this.validateWorkflow(workflowPath);
      
      validationResults[workflow] = validation;
      
      if (validation.valid) {
        totalValid++;
        this.log(`‚úÖ Workflow ${workflow} is valid`);
      } else {
        this.log(`‚ùå Workflow ${workflow} has validation errors:`, "ERROR");
        validation.errors.forEach(error => this.log(`   - ${error}`, "ERROR"));
        totalErrors += validation.errors.length;
      }
      
      if (validation.warnings.length > 0) {
        this.log(`‚ö†Ô∏è Workflow ${workflow} has warnings:`, "WARN");
        validation.warnings.forEach(warning => this.log(`   - ${warning}`, "WARN"));
        totalWarnings += validation.warnings.length;
      }
    }

    this.log(`üìä Workflow Validation Summary:`);
    this.log(`   Total workflows: ${workflowFiles.length}`);
    this.log(`   Valid: ${totalValid}`);
    this.log(`   Errors: ${totalErrors}`);
    this.log(`   Warnings: ${totalWarnings}`);

    return validationResults;
  }

  async checkWorkflowTriggers() {
    this.log("üîç Checking workflow triggers and schedules...");
    
    const workflowsDir = path.join(this.workspace, ".github/workflows");
    const workflowFiles = fs.readdirSync(workflowsDir).filter(file => file.endsWith('.yml'));
    
    const triggerResults = {};
    
    for (const workflow of workflowFiles) {
      const workflowPath = path.join(workflowsDir, workflow);
      const content = fs.readFileSync(workflowPath, 'utf8');
      
      const triggers = {
        manual: content.includes('workflow_dispatch:'),
        push: content.includes('push:'),
        pull_request: content.includes('pull_request:'),
        schedule: content.includes('schedule:'),
        cron: content.includes('cron:'),
        repository_dispatch: content.includes('repository_dispatch:')
      };
      
      triggerResults[workflow] = triggers;
      
      this.log(`üìã Workflow ${workflow} triggers:`);
      Object.entries(triggers).forEach(([trigger, enabled]) => {
        if (enabled) {
          this.log(`   ‚úÖ ${trigger}`);
        }
      });
    }

    return triggerResults;
  }

  async checkWorkflowDependencies() {
    this.log("üîç Checking workflow dependencies and actions...");
    
    const workflowsDir = path.join(this.workspace, ".github/workflows");
    const workflowFiles = fs.readdirSync(workflowsDir).filter(file => file.endsWith('.yml'));
    
    const dependencyResults = {};
    
    for (const workflow of workflowFiles) {
      const workflowPath = path.join(workflowsDir, workflow);
      const content = fs.readFileSync(workflowPath, 'utf8');
      
      // Extract action references
      const actionMatches = content.match(/uses:\s*([^\s\n]+)/g);
      const actions = actionMatches ? actionMatches.map(match => match.replace('uses:', '').trim()) : [];
      
      // Extract Node.js version
      const nodeVersionMatch = content.match(/node-version:\s*['"`]([^'"`]+)['"`]/);
      const nodeVersion = nodeVersionMatch ? nodeVersionMatch[1] : null;
      
      dependencyResults[workflow] = {
        actions: actions,
        nodeVersion: nodeVersion,
        actionCount: actions.length
      };
      
      this.log(`üì¶ Workflow ${workflow} dependencies:`);
      this.log(`   Node.js version: ${nodeVersion || 'Not specified'}`);
      this.log(`   Actions used: ${actions.length}`);
      actions.forEach(action => this.log(`     - ${action}`));
    }

    return dependencyResults;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
  }

  async performComprehensiveHealthCheck() {
    this.log("üöÄ Starting comprehensive GitHub Actions health check...");
    
    const results = {
<<<<<<< HEAD
      workflows: {},
      summary: {
        total: this.config.workflows.length,
        healthy: 0,
        unhealthy: 0,
        restored: 0,
        triggered: 0
      },
      timestamp: new Date().toISOString()
    };

    // Check workflows directory
    const workflowsDir = await this.checkWorkflowsDirectory();
    if (!workflowsDir.exists) {
      this.log("‚ùå Workflows directory not found, attempting to create...", "ERROR");
      fs.mkdirSync(path.join(this.workspace, ".github/workflows"), { recursive: true });
    }

    // Check each workflow
    for (const workflowName of this.config.workflows) {
      const workflowHealth = await this.checkWorkflowHealth(workflowName);
      results.workflows[workflowName] = workflowHealth;
      
      if (workflowHealth.exists && workflowHealth.valid) {
        results.summary.healthy++;
        this.log(`‚úÖ Workflow ${workflowName} is healthy`);
      } else {
        results.summary.unhealthy++;
        this.log(`‚ùå Workflow ${workflowName} is unhealthy`);
        
        if (this.config.enableAutoRecovery) {
          const restored = await this.restoreWorkflow(workflowName);
          if (restored) {
            results.summary.restored++;
            this.log(`‚úÖ Successfully restored workflow: ${workflowName}`);
          }
        }
      }
    }

    // Generate and log health report
    const healthReport = this.generateHealthReport(results);
    this.log(healthReport);

    // Save health report
    this.saveHealthReport(results);

    this.lastHealthCheck = results;
    return results;
  }

  generateHealthReport(results) {
    let workflowStatus = "";
    for (const [workflowName, health] of Object.entries(results.workflows)) {
      const status = health.exists && health.valid ? "‚úÖ" : "‚ùå";
      const details = health.exists ? health.valid ? "HEALTHY" : `UNHEALTHY: ${health.errors.join(', ')}` : "MISSING";
      workflowStatus += `${status} ${workflowName}: ${details}\n`;
    }

    return `
üìä ENHANCED GITHUB ACTIONS HEALTH REPORT
=========================================
Timestamp: ${results.timestamp}

üìã Workflow Health Summary:
Total Workflows: ${results.summary.total}
Healthy: ${results.summary.healthy}
Unhealthy: ${results.summary.unhealthy}
Restored: ${results.summary.restored}
Triggered: ${results.summary.triggered}

üîç Individual Workflow Status:
${workflowStatus}

${results.summary.healthy === results.summary.total ? 
  "üéâ All GitHub Actions workflows are healthy!" : 
  "‚ö†Ô∏è Some GitHub Actions workflows require attention. Check logs for details."}
`;
  }

  saveHealthReport(results) {
    try {
      const reportPath = path.join(this.logDir, `github-actions-health-report-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      this.log(`üìù GitHub Actions health report saved to ${reportPath}`);
    } catch (error) {
      this.log(`‚ùå Failed to save GitHub Actions health report: ${error.message}`, "ERROR");
=======
      workflowsDirectory: {},
      workflowValidation: {},
      triggers: {},
      dependencies: {},
      overall: false,
      timestamp: new Date().toISOString()
    };

    try {
      // Check workflows directory
      results.workflowsDirectory = await this.checkWorkflowsDirectory();
      
      if (!results.workflowsDirectory.exists) {
        this.log("‚ùå Workflows directory check failed", "ERROR");
        results.overall = false;
        return results;
      }

      // Validate workflows
      results.workflowValidation = await this.validateAllWorkflows();
      
      // Check triggers
      results.triggers = await this.checkWorkflowTriggers();
      
      // Check dependencies
      results.dependencies = await this.checkWorkflowDependencies();
      
      // Create backups if enabled
      if (this.config.backupWorkflows) {
        await this.createBackupWorkflows();
      }
      
      // Determine overall health
      const hasErrors = Object.values(results.workflowValidation).some(validation => !validation.valid);
      results.overall = !hasErrors && results.workflowsDirectory.exists;
      
      // Generate health summary
      this.log(`üìä GitHub Actions Health Summary:`);
      this.log(`   Workflows directory: ${results.workflowsDirectory.exists ? '‚úÖ' : '‚ùå'}`);
      this.log(`   Workflows valid: ${results.overall ? '‚úÖ' : '‚ùå'}`);
      this.log(`   Total workflows: ${results.workflowsDirectory.workflows.length}`);
      
      if (results.overall) {
        this.log("üéâ All GitHub Actions workflows are healthy!");
        this.failureCount = 0; // Reset failure count on success
      } else {
        this.failureCount++;
        this.log(`‚ö†Ô∏è GitHub Actions health check failed (attempt ${this.failureCount})`, "WARN");
        
        if (this.failureCount >= this.config.alertThreshold) {
          this.log(`üö® Alert threshold reached (${this.failureCount}/${this.config.alertThreshold})`, "ERROR");
        }
      }
      
      // Save health history
      this.healthHistory.push(results);
      if (this.healthHistory.length > 100) {
        this.healthHistory = this.healthHistory.slice(-100);
      }
      
      // Save detailed health report
      await this.saveHealthReport(results);
      
    } catch (error) {
      this.log(`‚ùå Comprehensive health check failed: ${error.message}`, "ERROR");
      results.overall = false;
      this.failureCount++;
    }

    return results;
  }

  async saveHealthReport(results) {
    try {
      const reportPath = path.join(this.logDir, "github-actions-health-report.json");
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      
      // Also save to logs directory with timestamp
      const logReportPath = path.join(this.logDir, `github-actions-health-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(logReportPath, JSON.stringify(results, null, 2));
      
      this.log(`üíæ Health report saved`);
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not save health report: ${error.message}`, "WARN");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    }
  }

  async startMonitoring() {
    if (this.monitoring) {
<<<<<<< HEAD
      this.log("‚ö†Ô∏è Monitoring is already running");
      return;
    }

    this.log("üöÄ Starting enhanced GitHub Actions redundancy monitoring...");
    this.monitoring = true;

    // Initial health check
    await this.performComprehensiveHealthCheck();

    // Set up periodic monitoring
    this.checkInterval = setInterval(async () => {
      await this.performComprehensiveHealthCheck();
    }, this.config.healthCheckInterval);

    this.log("‚úÖ Enhanced GitHub Actions redundancy monitoring started successfully");
=======
      this.log("‚ö†Ô∏è Monitoring is already running", "WARN");
      return;
    }

    this.log("üîç Starting enhanced GitHub Actions redundancy monitoring...");
    this.monitoring = true;

    // Perform initial health check
    await this.performComprehensiveHealthCheck();

    // Start periodic monitoring
    this.checkInterval = setInterval(async () => {
      try {
        await this.performComprehensiveHealthCheck();
      } catch (error) {
        this.log(`‚ùå Monitoring cycle failed: ${error.message}`, "ERROR");
      }
    }, this.config.checkInterval);

    this.log(`‚úÖ Enhanced GitHub Actions redundancy monitoring started with ${this.config.checkInterval}ms intervals`);
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
  }

  async stopMonitoring() {
    if (!this.monitoring) {
<<<<<<< HEAD
      this.log("‚ö†Ô∏è Monitoring is not running");
=======
      this.log("‚ö†Ô∏è Monitoring is not running", "WARN");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
      return;
    }

    this.log("üõë Stopping enhanced GitHub Actions redundancy monitoring...");
<<<<<<< HEAD
    this.monitoring = false;

=======
    
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
<<<<<<< HEAD

=======
    
    this.monitoring = false;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    this.log("‚úÖ Enhanced GitHub Actions redundancy monitoring stopped");
  }

  async emergencyRecovery() {
<<<<<<< HEAD
    this.log("üö® Starting emergency GitHub Actions recovery...");
    
    try {
      // Ensure workflows directory exists
      const workflowsDir = path.join(this.workspace, ".github/workflows");
      if (!fs.existsSync(workflowsDir)) {
        fs.mkdirSync(workflowsDir, { recursive: true });
      }

      // Restore all missing workflows
      let restoredCount = 0;
      for (const workflowName of this.config.workflows) {
        const workflowPath = path.join(workflowsDir, workflowName);
        if (!fs.existsSync(workflowPath)) {
          const restored = await this.restoreWorkflow(workflowName);
          if (restored) restoredCount++;
        }
      }

      this.log(`‚úÖ Emergency GitHub Actions recovery completed. Restored ${restoredCount} workflows.`);
      return true;
    } catch (error) {
      this.log(`‚ùå Emergency GitHub Actions recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  getStatus() {
    return {
      monitoring: this.monitoring,
      config: this.config,
      lastHealthCheck: this.lastHealthCheck,
      failureCounts: Object.fromEntries(this.failureCounts)
    };
  }
}

// Start the enhanced GitHub Actions redundancy system
if (require.main === module) {
  const githubActionsRedundancy = new EnhancedGitHubActionsRedundancy();
  
  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\nüõë Shutting down enhanced GitHub Actions redundancy system...');
    await githubActionsRedundancy.stopMonitoring();
=======
    this.log("üö® Emergency recovery mode activated for GitHub Actions...");
    
    try {
      // Stop monitoring temporarily
      await this.stopMonitoring();
      
      // Create emergency backups
      await this.createBackupWorkflows();
      
      // Attempt to fix common issues
      if (this.config.autoFix) {
        await this.attemptAutoFix();
      }
      
      // Restart monitoring
      await this.startMonitoring();
      
      this.log("‚úÖ Emergency recovery completed");
    } catch (error) {
      this.log(`‚ùå Emergency recovery failed: ${error.message}`, "ERROR");
      
      // Try to restart monitoring anyway
      try {
        await this.startMonitoring();
      } catch (monitoringError) {
        this.log(`‚ùå Failed to restart monitoring: ${monitoringError.message}`, "ERROR");
      }
    }
  }

  async attemptAutoFix() {
    this.log("üîß Attempting automatic fixes...");
    
    try {
      // Check for common issues and fix them
      const workflowsDir = path.join(this.workspace, ".github/workflows");
      const workflowFiles = fs.readdirSync(workflowsDir).filter(file => file.endsWith('.yml'));
      
      for (const workflow of workflowFiles) {
        const attempts = this.fixAttempts.get(workflow) || 0;
        
        if (attempts >= this.config.maxFixAttempts) {
          this.log(`‚ö†Ô∏è Skipping ${workflow} - max fix attempts reached`, "WARN");
          continue;
        }
        
        const workflowPath = path.join(workflowsDir, workflow);
        const content = fs.readFileSync(workflowPath, 'utf8');
        let fixed = false;
        
        // Fix common YAML issues
        if (content.includes('\t')) {
          const fixedContent = content.replace(/\t/g, '  ');
          fs.writeFileSync(workflowPath, fixedContent);
          this.log(`üîß Fixed tabs in ${workflow}`);
          fixed = true;
        }
        
        // Fix common cron syntax issues
        if (content.includes('cron:') && content.includes('*/')) {
          // Check for invalid cron expressions
          const cronMatches = content.match(/cron:\s*['"`]([^'"`]+)['"`]/g);
          if (cronMatches) {
            for (const match of cronMatches) {
              const cronExpression = match.match(/cron:\s*['"`]([^'"`]+)['"`]/)[1];
              if (!this.isValidCronExpression(cronExpression)) {
                this.log(`‚ö†Ô∏è Invalid cron expression found in ${workflow}: ${cronExpression}`, "WARN");
                // Could implement cron fixing logic here
              }
            }
          }
        }
        
        if (fixed) {
          this.fixAttempts.set(workflow, attempts + 1);
        }
      }
      
      this.log("‚úÖ Auto-fix attempts completed");
    } catch (error) {
      this.log(`‚ö†Ô∏è Auto-fix failed: ${error.message}`, "WARN");
    }
  }

  getHealthHistory() {
    return this.healthHistory;
  }

  getFailureCount() {
    return this.failureCount;
  }

  getFixAttempts() {
    return Object.fromEntries(this.fixAttempts);
  }

  async cleanup() {
    this.log("üßπ Cleaning up enhanced GitHub Actions redundancy...");
    
    try {
      await this.stopMonitoring();
      
      // Rotate logs if enabled
      if (this.config.logRotation) {
        await this.rotateLogs();
      }
      
      this.log("‚úÖ Cleanup completed");
    } catch (error) {
      this.log(`‚ùå Cleanup failed: ${error.message}`, "ERROR");
    }
  }

  async rotateLogs() {
    try {
      const logFiles = fs.readdirSync(this.logDir)
        .filter(file => file.startsWith('enhanced-github-actions-redundancy'))
        .sort();

      // Remove old log files if we exceed maxLogFiles
      if (logFiles.length > this.config.maxLogFiles) {
        const filesToRemove = logFiles.slice(0, logFiles.length - this.config.maxLogFiles);
        
        for (const file of filesToRemove) {
          const filePath = path.join(this.logDir, file);
          fs.unlinkSync(filePath);
          this.log(`üóëÔ∏è Removed old log file: ${file}`);
        }
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not rotate logs: ${error.message}`, "WARN");
    }
  }
}

// Start the enhanced GitHub Actions redundancy monitor if run directly
if (require.main === module) {
  const monitor = new EnhancedGitHubActionsRedundancy();
  
  // Handle process signals
  process.on('SIGINT', async () => {
    console.log('\nüõë Received SIGINT, shutting down gracefully...');
    await monitor.cleanup();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    process.exit(0);
  });
  
  process.on('SIGTERM', async () => {
<<<<<<< HEAD
    console.log('\nüõë Terminating enhanced GitHub Actions redundancy system...');
    await githubActionsRedundancy.stopMonitoring();
    process.exit(0);
  });

  // Start monitoring
  githubActionsRedundancy.startMonitoring();
=======
    console.log('\nüõë Received SIGTERM, shutting down gracefully...');
    await monitor.cleanup();
    process.exit(0);
  });
  
  // Start monitoring
  monitor.startMonitoring().catch(error => {
    console.error('‚ùå Failed to start monitoring:', error);
    process.exit(1);
  });
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
}

module.exports = EnhancedGitHubActionsRedundancy;