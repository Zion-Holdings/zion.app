#!/usr/bin/env node
"use strict";

<<<<<<< HEAD
const { spawnSync, execSync } = require("child_process");
=======
const { spawnSync, execSync, spawn } = require("child_process");
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-ce5e
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

class UltimateRedundancyAutomationSystem {
  constructor() {
<<<<<<< HEAD
    this.config = {
      pm2: {
        ecosystemFiles: [
          "ecosystem.pm2.cjs",
          "ecosystem.redundancy.cjs", 
          "ecosystem.comprehensive-redundancy.cjs",
          "ecosystem.ultimate-redundancy.cjs",
          "ecosystem-redundancy.pm2.cjs"
=======
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "ultimate-redundancy-automation.log");
    this.statusFile = path.join(this.workspace, "automation/ultimate-redundancy-status.json");
    this.ensureLogDir();
    
    this.config = {
      // PM2 Redundancy Configuration
      pm2: {
        ecosystemFiles: [
          "ecosystem.pm2.cjs",
          "ecosystem-redundancy.pm2.cjs",
          "ecosystem.redundancy.cjs",
          "ecosystem.comprehensive-redundancy.cjs"
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-ce5e
        ],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
<<<<<<< HEAD
          "master-redundancy-orchestrator",
          "enhanced-pm2-redundancy",
          "enhanced-github-actions-redundancy",
          "enhanced-netlify-functions-redundancy",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor",
          "ultimate-redundancy-master",
          "ultimate-redundancy-system"
        ],
        healthCheckInterval: 15000,
        maxRestartAttempts: 10,
        restartDelay: 3000,
        autoRecovery: true,
        processMonitoring: true,
        logRotation: true
      },
      githubActions: {
        workflows: [
          ".github/workflows/marketing-sync.yml",
          ".github/workflows/sync-health.yml",
          ".github/workflows/marketing-sync-backup.yml",
          ".github/workflows/sync-health-backup.yml"
        ],
        healthCheckInterval: 30000,
        maxFailureThreshold: 5,
        autoTrigger: true,
        backupTriggers: true,
        workflowValidation: true,
        apiHealthCheck: true,
        backupRestoration: true
      },
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
=======
          "zion-auto-sync-backup",
          "zion-auto-sync-cron-backup",
          "redundancy-master-orchestrator",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor",
          "redundancy-automation-system",
          "comprehensive-redundancy-orchestrator",
          "ultimate-redundancy-master"
        ],
        healthCheckInterval: 30000,
        maxRestartAttempts: 5,
        restartDelay: 5000,
        memoryThreshold: 80,
        cpuThreshold: 90,
        autoRecovery: true
      },
      
      // GitHub Actions Redundancy Configuration
      github: {
        workflows: [
          "marketing-sync",
          "sync-health",
          "marketing-sync-backup",
          "sync-health-backup"
        ],
        backupWorkflows: [
          "marketing-sync-backup",
          "sync-health-backup"
        ],
        triggerInterval: 300000, // 5 minutes
        maxRetries: 3,
        retryDelay: 60000, // 1 minute
        autoTrigger: true,
        healthMonitoring: true
      },
      
      // Netlify Functions Redundancy Configuration
      netlify: {
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-ce5e
        functions: [
          "a11y-alt-text-runner",
          "adaptive-orchestrator",
          "ai-changelog-runner",
          "ai-trends-radar-runner",
          "anchor-links-auto-fixer",
          "auto-discovery-runner",
          "auto-scheduler",
          "automation-matrix",
          "autonomous-invention-orchestrator",
          "autonomous-meta-orchestrator",
          "broken-image-scanner",
          "broken-image-scanner-runner",
          "canonical-auditor",
          "cloud_deep_research",
          "cloud_orchestrator",
          "code-smell-audit-runner",
          "component-coupling-graph-runner",
          "component-props-docs-runner",
          "component-size-report",
          "content-freshness-score-runner",
          "continuous-front-runner",
          "continuous-orchestrator",
          "dead-code-audit",
          "dead-code-report",
          "deps-auto-upgrade-runner",
          "docs-index-runner",
          "docs-search-index-runner",
          "duplicate-media-finder-runner",
          "external-link-check-runner",
          "fast-front-promoter",
          "fast-orchestrator",
          "feature-advertiser",
          "features-capabilities-benefits-advertiser",
          "front-ads-promoter",
          "front-enhancer",
          "front-index-futurizer",
          "front-index-orchestrator",
          "front-index-scheduler",
          "front-maximizer",
          "front-visionary-expander",
          "frontpage-enhancer",
          "frontpage-scheduler",
          "headers-enforcer",
          "home-visionary-expander",
          "homepage-advertiser-scheduler",
          "homepage-enhancer",
          "homepage-updater",
          "homepage-updater-scheduler",
          "homepage_advertiser",
          "hyper-front-index-accelerator",
          "image-optimizer-runner",
          "innovation-lab",
          "innovations-promoter",
          "intelligent-meta-orchestrator",
          "internal-link-graph-runner",
          "knowledge-pack-runner",
          "license-compliance-auditor",
          "link-and-health-scheduler",
          "link-crawler",
          "maintenance-scheduler",
          "marketing-and-features-promo",
          "marketing-scheduler",
          "media-og-and-optimize",
          "metadata-optimizer-runner",
          "netlify-auto-healer-runner",
          "newsroom-auto-publisher",
          "newsroom-runner",
          "og-image-update-runner",
          "orphan-pages-detector",
          "pagespeed-insights-runner",
          "readme-advertiser",
          "repo-knowledge-graph-runner",
          "repo-radar-and-graph",
          "repo-radar-runner",
          "revenue-ideas-lab",
          "roadmap-curator",
          "robots-auditor",
          "schedule-content-index",
          "schedule-homepage",
          "schedule-knowledge-graph",
          "schedule-site-health",
          "security-audit",
          "security-audit-runner",
          "seo-audit-runner",
          "site-404-map-runner",
          "site-crawler",
          "sitemap_runner",
          "stale-content-auditor-runner",
          "todo-scanner-runner",
          "todo-summary-runner",
          "topic-cluster-builder-runner",
          "topics-map-runner",
          "trigger-all-and-commit",
          "ui-enhancer",
          "ultrafast-front-orchestrator",
          "ultrafast-orchestrator",
          "unused-media-scanner"
        ],
<<<<<<< HEAD
        healthCheckInterval: 60000,
        maxFailureThreshold: 3,
        autoDeploy: true,
        autoRegenerate: true,
        deploymentCheck: true,
        logRotation: true,
        functionValidation: true,
        backupFunctions: true
      },
      logging: {
        logDir: "automation/logs",
        maxLogSize: 20 * 1024 * 1024,
        maxLogFiles: 50,
        compression: true
      },
      monitoring: {
        enabled: true,
        interval: 15000,
        alertThreshold: 5,
        autoRestart: true,
        healthDashboard: true,
        performanceMetrics: true
      },
      backup: {
        enabled: true,
        interval: 3600000, // 1 hour
        retention: 168, // 7 days
        compression: true,
        encryption: false
=======
        healthCheckInterval: 60000, // 1 minute
        maxRetries: 3,
        retryDelay: 30000, // 30 seconds
        autoRecovery: true,
        manifestValidation: true
      },
      
      // System Configuration
      system: {
        healthCheckInterval: 60000, // 1 minute
        logRotation: true,
        maxLogSize: "100M",
        maxLogFiles: 10,
        performanceMonitoring: true,
        alertThresholds: {
          cpu: 85,
          memory: 80,
          disk: 90
        }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-ce5e
      }
    };
    
    this.status = {
      pm2: { healthy: false, processes: [], lastCheck: null },
<<<<<<< HEAD
      githubActions: { healthy: false, workflows: [], lastCheck: null },
      netlifyFunctions: { healthy: false, functions: [], lastCheck: null },
      system: { healthy: false, uptime: 0, startTime: Date.now() }
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
    this.startUltimateMonitoring();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
=======
      github: { healthy: false, workflows: [], lastCheck: null },
      netlify: { healthy: false, functions: [], lastCheck: null },
      system: { healthy: false, lastCheck: null },
      lastUpdate: new Date().toISOString()
    };
    
    this.isRunning = false;
    this.healthCheckInterval = null;
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-ce5e
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `ultimate-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 50,
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

  async checkPM2UltimateHealth() {
    this.log("🔍 Checking ultimate PM2 process health...");
    
    try {
      // Check PM2 status
      const pm2Status = await this.runCommand("pm2", ["status", "--json"]);
      if (pm2Status.status !== 0) {
        throw new Error(`PM2 status check failed: ${pm2Status.stderr}`);
      }

      const processes = JSON.parse(pm2Status.stdout);
      const healthyProcesses = [];
      const unhealthyProcesses = [];

      for (const process of processes) {
        const isHealthy = process.pm2_env && process.pm2_env.status === "online";
        if (isHealthy) {
          healthyProcesses.push(process.name);
        } else {
          unhealthyProcesses.push(process.name);
        }
      }

      // Check if all required processes are running
      const requiredProcesses = this.config.pm2.processes;
      const missingProcesses = requiredProcesses.filter(p => !healthyProcesses.includes(p));

      if (missingProcesses.length > 0) {
        this.log(`⚠️ Missing PM2 processes: ${missingProcesses.join(", ")}`, "WARN");
        
        // Auto-recovery for missing processes
        if (this.config.pm2.autoRecovery) {
          await this.recoverPM2Processes(missingProcesses);
        }
      }

      this.status.pm2 = {
        healthy: missingProcesses.length === 0,
        processes: healthyProcesses,
        lastCheck: new Date().toISOString(),
        missing: missingProcesses,
        total: healthyProcesses.length,
        required: requiredProcesses.length
      };

      this.log(`✅ PM2 Health Check: ${healthyProcesses.length}/${requiredProcesses.length} processes healthy`);
      return this.status.pm2.healthy;

    } catch (error) {
      this.log(`❌ PM2 Health Check Failed: ${error.message}`, "ERROR");
      this.status.pm2.healthy = false;
      this.status.pm2.lastCheck = new Date().toISOString();
      return false;
    }
  }

  async recoverPM2Processes(missingProcesses) {
    this.log(`🔄 Attempting to recover ${missingProcesses.length} missing PM2 processes...`);
    
    for (const processName of missingProcesses) {
      try {
        // Try to restart the process
        const restartResult = await this.runCommand("pm2", ["restart", processName]);
        if (restartResult.status === 0) {
          this.log(`✅ Successfully restarted PM2 process: ${processName}`);
        } else {
          // If restart fails, try to start it
          const startResult = await this.runCommand("pm2", ["start", processName]);
          if (startResult.status === 0) {
            this.log(`✅ Successfully started PM2 process: ${processName}`);
          } else {
            this.log(`❌ Failed to start PM2 process: ${processName}`, "ERROR");
          }
        }
      } catch (error) {
        this.log(`❌ Error recovering PM2 process ${processName}: ${error.message}`, "ERROR");
      }
    }
  }

  async checkGitHubActionsUltimateHealth() {
    this.log("🔍 Checking ultimate GitHub Actions health...");
    
    try {
      const workflows = this.config.githubActions.workflows;
      const healthyWorkflows = [];
      const unhealthyWorkflows = [];

      for (const workflow of workflows) {
        if (fs.existsSync(workflow)) {
          const content = fs.readFileSync(workflow, 'utf8');
          const isValid = this.validateWorkflow(content);
          
          if (isValid) {
            healthyWorkflows.push(workflow);
          } else {
            unhealthyWorkflows.push(workflow);
          }
        } else {
          unhealthyWorkflows.push(workflow);
        }
      }

      // Check workflow syntax and trigger configuration
      const validationResults = await this.validateAllWorkflows(workflows);
      
      this.status.githubActions = {
        healthy: unhealthyWorkflows.length === 0 && validationResults.valid,
        workflows: healthyWorkflows,
        lastCheck: new Date().toISOString(),
        invalid: unhealthyWorkflows,
        validation: validationResults,
        total: workflows.length,
        healthy: healthyWorkflows.length
      };

      this.log(`✅ GitHub Actions Health Check: ${healthyWorkflows.length}/${workflows.length} workflows healthy`);
      return this.status.githubActions.healthy;

    } catch (error) {
      this.log(`❌ GitHub Actions Health Check Failed: ${error.message}`, "ERROR");
      this.status.githubActions.healthy = false;
      this.status.githubActions.lastCheck = new Date().toISOString();
      return false;
    }
  }

  validateWorkflow(content) {
    try {
      // Basic YAML validation
      const lines = content.split('\n');
      let indentLevel = 0;
      let isValid = true;

      for (const line of lines) {
        if (line.trim() === '') continue;
        if (line.trim().startsWith('#')) continue;
        
        const currentIndent = line.search(/\S/);
        if (currentIndent === -1) continue;
        
        if (currentIndent > indentLevel + 2) {
          isValid = false;
          break;
        }
        indentLevel = currentIndent;
      }

      return isValid;
    } catch (error) {
      return false;
    }
  }

  async validateAllWorkflows(workflows) {
    const results = {
      valid: true,
      errors: [],
      warnings: []
    };

    for (const workflow of workflows) {
      try {
        if (fs.existsSync(workflow)) {
          const content = fs.readFileSync(workflow, 'utf8');
          
          // Check for required workflow components
          if (!content.includes('name:') || !content.includes('on:')) {
            results.errors.push(`${workflow}: Missing required workflow components`);
            results.valid = false;
          }
          
          // Check for proper permissions
          if (content.includes('permissions:') && !content.includes('contents: write')) {
            results.warnings.push(`${workflow}: Consider adding contents: write permission`);
          }
          
        } else {
          results.errors.push(`${workflow}: File not found`);
          results.valid = false;
        }
      } catch (error) {
        results.errors.push(`${workflow}: ${error.message}`);
        results.valid = false;
      }
    }

    return results;
  }

  async checkNetlifyFunctionsUltimateHealth() {
    this.log("🔍 Checking ultimate Netlify Functions health...");
    
    try {
      const manifestFile = this.config.netlifyFunctions.manifestFile;
      const functions = this.config.netlifyFunctions.functions;
      
      if (!fs.existsSync(manifestFile)) {
        throw new Error("Netlify functions manifest not found");
      }

      const manifest = JSON.parse(fs.readFileSync(manifestFile, 'utf8'));
      const manifestFunctions = manifest.functions || [];
      
      const healthyFunctions = [];
      const missingFunctions = [];
      const outdatedFunctions = [];

      // Check each required function
      for (const functionName of functions) {
        if (manifestFunctions.includes(functionName)) {
          healthyFunctions.push(functionName);
        } else {
          missingFunctions.push(functionName);
        }
      }

      // Check for outdated manifest
      const manifestAge = Date.now() - new Date(manifest.generatedAt).getTime();
      const isOutdated = manifestAge > 24 * 60 * 60 * 1000; // 24 hours

      if (isOutdated) {
        this.log("⚠️ Netlify functions manifest is outdated, regenerating...", "WARN");
        await this.regenerateNetlifyFunctionsManifest();
      }

      this.status.netlifyFunctions = {
        healthy: missingFunctions.length === 0 && !isOutdated,
        functions: healthyFunctions,
        lastCheck: new Date().toISOString(),
        missing: missingFunctions,
        manifestAge: manifestAge,
        isOutdated: isOutdated,
        total: functions.length,
        healthy: healthyFunctions.length
      };

      this.log(`✅ Netlify Functions Health Check: ${healthyFunctions.length}/${functions.length} functions healthy`);
      return this.status.netlifyFunctions.healthy;

    } catch (error) {
      this.log(`❌ Netlify Functions Health Check Failed: ${error.message}`, "ERROR");
      this.status.netlifyFunctions.healthy = false;
      this.status.netlifyFunctions.lastCheck = new Date().toISOString();
      return false;
    }
  }

  async regenerateNetlifyFunctionsManifest() {
    try {
      this.log("🔄 Regenerating Netlify functions manifest...");
      
      const result = await this.runCommand("node", ["scripts/generate-netlify-functions-manifest.cjs"]);
      
      if (result.status === 0) {
        this.log("✅ Successfully regenerated Netlify functions manifest");
      } else {
        this.log(`❌ Failed to regenerate manifest: ${result.stderr}`, "ERROR");
      }
    } catch (error) {
      this.log(`❌ Error regenerating manifest: ${error.message}`, "ERROR");
    }
  }

  async performBackup() {
    if (!this.config.backup.enabled) return;

    try {
      this.log("💾 Performing system backup...");
      
      const backupDir = path.join(this.config.logging.logDir, "backups", new Date().toISOString().split('T')[0]);
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      // Backup PM2 ecosystem files
      for (const ecosystemFile of this.config.pm2.ecosystemFiles) {
        if (fs.existsSync(ecosystemFile)) {
          const backupPath = path.join(backupDir, `pm2-${path.basename(ecosystemFile)}`);
          fs.copyFileSync(ecosystemFile, backupPath);
        }
      }

      // Backup GitHub Actions workflows
      for (const workflow of this.config.githubActions.workflows) {
        if (fs.existsSync(workflow)) {
          const backupPath = path.join(backupDir, `github-${path.basename(workflow)}`);
          fs.copyFileSync(workflow, backupPath);
        }
      }

      // Backup Netlify functions manifest
      if (fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        const backupPath = path.join(backupDir, "netlify-functions-manifest.json");
        fs.copyFileSync(this.config.netlifyFunctions.manifestFile, backupPath);
      }

      // Cleanup old backups
      await this.cleanupOldBackups();

      this.log("✅ System backup completed successfully");
    } catch (error) {
      this.log(`❌ Backup failed: ${error.message}`, "ERROR");
    }
  }

  async cleanupOldBackups() {
    try {
      const backupDir = path.join(this.config.logging.logDir, "backups");
      if (!fs.existsSync(backupDir)) return;

      const dirs = fs.readdirSync(backupDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name)
        .sort()
        .reverse();

      // Keep only the most recent backups within retention period
      const retentionMs = this.config.backup.retention * 60 * 60 * 1000;
      const cutoffTime = Date.now() - retentionMs;

      for (let i = this.config.backup.retention; i < dirs.length; i++) {
        const dirPath = path.join(backupDir, dirs[i]);
        try {
          fs.rmSync(dirPath, { recursive: true, force: true });
          this.log(`🗑️ Cleaned up old backup: ${dirs[i]}`);
        } catch (error) {
          this.log(`⚠️ Failed to cleanup backup ${dirs[i]}: ${error.message}`, "WARN");
        }
      }
    } catch (error) {
      this.log(`❌ Backup cleanup failed: ${error.message}`, "ERROR");
    }
  }

  async runUltimateHealthCheck() {
    this.log("🚀 Starting ultimate health check cycle...");
    
    const startTime = Date.now();
    
    // Run all health checks in parallel
    const [pm2Healthy, githubHealthy, netlifyHealthy] = await Promise.all([
      this.checkPM2UltimateHealth(),
      this.checkGitHubActionsUltimateHealth(),
      this.checkNetlifyFunctionsUltimateHealth()
    ]);

    // Update overall system health
    this.status.system.healthy = pm2Healthy && githubHealthy && netlifyHealthy;
    this.status.system.uptime = Date.now() - this.status.system.startTime;

    const duration = Date.now() - startTime;
    
    if (this.status.system.healthy) {
      this.log(`✅ Ultimate health check completed successfully in ${duration}ms`);
    } else {
      this.log(`⚠️ Ultimate health check completed with issues in ${duration}ms`, "WARN");
    }

    // Generate health report
    await this.generateHealthReport();
    
    return this.status.system.healthy;
  }

  async generateHealthReport() {
    try {
      const report = {
        timestamp: new Date().toISOString(),
        system: this.status.system,
        pm2: this.status.pm2,
        githubActions: this.status.githubActions,
        netlifyFunctions: this.status.netlifyFunctions,
        config: {
          pm2: {
            processes: this.config.pm2.processes.length,
            healthCheckInterval: this.config.pm2.healthCheckInterval
          },
          githubActions: {
            workflows: this.config.githubActions.workflows.length,
            healthCheckInterval: this.config.githubActions.healthCheckInterval
          },
          netlifyFunctions: {
            functions: this.config.netlifyFunctions.functions.length,
            healthCheckInterval: this.config.netlifyFunctions.healthCheckInterval
          }
        }
      };

      const reportFile = path.join(this.config.logging.logDir, "ultimate-health-report.json");
      fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
      
      this.log("📊 Health report generated successfully");
    } catch (error) {
      this.log(`❌ Failed to generate health report: ${error.message}`, "ERROR");
    }
  }

  initializeMonitoring() {
    this.log("🔧 Initializing ultimate redundancy monitoring...");
    
    // Set up periodic health checks
    setInterval(async () => {
      await this.runUltimateHealthCheck();
    }, this.config.monitoring.interval);

    // Set up periodic backups
    setInterval(async () => {
      await this.performBackup();
    }, this.config.backup.interval);

    this.log("✅ Ultimate redundancy monitoring initialized");
  }

  startUltimateMonitoring() {
    this.log("🚀 Starting ultimate redundancy automation system...");
    
    // Run initial health check
    this.runUltimateHealthCheck();
    
    this.log("✅ Ultimate redundancy automation system is now running");
    this.log(`📊 Health checks every ${this.config.monitoring.interval / 1000} seconds`);
    this.log(`💾 Backups every ${this.config.backup.interval / (1000 * 60 * 60)} hours`);
=======
    const logEntry = `[${timestamp}] [${level}] ${message}\n`;
    
    fs.appendFileSync(this.logFile, logEntry);
    console.log(`[${level}] ${message}`);
  }

  async start() {
    if (this.isRunning) {
      this.log("System is already running", "WARN");
      return;
    }

    this.log("Starting Ultimate Redundancy Automation System...", "INFO");
    this.isRunning = true;

    // Initialize all redundancy systems
    await this.initializePM2Redundancy();
    await this.initializeGitHubActionsRedundancy();
    await this.initializeNetlifyFunctionsRedundancy();
    
    // Start health monitoring
    this.startHealthMonitoring();
    
    // Start performance monitoring
    this.startPerformanceMonitoring();
    
    this.log("Ultimate Redundancy Automation System started successfully", "INFO");
    this.updateStatus();
  }

  async stop() {
    if (!this.isRunning) {
      this.log("System is not running", "WARN");
      return;
    }

    this.log("Stopping Ultimate Redundancy Automation System...", "INFO");
    this.isRunning = false;

    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }

    this.log("Ultimate Redundancy Automation System stopped", "INFO");
  }

  async initializePM2Redundancy() {
    this.log("Initializing PM2 Redundancy System...", "INFO");
    
    try {
      // Check if PM2 is installed
      const pm2Check = spawnSync("pm2", ["--version"], { stdio: "pipe" });
      if (pm2Check.status !== 0) {
        this.log("PM2 is not installed. Installing PM2...", "WARN");
        execSync("npm install -g pm2", { stdio: "inherit" });
      }

      // Start redundancy processes
      for (const ecosystemFile of this.config.pm2.ecosystemFiles) {
        if (fs.existsSync(ecosystemFile)) {
          try {
            execSync(`pm2 start ${ecosystemFile} --update-env`, { stdio: "inherit" });
            this.log(`Started PM2 ecosystem: ${ecosystemFile}`, "INFO");
          } catch (error) {
            this.log(`Failed to start PM2 ecosystem ${ecosystemFile}: ${error.message}`, "ERROR");
          }
        }
      }

      // Install PM2 logrotate
      try {
        execSync("pm2 install pm2-logrotate", { stdio: "inherit" });
        execSync("pm2 set pm2-logrotate:max_size 10M", { stdio: "inherit" });
        execSync("pm2 set pm2-logrotate:retain 30", { stdio: "inherit" });
        execSync("pm2 set pm2-logrotate:compress true", { stdio: "inherit" });
        execSync("pm2 set pm2-logrotate:workerInterval 60", { stdio: "inherit" });
        execSync("pm2 set pm2-logrotate:rotateInterval '0 0 * * *'", { stdio: "inherit" });
        this.log("PM2 logrotate configured successfully", "INFO");
      } catch (error) {
        this.log(`Failed to configure PM2 logrotate: ${error.message}`, "ERROR");
      }

      this.status.pm2.healthy = true;
      this.log("PM2 Redundancy System initialized successfully", "INFO");
    } catch (error) {
      this.log(`Failed to initialize PM2 Redundancy System: ${error.message}`, "ERROR");
      this.status.pm2.healthy = false;
    }
  }

  async initializeGitHubActionsRedundancy() {
    this.log("Initializing GitHub Actions Redundancy System...", "INFO");
    
    try {
      // Check if GitHub CLI is available
      const ghCheck = spawnSync("gh", ["--version"], { stdio: "pipe" });
      if (ghCheck.status !== 0) {
        this.log("GitHub CLI is not installed. Please install it manually.", "WARN");
      }

      // Validate workflow files
      for (const workflow of this.config.github.workflows) {
        const workflowFile = `.github/workflows/${workflow}.yml`;
        if (fs.existsSync(workflowFile)) {
          this.log(`GitHub workflow found: ${workflow}`, "INFO");
        } else {
          this.log(`GitHub workflow missing: ${workflow}`, "WARN");
        }
      }

      this.status.github.healthy = true;
      this.log("GitHub Actions Redundancy System initialized successfully", "INFO");
    } catch (error) {
      this.log(`Failed to initialize GitHub Actions Redundancy System: ${error.message}`, "ERROR");
      this.status.github.healthy = false;
    }
  }

  async initializeNetlifyFunctionsRedundancy() {
    this.log("Initializing Netlify Functions Redundancy System...", "INFO");
    
    try {
      // Check Netlify CLI
      const netlifyCheck = spawnSync("netlify", ["--version"], { stdio: "pipe" });
      if (netlifyCheck.status !== 0) {
        this.log("Netlify CLI is not installed. Installing...", "WARN");
        execSync("npm install -g netlify-cli", { stdio: "inherit" });
      }

      // Validate functions manifest
      const manifestPath = "netlify/functions/functions-manifest.json";
      if (fs.existsSync(manifestPath)) {
        const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
        this.log(`Netlify functions manifest found with ${manifest.functions.length} functions`, "INFO");
        
        // Validate each function
        for (const func of this.config.netlify.functions) {
          if (manifest.functions.includes(func)) {
            this.log(`Netlify function validated: ${func}`, "INFO");
          } else {
            this.log(`Netlify function missing from manifest: ${func}`, "WARN");
          }
        }
      } else {
        this.log("Netlify functions manifest not found", "WARN");
      }

      this.status.netlify.healthy = true;
      this.log("Netlify Functions Redundancy System initialized successfully", "INFO");
    } catch (error) {
      this.log(`Failed to initialize Netlify Functions Redundancy System: ${error.message}`, "ERROR");
      this.status.netlify.healthy = false;
    }
  }

  startHealthMonitoring() {
    this.log("Starting health monitoring...", "INFO");
    
    this.healthCheckInterval = setInterval(async () => {
      if (!this.isRunning) return;
      
      await this.performHealthCheck();
    }, this.config.system.healthCheckInterval);
  }

  startPerformanceMonitoring() {
    this.log("Starting performance monitoring...", "INFO");
    
    setInterval(async () => {
      if (!this.isRunning) return;
      
      await this.monitorPerformance();
    }, 300000); // Every 5 minutes
  }

  async performHealthCheck() {
    this.log("Performing health check...", "INFO");
    
    try {
      // PM2 Health Check
      await this.checkPM2Health();
      
      // GitHub Actions Health Check
      await this.checkGitHubActionsHealth();
      
      // Netlify Functions Health Check
      await this.checkNetlifyFunctionsHealth();
      
      // System Health Check
      await this.checkSystemHealth();
      
      this.updateStatus();
      this.log("Health check completed", "INFO");
    } catch (error) {
      this.log(`Health check failed: ${error.message}`, "ERROR");
    }
  }

  async checkPM2Health() {
    try {
      const pm2Status = execSync("pm2 status --json", { encoding: "utf8" });
      const status = JSON.parse(pm2Status);
      
      this.status.pm2.processes = status.map(proc => ({
        name: proc.name,
        status: proc.pm2_env.status,
        memory: proc.monit.memory,
        cpu: proc.monit.cpu,
        uptime: proc.pm2_env.pm_uptime
      }));
      
      this.status.pm2.healthy = this.status.pm2.processes.every(proc => 
        proc.status === "online" && proc.memory < this.config.pm2.memoryThreshold
      );
      
      this.status.pm2.lastCheck = new Date().toISOString();
      
      if (!this.status.pm2.healthy) {
        this.log("PM2 health check failed - attempting recovery", "WARN");
        await this.recoverPM2();
      }
    } catch (error) {
      this.log(`PM2 health check failed: ${error.message}`, "ERROR");
      this.status.pm2.healthy = false;
    }
  }

  async checkGitHubActionsHealth() {
    try {
      // Check if workflows are properly configured
      let healthyWorkflows = 0;
      
      for (const workflow of this.config.github.workflows) {
        const workflowFile = `.github/workflows/${workflow}.yml`;
        if (fs.existsSync(workflowFile)) {
          healthyWorkflows++;
        }
      }
      
      this.status.github.workflows = this.config.github.workflows.map(workflow => ({
        name: workflow,
        exists: fs.existsSync(`.github/workflows/${workflow}.yml`),
        lastRun: null // Would need GitHub API to get actual last run
      }));
      
      this.status.github.healthy = healthyWorkflows === this.config.github.workflows.length;
      this.status.github.lastCheck = new Date().toISOString();
      
      if (!this.status.github.healthy) {
        this.log("GitHub Actions health check failed", "WARN");
      }
    } catch (error) {
      this.log(`GitHub Actions health check failed: ${error.message}`, "ERROR");
      this.status.github.healthy = false;
    }
  }

  async checkNetlifyFunctionsHealth() {
    try {
      const manifestPath = "netlify/functions/functions-manifest.json";
      
      if (fs.existsSync(manifestPath)) {
        const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
        
        this.status.netlify.functions = this.config.netlify.functions.map(func => ({
          name: func,
          exists: manifest.functions.includes(func),
          lastRun: null
        }));
        
        this.status.netlify.healthy = this.status.netlify.functions.every(f => f.exists);
      } else {
        this.status.netlify.healthy = false;
      }
      
      this.status.netlify.lastCheck = new Date().toISOString();
      
      if (!this.status.netlify.healthy) {
        this.log("Netlify Functions health check failed", "WARN");
      }
    } catch (error) {
      this.log(`Netlify Functions health check failed: ${error.message}`, "ERROR");
      this.status.netlify.healthy = false;
    }
  }

  async checkSystemHealth() {
    try {
      // Check system resources
      const cpuUsage = await this.getCPUUsage();
      const memoryUsage = await this.getMemoryUsage();
      const diskUsage = await this.getDiskUsage();
      
      this.status.system.healthy = 
        cpuUsage < this.config.system.alertThresholds.cpu &&
        memoryUsage < this.config.system.alertThresholds.memory &&
        diskUsage < this.config.system.alertThresholds.disk;
      
      this.status.system.lastCheck = new Date().toISOString();
      
      if (!this.status.system.healthy) {
        this.log(`System health check failed - CPU: ${cpuUsage}%, Memory: ${memoryUsage}%, Disk: ${diskUsage}%`, "WARN");
      }
    } catch (error) {
      this.log(`System health check failed: ${error.message}`, "ERROR");
      this.status.system.healthy = false;
    }
  }

  async getCPUUsage() {
    try {
      const topOutput = execSync("top -bn1 | grep 'Cpu(s)' | awk '{print $2}' | cut -d'%' -f1", { encoding: "utf8" });
      return parseFloat(topOutput.trim());
    } catch {
      return 0;
    }
  }

  async getMemoryUsage() {
    try {
      const freeOutput = execSync("free | grep Mem | awk '{printf \"%.1f\", $3/$2 * 100.0}'", { encoding: "utf8" });
      return parseFloat(freeOutput.trim());
    } catch {
      return 0;
    }
  }

  async getDiskUsage() {
    try {
      const dfOutput = execSync("df / | tail -1 | awk '{print $5}' | cut -d'%' -f1", { encoding: "utf8" });
      return parseFloat(dfOutput.trim());
    } catch {
      return 0;
    }
  }

  async monitorPerformance() {
    try {
      const cpuUsage = await this.getCPUUsage();
      const memoryUsage = await this.getMemoryUsage();
      const diskUsage = await this.getDiskUsage();
      
      if (cpuUsage > this.config.system.alertThresholds.cpu ||
          memoryUsage > this.config.system.alertThresholds.memory ||
          diskUsage > this.config.system.alertThresholds.disk) {
        
        this.log(`Performance alert - CPU: ${cpuUsage}%, Memory: ${memoryUsage}%, Disk: ${diskUsage}%`, "WARN");
        
        // Take corrective actions
        if (cpuUsage > 90) {
          this.log("High CPU usage detected - optimizing processes", "WARN");
          await this.optimizeProcesses();
        }
        
        if (memoryUsage > 85) {
          this.log("High memory usage detected - cleaning up", "WARN");
          await this.cleanupMemory();
        }
      }
    } catch (error) {
      this.log(`Performance monitoring failed: ${error.message}`, "ERROR");
    }
  }

  async recoverPM2() {
    if (!this.config.pm2.autoRecovery) return;
    
    this.log("Attempting PM2 recovery...", "INFO");
    
    try {
      // Restart failed processes
      execSync("pm2 restart all", { stdio: "inherit" });
      this.log("PM2 recovery completed", "INFO");
    } catch (error) {
      this.log(`PM2 recovery failed: ${error.message}`, "ERROR");
    }
  }

  async optimizeProcesses() {
    this.log("Optimizing processes...", "INFO");
    
    try {
      // Restart PM2 processes to free up resources
      execSync("pm2 restart all", { stdio: "inherit" });
      this.log("Process optimization completed", "INFO");
    } catch (error) {
      this.log(`Process optimization failed: ${error.message}`, "ERROR");
    }
  }

  async cleanupMemory() {
    this.log("Cleaning up memory...", "INFO");
    
    try {
      // Force garbage collection if possible
      if (global.gc) {
        global.gc();
        this.log("Garbage collection completed", "INFO");
      }
      
      // Clear PM2 logs if they're too large
      execSync("pm2 flush", { stdio: "inherit" });
      this.log("Memory cleanup completed", "INFO");
    } catch (error) {
      this.log(`Memory cleanup failed: ${error.message}`, "ERROR");
    }
  }

  updateStatus() {
    this.status.lastUpdate = new Date().toISOString();
    
    try {
      fs.writeFileSync(this.statusFile, JSON.stringify(this.status, null, 2));
    } catch (error) {
      this.log(`Failed to update status file: ${error.message}`, "ERROR");
    }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-ce5e
  }

  getStatus() {
    return this.status;
  }

<<<<<<< HEAD
  async stop() {
    this.log("🛑 Stopping ultimate redundancy automation system...");
    // Cleanup and stop monitoring
    process.exit(0);
  }
}

// Handle process signals
process.on('SIGINT', async () => {
  console.log('\n🛑 Received SIGINT, shutting down gracefully...');
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\n🛑 Received SIGTERM, shutting down gracefully...');
  process.exit(0);
});

// Export for use as module
if (require.main === module) {
  const system = new UltimateRedundancyAutomationSystem();
  
  // Keep the process running
  setInterval(() => {
    // Keep alive
  }, 60000);
=======
  async runCommand(command, args = []) {
    return new Promise((resolve, reject) => {
      const child = spawn(command, args, { stdio: "pipe" });
      let stdout = "";
      let stderr = "";
      
      child.stdout.on("data", (data) => {
        stdout += data.toString();
      });
      
      child.stderr.on("data", (data) => {
        stderr += data.toString();
      });
      
      child.on("close", (code) => {
        if (code === 0) {
          resolve(stdout);
        } else {
          reject(new Error(`Command failed with code ${code}: ${stderr}`));
        }
      });
      
      child.on("error", (error) => {
        reject(error);
      });
    });
  }
}

// CLI Interface
if (require.main === module) {
  const system = new UltimateRedundancyAutomationSystem();
  const command = process.argv[2];
  
  switch (command) {
    case "start":
      system.start().catch(console.error);
      break;
    case "stop":
      system.stop().catch(console.error);
      break;
    case "status":
      console.log(JSON.stringify(system.getStatus(), null, 2));
      break;
    case "health":
      system.performHealthCheck().catch(console.error);
      break;
    default:
      console.log("Usage: node ultimate-redundancy-automation-system.cjs [start|stop|status|health]");
      process.exit(1);
  }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-ce5e
}

module.exports = UltimateRedundancyAutomationSystem;