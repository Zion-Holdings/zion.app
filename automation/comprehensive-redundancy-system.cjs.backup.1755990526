#!/usr/bin/env node
<<<<<<< HEAD

/**
 * Comprehensive Redundancy System
 * Provides complete backup automation for all systems:
 * - PM2 automations
 * - GitHub Actions automations  
 * - Netlify functions automations
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
=======
"use strict";

const { spawnSync, execSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-1200

class ComprehensiveRedundancySystem {
  constructor() {
    this.config = {
      pm2: {
        ecosystemFiles: [
<<<<<<< HEAD
          'ecosystem.pm2.cjs',
          'ecosystem-redundancy.pm2.cjs',
          'ecosystem.redundancy.cjs'
        ],
        processes: [
          'zion-auto-sync',
          'zion-auto-sync-cron',
          'zion-auto-sync-backup',
          'zion-auto-sync-cron-backup',
          'redundancy-master-orchestrator',
          'redundancy-pm2-manager',
          'redundancy-github-manager',
          'redundancy-netlify-manager',
          'build-monitor-backup',
          'git-sync-backup',
          'netlify-healer-backup'
        ]
      },
      github: {
        workflows: [
          'marketing-sync.yml',
          'sync-health.yml',
          'marketing-sync-backup.yml',
          'sync-health-backup.yml'
        ],
        schedules: {
          'marketing-sync': '0 */12 * * *',
          'sync-health': '*/15 * * * *',
          'marketing-sync-backup': '30 */12 * * *',
          'sync-health-backup': '*/20 * * * *'
        }
      },
      netlify: {
        functions: [
          'a11y-alt-text-runner',
          'adaptive-orchestrator',
          'ai-changelog-runner',
          'ai-trends-radar-runner',
          'anchor-links-auto-fixer',
          'auto-discovery-runner',
          'auto-scheduler',
          'automation-matrix',
          'autonomous-invention-orchestrator',
          'autonomous-meta-orchestrator',
          'broken-image-scanner',
          'broken-image-scanner-runner',
          'canonical-auditor',
          'cloud_deep_research',
          'cloud_orchestrator',
          'code-smell-audit-runner',
          'component-coupling-graph-runner',
          'component-props-docs-runner',
          'component-size-report',
          'content-freshness-score-runner',
          'continuous-front-runner',
          'continuous-orchestrator',
          'dead-code-audit',
          'dead-code-report',
          'deps-auto-upgrade-runner',
          'docs-index-runner',
          'docs-search-index-runner',
          'duplicate-media-finder-runner',
          'external-link-check-runner',
          'fast-front-promoter',
          'fast-orchestrator',
          'feature-advertiser',
          'features-capabilities-benefits-advertiser',
          'front-ads-promoter',
          'front-enhancer',
          'front-index-futurizer',
          'front-index-orchestrator',
          'front-index-scheduler',
          'front-maximizer',
          'front-visionary-expander',
          'frontpage-enhancer',
          'frontpage-scheduler',
          'headers-enforcer',
          'home-visionary-expander',
          'homepage-advertiser-scheduler',
          'homepage-enhancer',
          'homepage-updater',
          'homepage-updater-scheduler',
          'homepage_advertiser',
          'hyper-front-index-accelerator',
          'image-optimizer-runner',
          'innovation-lab',
          'innovations-promoter',
          'intelligent-meta-orchestrator',
          'internal-link-graph-runner',
          'knowledge-pack-runner',
          'license-compliance-auditor',
          'link-and-health-scheduler',
          'link-crawler',
          'maintenance-scheduler',
          'marketing-and-features-promo',
          'marketing-scheduler',
          'media-og-and-optimize',
          'metadata-optimizer-runner',
          'netlify-auto-healer-runner',
          'newsroom-auto-publisher',
          'newsroom-runner',
          'og-image-update-runner',
          'orphan-pages-detector',
          'pagespeed-insights-runner',
          'readme-advertiser',
          'repo-knowledge-graph-runner',
          'repo-radar-and-graph',
          'repo-radar-runner',
          'revenue-ideas-lab',
          'roadmap-curator',
          'robots-auditor',
          'schedule-content-index',
          'schedule-homepage',
          'schedule-knowledge-graph',
          'schedule-site-health',
          'security-audit',
          'security-audit-runner',
          'seo-audit-runner',
          'site-404-map-runner',
          'site-crawler',
          'sitemap_runner',
          'stale-content-auditor-runner',
          'todo-scanner-runner',
          'todo-summary-runner',
          'topic-cluster-builder-runner',
          'topics-map-runner',
          'trigger-all-and-commit',
          'ui-enhancer',
          'ultrafast-front-orchestrator',
          'ultrafast-orchestrator',
          'unused-media-scanner'
        ]
      }
    };
    
    this.status = {
      pm2: { running: false, processes: [] },
      github: { workflows: [], lastRun: null },
      netlify: { functions: [], lastDeploy: null }
    };
  }

  async start() {
    console.log('🚀 Starting Comprehensive Redundancy System...');
    
    try {
      // Start PM2 redundancy
      await this.startPM2Redundancy();
      
      // Start GitHub Actions redundancy
      await this.startGitHubActionsRedundancy();
      
      // Start Netlify Functions redundancy
      await this.startNetlifyFunctionsRedundancy();
      
      // Start monitoring
      this.startMonitoring();
      
      console.log('✅ Comprehensive Redundancy System started successfully');
    } catch (error) {
      console.error('❌ Failed to start Comprehensive Redundancy System:', error);
      throw error;
    }
  }

  async startPM2Redundancy() {
    console.log('📱 Starting PM2 Redundancy...');
    
    try {
      // Ensure logs directory exists
      execSync('mkdir -p automation/logs', { stdio: 'inherit' });
      
      // Start redundancy ecosystem
      execSync('pm2 start ecosystem-redundancy.pm2.cjs --update-env', { stdio: 'inherit' });
      
      // Wait for processes to start
      await this.sleep(3000);
      
      // Verify processes are running
      const status = execSync('pm2 status --no-daemon', { encoding: 'utf8' });
      this.status.pm2.running = true;
      this.status.pm2.processes = this.parsePM2Status(status);
      
      console.log(`✅ PM2 Redundancy started with ${this.status.pm2.processes.length} processes`);
    } catch (error) {
      console.error('❌ Failed to start PM2 Redundancy:', error);
      throw error;
    }
  }

  async startGitHubActionsRedundancy() {
    console.log('🐙 Starting GitHub Actions Redundancy...');
    
    try {
      // Create backup workflows with different schedules
      await this.createGitHubActionsBackups();
      
      // Verify workflows exist
      this.status.github.workflows = await this.getGitHubWorkflows();
      
      console.log(`✅ GitHub Actions Redundancy configured with ${this.status.github.workflows.length} workflows`);
    } catch (error) {
      console.error('❌ Failed to start GitHub Actions Redundancy:', error);
      throw error;
    }
  }

  async startNetlifyFunctionsRedundancy() {
    console.log('☁️ Starting Netlify Functions Redundancy...');
    
    try {
      // Create backup function runners
      await this.createNetlifyFunctionsBackups();
      
      // Verify functions exist
      this.status.netlify.functions = await this.getNetlifyFunctions();
      
      console.log(`✅ Netlify Functions Redundancy configured with ${this.status.netlify.functions.length} functions`);
    } catch (error) {
      console.error('❌ Failed to start Netlify Functions Redundancy:', error);
      throw error;
    }
  }

  async createGitHubActionsBackups() {
    const workflowsDir = '.github/workflows';
    
    // Create backup workflows with different schedules
    const backupWorkflows = [
      {
        name: 'marketing-sync-backup.yml',
        schedule: '30 */12 * * *', // 30 minutes offset from primary
        jobName: 'run-marketing-sync-backup'
      },
      {
        name: 'sync-health-backup.yml',
        schedule: '*/20 * * * *', // Every 20 minutes instead of 15
        jobName: 'check-sync-backup'
      }
    ];

    for (const workflow of backupWorkflows) {
      const workflowPath = path.join(workflowsDir, workflow.name);
      if (!fs.existsSync(workflowPath)) {
        await this.createBackupWorkflow(workflow);
      }
    }
  }

  async createBackupWorkflow(workflow) {
    const template = this.getWorkflowTemplate(workflow);
    const workflowPath = path.join('.github/workflows', workflow.name);
    
    fs.writeFileSync(workflowPath, template);
    console.log(`📝 Created backup workflow: ${workflow.name}`);
  }

  getWorkflowTemplate(workflow) {
    if (workflow.name.includes('marketing-sync')) {
      return `name: Marketing Sync Backup

on:
  schedule:
    - cron: '${workflow.schedule}'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  ${workflow.jobName}:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run marketing-sync backup
        env:
          LINKEDIN_ACCESS_TOKEN: \${{ secrets.LINKEDIN_ACCESS_TOKEN }}
          LINKEDIN_URN: \${{ secrets.LINKEDIN_URN }}
          IG_USER_ID: \${{ secrets.IG_USER_ID }}
          IG_ACCESS_TOKEN: \${{ secrets.IG_ACCESS_TOKEN }}
        run: node automation/marketing-sync.js

      - name: Commit report if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [ -n "\$(git status --porcelain)" ]; then
            git add -A
            git commit -m "chore(marketing): update marketing-sync backup report"
            git push origin HEAD:main
          else
            echo "No changes to commit."
          fi`;
    } else {
      return `name: Sync Health Backup

on:
  schedule:
    - cron: '${workflow.schedule}'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  ${workflow.jobName}:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run pm2-auto-sync backup (safe mode)
        env:
          AUTO_SYNC_STRATEGY: hardreset
          AUTO_SYNC_CLEAN: '0'
        run: node automation/pm2-auto-sync.js || true

      - name: Push if repository is ahead
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          # Only push if we have local commits not on origin
          AHEAD=\$(git rev-list --left-right --count HEAD...origin/main | awk '{print \$1}')
          if [ "\$AHEAD" != "0" ]; then
            git push origin HEAD:main
          else
            echo "No push needed."
          fi`;
Timestamp: ${results.timestamp}
Overall Status: ${overallHealth}

🔧 PM2 Processes: ${status.pm2}
🔄 GitHub Actions: ${status.githubActions}
☁️ Netlify Functions: ${status.netlifyFunctions}

${results.pm2 && results.githubActions && results.netlifyFunctions ? 
  "🎉 All automation systems are operating normally!" : 
  "⚠️ Some automation systems require attention. Check logs for details."}
`;
  }

  saveHealthReport(results) {
    try {
      const reportPath = path.join(this.config.logging.logDir, `health-report-${new Date().toISOString().split('T')[0]}.json`);
      const reportData = {
        ...results,
        summary: {
          totalSystems: 3,
          healthySystems: Object.values(results).filter(Boolean).length,
          unhealthySystems: Object.values(results).filter(Boolean).length - 3
        }
      };
      
      fs.writeFileSync(reportPath, JSON.stringify(reportData, null, 2));
      this.log(`📝 Health report saved to ${reportPath}`);
    } catch (error) {
      this.log(`❌ Failed to save health report: ${error.message}`, "ERROR");
    }
  }

  async startComprehensiveMonitoring() {
    this.log("🚀 Starting comprehensive monitoring system...");
    
    // Initial health check
    await this.performComprehensiveHealthCheck();
    
    // Set up periodic monitoring
    setInterval(async () => {
      await this.performComprehensiveHealthCheck();
    }, 5 * 60 * 1000); // Every 5 minutes

    // Set up PM2 monitoring
    setInterval(async () => {
      await this.checkPM2ComprehensiveHealth();
    }, this.config.pm2.healthCheckInterval);

    // Set up GitHub Actions monitoring
    setInterval(async () => {
      await this.checkGitHubActionsComprehensive();
    }, this.config.githubActions.healthCheckInterval);

    // Set up Netlify functions monitoring
    setInterval(async () => {
      await this.checkNetlifyFunctionsComprehensive();
    }, this.config.netlifyFunctions.healthCheckInterval);

    this.log("✅ Comprehensive monitoring system started successfully");
  }

  initializeMonitoring() {
    this.log("🔧 Initializing comprehensive redundancy monitoring...");
    
    // Ensure all required directories exist
    const requiredDirs = [
      this.config.logging.logDir,
      ".github/workflows",
      "netlify/functions"
    ];

    requiredDirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        this.log(`📁 Created directory: ${dir}`);
      }
    });
  }
}

// Start the comprehensive redundancy system
if (require.main === module) {
  const redundancySystem = new ComprehensiveRedundancySystem();
  
  // Handle graceful shutdown
  process.on('SIGINT', () => {
    console.log('\n🛑 Shutting down comprehensive redundancy system...');
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    console.log('\n🛑 Terminating comprehensive redundancy system...');
    process.exit(0);
  });
=======
    }
  }

  async createNetlifyFunctionsBackups() {
    const functionsDir = 'netlify/functions';
    
    // Create backup function runners for critical functions
    const criticalFunctions = [
      'netlify-auto-healer-runner',
      'continuous-orchestrator',
      'build-monitor-runner',
      'git-sync-runner'
    ];

    for (const funcName of criticalFunctions) {
      const backupName = `${funcName}-backup`;
      const backupPath = path.join(functionsDir, backupName);
      
      if (!fs.existsSync(backupPath)) {
        await this.createBackupFunction(funcName, backupName);
      }
    }
  }

  async createBackupFunction(originalName, backupName) {
    const backupDir = path.join('netlify/functions', backupName);
    const backupFile = path.join(backupDir, 'index.js');
    
    // Create directory
    fs.mkdirSync(backupDir, { recursive: true });
    
    // Create backup function
    const backupCode = `// Backup function for ${originalName}
const { execSync } = require('child_process');
const path = require('path');

exports.handler = async (event, context) => {
  try {
    console.log('Backup function ${backupName} triggered');
    
    // Execute the original function logic
    const result = await executeBackupLogic();
    
    return {
      statusCode: 200,
      body: JSON.stringify({
        message: 'Backup function executed successfully',
        originalFunction: '${originalName}',
        backupFunction: '${backupName}',
        result: result
      })
    };
  } catch (error) {
    console.error('Backup function error:', error);
    
    return {
      statusCode: 500,
      body: JSON.stringify({
        message: 'Backup function failed',
        originalFunction: '${originalName}',
        backupFunction: '${backupName}',
        error: error.message
      })
    };
  }
};

async function executeBackupLogic() {
  // Implement backup logic here
  // This could involve calling the original function or implementing alternative logic
  return { status: 'backup_executed', timestamp: new Date().toISOString() };
}`;
    
    fs.writeFileSync(backupFile, backupCode);
    console.log(`📝 Created backup function: ${backupName}`);
  }

  async getGitHubWorkflows() {
    try {
      const workflowsDir = '.github/workflows';
      if (!fs.existsSync(workflowsDir)) return [];
      
      const files = fs.readdirSync(workflowsDir);
      return files.filter(file => file.endsWith('.yml') || file.endsWith('.yaml'));
    } catch (error) {
      console.error('Error getting GitHub workflows:', error);
      return [];
    }
  }

  async getNetlifyFunctions() {
    try {
      const functionsDir = 'netlify/functions';
      if (!fs.existsSync(functionsDir)) return [];
      
      const items = fs.readdirSync(functionsDir);
      return items.filter(item => {
        const itemPath = path.join(functionsDir, item);
        return fs.statSync(itemPath).isDirectory();
      });
    } catch (error) {
      console.error('Error getting Netlify functions:', error);
      return [];
    }
  }

  parsePM2Status(statusOutput) {
    const lines = statusOutput.split('\n');
    const processes = [];
    
    for (const line of lines) {
      if (line.includes('│') && !line.includes('App name')) {
        const parts = line.split('│').map(p => p.trim()).filter(p => p);
        if (parts.length >= 4) {
          processes.push({
            name: parts[0],
            status: parts[1],
            cpu: parts[2],
            memory: parts[3]
          });
        }
      }
    }
    
    return processes;
  }

  startMonitoring() {
    console.log('📊 Starting monitoring...');
    
    // Monitor every 30 seconds
    setInterval(() => {
      this.checkSystemHealth();
    }, 30000);
  }

  async checkSystemHealth() {
    try {
      // Check PM2 status
      const pm2Status = execSync('pm2 status --no-daemon', { encoding: 'utf8' });
      this.status.pm2.processes = this.parsePM2Status(pm2Status);
      
      // Check GitHub workflows
      this.status.github.workflows = await this.getGitHubWorkflows();
      
      // Check Netlify functions
      this.status.netlify.functions = await this.getNetlifyFunctions();
      
      // Log status
      console.log(`📊 System Health - PM2: ${this.status.pm2.processes.length} processes, GitHub: ${this.status.github.workflows.length} workflows, Netlify: ${this.status.netlify.functions.length} functions`);
      
      // Check for failures and restart if needed
      await this.handleFailures();
    } catch (error) {
      console.error('Health check error:', error);
    }
  }

  async handleFailures() {
    // Check PM2 processes and restart failed ones
    const failedProcesses = this.status.pm2.processes.filter(p => p.status === 'errored' || p.status === 'stopped');
    
    for (const process of failedProcesses) {
      console.log(`🔄 Restarting failed process: ${process.name}`);
      try {
        execSync(`pm2 restart ${process.name}`, { stdio: 'inherit' });
      } catch (error) {
        console.error(`Failed to restart ${process.name}:`, error);
      }
    }
  }

  async stop() {
    console.log('🛑 Stopping Comprehensive Redundancy System...');
    
    try {
      // Stop PM2 processes
      execSync('pm2 stop ecosystem-redundancy.pm2.cjs', { stdio: 'inherit' });
      
      console.log('✅ Comprehensive Redundancy System stopped');
    } catch (error) {
      console.error('❌ Error stopping system:', error);
    }
  }

  getStatus() {
    return this.status;
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
=======
          "ecosystem.pm2.cjs",
          "ecosystem.redundancy.cjs",
          "ecosystem-redundancy.pm2.cjs"
        ],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor"
        ],
        healthCheckInterval: 30000, // 30 seconds
        maxRestartAttempts: 5,
        restartDelay: 5000 // 5 seconds
      },
      githubActions: {
        workflows: [
          ".github/workflows/marketing-sync.yml",
          ".github/workflows/sync-health.yml",
          ".github/workflows/marketing-sync-backup.yml",
          ".github/workflows/sync-health-backup.yml"
        ],
        healthCheckInterval: 60000, // 1 minute
        maxFailureThreshold: 3,
        backupWorkflows: [
          ".github/workflows/marketing-sync-backup.yml",
          ".github/workflows/sync-health-backup.yml"
        ]
      },
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        healthCheckInterval: 120000, // 2 minutes
        maxFailureThreshold: 2,
        criticalFunctions: [
          "netlify-auto-healer-runner",
          "maintenance-scheduler",
          "site-crawler",
          "security-audit-runner"
        ]
      },
      npmScripts: {
        critical: [
          "build",
          "build:health-check",
          "build:validate",
          "build:recovery",
          "lint",
          "type-check"
        ],
        automation: [
          "automation:all",
          "redundancy:start",
          "redundancy:health",
          "redundancy:pm2",
          "redundancy:github",
          "redundancy:netlify"
        ]
      },
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024, // 10MB
        maxLogFiles: 30
      },
      monitoring: {
        overallHealthCheckInterval: 60000, // 1 minute
        alertThreshold: 3,
        recoveryTimeout: 300000 // 5 minutes
      }
    };
    
    this.healthStatus = {
      pm2: { healthy: true, lastCheck: null, failures: 0 },
      githubActions: { healthy: true, lastCheck: null, failures: 0 },
      netlifyFunctions: { healthy: true, lastCheck: null, failures: 0 },
      npmScripts: { healthy: true, lastCheck: null, failures: 0 },
      overall: { healthy: true, lastCheck: null, failures: 0 }
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `comprehensive-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

  async checkPM2Health() {
    this.log("Checking PM2 process health...");
    
    try {
      const statusResult = await this.runCommand("pm2", ["status", "--no-daemon"]);
      
      if (statusResult.status !== 0) {
        this.log("PM2 status check failed, attempting to restart PM2", "WARN");
        await this.runCommand("pm2", ["kill"]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFiles[0]]);
        this.healthStatus.pm2.healthy = false;
        this.healthStatus.pm2.failures++;
        return false;
      }

      const processes = this.config.pm2.processes;
      let allHealthy = true;

      for (const processName of processes) {
        const processStatus = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
        
        if (processStatus.status !== 0) {
          this.log(`PM2 process ${processName} not found, restarting...`, "WARN");
          await this.runCommand("pm2", ["restart", processName]);
          allHealthy = false;
        }
      }

      // Check if any ecosystem files need to be started
      for (const ecosystemFile of this.config.pm2.ecosystemFiles) {
        if (fs.existsSync(ecosystemFile)) {
          const startResult = await this.runCommand("pm2", ["start", ecosystemFile, "--update-env"]);
          if (startResult.status === 0) {
            this.log(`Started PM2 ecosystem: ${ecosystemFile}`);
          }
        }
      }

      this.healthStatus.pm2.healthy = allHealthy;
      this.healthStatus.pm2.lastCheck = new Date();
      if (allHealthy) {
        this.healthStatus.pm2.failures = 0;
      }
      
      return allHealthy;
    } catch (error) {
      this.log(`PM2 health check error: ${error.message}`, "ERROR");
      this.healthStatus.pm2.healthy = false;
      this.healthStatus.pm2.failures++;
      return false;
    }
  }

  async checkGitHubActionsHealth() {
    this.log("Checking GitHub Actions workflows...");
    
    try {
      let allHealthy = true;
      
      // Check if workflow files exist and are valid
      for (const workflow of this.config.githubActions.workflows) {
        if (!fs.existsSync(workflow)) {
          this.log(`GitHub Actions workflow not found: ${workflow}`, "WARN");
          allHealthy = false;
        } else {
          // Validate YAML syntax (basic check)
          try {
            const content = fs.readFileSync(workflow, 'utf8');
            if (!content.includes('name:') || !content.includes('on:')) {
              this.log(`Invalid GitHub Actions workflow: ${workflow}`, "WARN");
              allHealthy = false;
            }
          } catch (error) {
            this.log(`Error reading GitHub Actions workflow: ${workflow}`, "ERROR");
            allHealthy = false;
          }
        }
      }

      // Check if backup workflows exist
      for (const backupWorkflow of this.config.githubActions.backupWorkflows) {
        if (!fs.existsSync(backupWorkflow)) {
          this.log(`Backup workflow not found: ${backupWorkflow}`, "WARN");
          allHealthy = false;
        }
      }

      this.healthStatus.githubActions.healthy = allHealthy;
      this.healthStatus.githubActions.lastCheck = new Date();
      if (allHealthy) {
        this.healthStatus.githubActions.failures = 0;
      }
      
      return allHealthy;
    } catch (error) {
      this.log(`GitHub Actions health check error: ${error.message}`, "ERROR");
      this.healthStatus.githubActions.healthy = false;
      this.healthStatus.githubActions.failures++;
      return false;
    }
  }

  async checkNetlifyFunctionsHealth() {
    this.log("Checking Netlify functions...");
    
    try {
      let allHealthy = true;
      
      if (!fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        this.log("Netlify functions manifest not found", "WARN");
        allHealthy = false;
      } else {
        try {
          const manifest = JSON.parse(fs.readFileSync(this.config.netlifyFunctions.manifestFile, 'utf8'));
          
          if (!manifest.functions || !Array.isArray(manifest.functions)) {
            this.log("Invalid Netlify functions manifest", "WARN");
            allHealthy = false;
          } else {
            // Check if critical functions exist
            for (const criticalFunction of this.config.netlifyFunctions.criticalFunctions) {
              if (!manifest.functions.includes(criticalFunction)) {
                this.log(`Critical Netlify function not found: ${criticalFunction}`, "WARN");
                allHealthy = false;
              }
            }
            
            this.log(`Found ${manifest.functions.length} Netlify functions`);
          }
        } catch (error) {
          this.log(`Error parsing Netlify functions manifest: ${error.message}`, "ERROR");
          allHealthy = false;
        }
      }

      this.healthStatus.netlifyFunctions.healthy = allHealthy;
      this.healthStatus.netlifyFunctions.lastCheck = new Date();
      if (allHealthy) {
        this.healthStatus.netlifyFunctions.failures = 0;
      }
      
      return allHealthy;
    } catch (error) {
      this.log(`Netlify functions health check error: ${error.message}`, "ERROR");
      this.healthStatus.netlifyFunctions.healthy = false;
      this.healthStatus.netlifyFunctions.failures++;
      return false;
    }
  }

  async checkNPMScriptsHealth() {
    this.log("Checking NPM scripts availability...");
    
    try {
      let allHealthy = true;
      
      // Check if package.json exists and has required scripts
      if (!fs.existsSync('package.json')) {
        this.log("package.json not found", "ERROR");
        allHealthy = false;
      } else {
        try {
          const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          
          for (const criticalScript of this.config.npmScripts.critical) {
            if (!packageJson.scripts || !packageJson.scripts[criticalScript]) {
              this.log(`Critical NPM script not found: ${criticalScript}`, "WARN");
              allHealthy = false;
            }
          }
          
          for (const automationScript of this.config.npmScripts.automation) {
            if (!packageJson.scripts || !packageJson.scripts[automationScript]) {
              this.log(`Automation NPM script not found: ${automationScript}`, "WARN");
              allHealthy = false;
            }
          }
        } catch (error) {
          this.log(`Error parsing package.json: ${error.message}`, "ERROR");
          allHealthy = false;
        }
      }

      this.healthStatus.npmScripts.healthy = allHealthy;
      this.healthStatus.npmScripts.lastCheck = new Date();
      if (allHealthy) {
        this.healthStatus.npmScripts.failures = 0;
      }
      
      return allHealthy;
    } catch (error) {
      this.log(`NPM scripts health check error: ${error.message}`, "ERROR");
      this.healthStatus.npmScripts.healthy = false;
      this.healthStatus.npmScripts.failures++;
      return false;
    }
  }

  async performRecovery() {
    this.log("Performing comprehensive recovery...");
    
    try {
      // PM2 Recovery
      if (!this.healthStatus.pm2.healthy) {
        this.log("Recovering PM2 processes...");
        await this.runCommand("pm2", ["kill"]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFiles[0]]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFiles[1]]);
        await this.runCommand("pm2", ["save"]);
      }

      // GitHub Actions Recovery
      if (!this.healthStatus.githubActions.healthy) {
        this.log("Recovering GitHub Actions workflows...");
        // Trigger backup workflows if main ones are broken
        for (const backupWorkflow of this.config.githubActions.backupWorkflows) {
          if (fs.existsSync(backupWorkflow)) {
            this.log(`Triggering backup workflow: ${backupWorkflow}`);
            // This would typically involve GitHub API calls
          }
        }
      }

      // Netlify Functions Recovery
      if (!this.healthStatus.netlifyFunctions.healthy) {
        this.log("Recovering Netlify functions...");
        await this.runCommand("npm", ["run", "netlify:manifest"]);
      }

      // NPM Scripts Recovery
      if (!this.healthStatus.npmScripts.healthy) {
        this.log("Recovering NPM scripts...");
        await this.runCommand("npm", ["install"]);
      }

      this.log("Recovery completed");
      return true;
    } catch (error) {
      this.log(`Recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async runComprehensiveHealthCheck() {
    this.log("Running comprehensive health check...");
    
    const pm2Health = await this.checkPM2Health();
    const githubHealth = await this.checkGitHubActionsHealth();
    const netlifyHealth = await this.checkNetlifyFunctionsHealth();
    const npmHealth = await this.checkNPMScriptsHealth();
    
    const overallHealth = pm2Health && githubHealth && netlifyHealth && npmHealth;
    
    this.healthStatus.overall.healthy = overallHealth;
    this.healthStatus.overall.lastCheck = new Date();
    
    if (!overallHealth) {
      this.healthStatus.overall.failures++;
      this.log("Overall health check failed, initiating recovery...", "WARN");
      
      if (this.healthStatus.overall.failures >= this.config.monitoring.alertThreshold) {
        this.log("Alert threshold reached, performing recovery", "ERROR");
        await this.performRecovery();
      }
    } else {
      this.healthStatus.overall.failures = 0;
    }
    
    this.log(`Health check completed. Overall: ${overallHealth ? 'HEALTHY' : 'UNHEALTHY'}`);
    return overallHealth;
  }

  getStatus() {
    return {
      timestamp: new Date().toISOString(),
      overall: this.healthStatus.overall,
      components: {
        pm2: this.healthStatus.pm2,
        githubActions: this.healthStatus.githubActions,
        netlifyFunctions: this.healthStatus.netlifyFunctions,
        npmScripts: this.healthStatus.npmScripts
      },
      config: this.config
    };
  }

  async startMonitoring() {
    this.log("Starting comprehensive redundancy monitoring...");
    
    // Initial health check
    await this.runComprehensiveHealthCheck();
    
    // Set up monitoring intervals
    setInterval(async () => {
      await this.runComprehensiveHealthCheck();
    }, this.config.monitoring.overallHealthCheckInterval);
    
    // PM2 monitoring
    setInterval(async () => {
      await this.checkPM2Health();
    }, this.config.pm2.healthCheckInterval);
    
    // GitHub Actions monitoring
    setInterval(async () => {
      await this.checkGitHubActionsHealth();
    }, this.config.githubActions.healthCheckInterval);
    
    // Netlify Functions monitoring
    setInterval(async () => {
      await this.checkNetlifyFunctionsHealth();
    }, this.config.netlifyFunctions.healthCheckInterval);
    
    this.log("Comprehensive redundancy monitoring started");
  }

  async stopMonitoring() {
    this.log("Stopping comprehensive redundancy monitoring...");
    // Clear all intervals
    process.exit(0);
  }

  initializeMonitoring() {
    // Handle graceful shutdown
    process.on('SIGINT', async () => {
      this.log("Received SIGINT, shutting down gracefully...");
      await this.stopMonitoring();
    });
    
    process.on('SIGTERM', async () => {
      this.log("Received SIGTERM, shutting down gracefully...");
      await this.stopMonitoring();
    });
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-1200
  }
}

// CLI interface
if (require.main === module) {
  const system = new ComprehensiveRedundancySystem();
<<<<<<< HEAD
=======
  
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-1200
  const command = process.argv[2] || 'start';
  
  switch (command) {
    case 'start':
<<<<<<< HEAD
      system.start();
      break;
    case 'stop':
      system.stop();
=======
      system.startMonitoring();
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-1200
      break;
    case 'status':
      console.log(JSON.stringify(system.getStatus(), null, 2));
      break;
<<<<<<< HEAD
    default:
      console.log('Usage: node comprehensive-redundancy-system.cjs [start|stop|status]');
=======
    case 'health':
      system.runComprehensiveHealthCheck();
      break;
    case 'recover':
      system.performRecovery();
      break;
    default:
      console.log('Usage: node comprehensive-redundancy-system.cjs [start|status|health|recover]');
      process.exit(1);
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-1200
  }
}

module.exports = ComprehensiveRedundancySystem;