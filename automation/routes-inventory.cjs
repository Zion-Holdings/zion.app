#!/usr/bin/env node
/* eslint-disable */
const fs = require('fs');
const path = require('path');

const ROOT = process.cwd();
const PAGES_DIR = path.join(ROOT, 'pages');

function walk(dir) {
  const out = [];
  for (const e of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) out.push(...walk(full));
    else out.push(full);
  }
  return out;
}

function toRoute(file) {
  const rel = file.replace(PAGES_DIR, '').replace(/\\/g, '/');
  if (rel.startsWith('/api/')) return null;
  if (!/\.(tsx|jsx|ts|js)$/.test(rel)) return null;
  // Remove extension and index
  let route = rel.replace(/\.(tsx|jsx|ts|js)$/, '');
  if (route.endsWith('/index')) route = route.slice(0, -('/index'.length)) || '/';
  // Next.js dynamic segments remain like /users/[id]
  return route;
}

function toMarkdown(routes) {
  const lines = ['# Routes Index', '', 'Auto-generated from Next.js pages.', ''];
  for (const r of routes) lines.push(`- ${r}`);
  lines.push('', '_Generated by automation/routes-inventory.cjs_');
  return lines.join('\n');
}

function main() {
  if (!fs.existsSync(PAGES_DIR)) return;
  const files = walk(PAGES_DIR);
  const routes = files.map(toRoute).filter(Boolean).sort();
  const docsDir = path.join(ROOT, 'docs');
  if (!fs.existsSync(docsDir)) fs.mkdirSync(docsDir, { recursive: true });
  fs.writeFileSync(path.join(docsDir, 'routes-index.json'), JSON.stringify(routes, null, 2));
  fs.writeFileSync(path.join(docsDir, 'routes-index.md'), toMarkdown(routes));
  console.log('routes-inventory: updated docs/routes-index.*');
}

if (require.main === module) main();