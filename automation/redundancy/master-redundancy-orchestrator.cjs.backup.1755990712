#!/usr/bin/env node
"use strict";

const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");
<<<<<<< HEAD
const cron = require("node-cron");

class MasterRedundancyOrchestrator {
  constructor() {
    this.config = {
      systems: {
        pm2: {
          name: "PM2 Redundancy",
          manager: path.join(__dirname, "pm2-redundancy-manager.cjs"),
          enabled: true,
          autoStart: true,
          healthCheckInterval: 300000, // 5 minutes
          restartOnFailure: true
        },
        githubActions: {
          name: "GitHub Actions Redundancy",
          manager: path.join(__dirname, "github-actions-redundancy.cjs"),
          enabled: true,
          autoStart: true,
          healthCheckInterval: 600000, // 10 minutes
          restartOnFailure: true
        },
        netlifyFunctions: {
          name: "Netlify Functions Redundancy",
          manager: path.join(__dirname, "netlify-functions-redundancy.cjs"),
          enabled: true,
          autoStart: true,
          healthCheckInterval: 900000, // 15 minutes
          restartOnFailure: true
        }
      },
      logDir: path.join(__dirname, "../logs"),
      reportDir: path.join(__dirname, "reports"),
      backupDir: path.join(__dirname, "backups"),
      healthCheckInterval: 120000, // 2 minutes
      maxRestartAttempts: 3,
      restartCooldown: 300000 // 5 minutes
    };
    
    this.systemProcesses = new Map();
    this.systemHealth = new Map();
    this.restartAttempts = new Map();
    this.lastRestart = new Map();
    this.healthMonitor = null;
    
    this.ensureDirectories();
    this.setupLogging();
  }

  ensureDirectories() {
    [this.config.logDir, this.config.reportDir, this.config.backupDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  setupLogging() {
    this.log = (message, level = "INFO") => {
      const timestamp = new Date().toISOString();
      const logMessage = `[${timestamp}] [${level}] [MASTER] ${message}`;
      
      console.log(logMessage);
      
      // Write to log file
      const logFile = path.join(this.config.logDir, "master-redundancy-orchestrator.log");
      try {
        fs.appendFileSync(logFile, logMessage + "\n");
      } catch (error) {
        console.error(`Failed to write to log file: ${error.message}`);
      }
    };
  }

  runCommand(command, args = [], options = {}) {
=======

class MasterRedundancyOrchestrator {
  constructor() {
    this.logsDir = path.join(process.cwd(), "automation", "logs");
    this.redundancyDir = path.join(process.cwd(), "automation", "redundancy");
    this.ensureDirectories();
    
    // Import redundancy managers
    this.pm2Manager = null;
    this.githubActionsManager = null;
    this.netlifyFunctionsManager = null;
    
    this.loadManagers();
  }

  ensureDirectories() {
    if (!fs.existsSync(this.logsDir)) {
      fs.mkdirSync(this.logsDir, { recursive: true });
    }
  }

  loadManagers() {
    try {
      const pm2ManagerPath = path.join(this.redundancyDir, "pm2-redundancy-manager.cjs");
      const githubActionsManagerPath = path.join(this.redundancyDir, "github-actions-redundancy-manager.cjs");
      const netlifyFunctionsManagerPath = path.join(this.redundancyDir, "netlify-functions-redundancy-manager.cjs");

      if (fs.existsSync(pm2ManagerPath)) {
        this.pm2Manager = require(pm2ManagerPath);
      }
      if (fs.existsSync(githubActionsManagerPath)) {
        this.githubActionsManager = require(githubActionsManagerPath);
      }
      if (fs.existsSync(netlifyFunctionsManagerPath)) {
        this.netlifyFunctionsManager = require(netlifyFunctionsManagerPath);
      }
    } catch (error) {
      this.log(`Failed to load redundancy managers: ${error.message}`);
    }
  }

  log(message) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] MASTER-REDUNDANCY: ${message}`;
    console.log(logMessage);
    
    // Write to log file
    const logFile = path.join(this.logsDir, "master-redundancy-orchestrator.log");
    fs.appendFileSync(logFile, logMessage + "\n");
  }

  runCommand(command, args = []) {
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-c86d
    const result = spawnSync(command, args, {
      cwd: process.cwd(),
      env: process.env,
      shell: false,
      encoding: "utf8",
<<<<<<< HEAD
      maxBuffer: 1024 * 1024 * 20,
      ...options
    });
    
    return {
      status: result.status || 0,
      stdout: (result.stdout || "").trim(),
      stderr: (result.stderr || "").trim(),
      success: (result.status || 0) === 0
    };
  }

  async startSystem(systemName, systemConfig) {
    if (!systemConfig.enabled) {
      this.log(`System ${systemName} is disabled, skipping`);
      return { success: false, skipped: true };
    }

    if (!fs.existsSync(systemConfig.manager)) {
      this.log(`System manager not found: ${systemConfig.manager}`, "ERROR");
      return { success: false, error: "Manager not found" };
    }

    this.log(`Starting system: ${systemName}`);
    
    try {
      // Start the system manager
      const process = spawn("node", [systemConfig.manager, "start"], {
        cwd: process.cwd(),
        env: process.env,
        stdio: ["pipe", "pipe", "pipe"]
      });

      // Store process reference
      this.systemProcesses.set(systemName, {
        process,
        startTime: new Date(),
        status: "starting",
        config: systemConfig
      });

      // Monitor process output
      process.stdout.on("data", (data) => {
        this.log(`[${systemName}] ${data.toString().trim()}`);
      });

      process.stderr.on("data", (data) => {
        this.log(`[${systemName}] ERROR: ${data.toString().trim()}`, "ERROR");
      });

      // Handle process exit
      process.on("exit", (code, signal) => {
        this.log(`System ${systemName} exited with code ${code} and signal ${signal}`);
        
        const systemInfo = this.systemProcesses.get(systemName);
        if (systemInfo) {
          systemInfo.status = "stopped";
          systemInfo.exitCode = code;
          systemInfo.exitSignal = signal;
          systemInfo.endTime = new Date();
        }

        // Attempt restart if enabled
        if (systemConfig.restartOnFailure && code !== 0) {
          this.scheduleSystemRestart(systemName);
        }
      });

      // Wait a moment for startup
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Check if process is still running
      if (process.exitCode === null) {
        this.systemProcesses.get(systemName).status = "running";
        this.log(`System ${systemName} started successfully`);
        return { success: true, pid: process.pid };
      } else {
        this.log(`System ${systemName} failed to start`, "ERROR");
        return { success: false, error: "Process exited during startup" };
      }

    } catch (error) {
      this.log(`Failed to start system ${systemName}: ${error.message}`, "ERROR");
      return { success: false, error: error.message };
    }
  }

  async stopSystem(systemName) {
    const systemInfo = this.systemProcesses.get(systemName);
    if (!systemInfo) {
      this.log(`System ${systemName} not found`);
      return { success: false, error: "System not found" };
    }

    this.log(`Stopping system: ${systemName}`);
    
    try {
      // Send SIGTERM first
      systemInfo.process.kill("SIGTERM");
      
      // Wait for graceful shutdown
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // Force kill if still running
      if (systemInfo.process.exitCode === null) {
        systemInfo.process.kill("SIGKILL");
      }
      
      systemInfo.status = "stopped";
      systemInfo.endTime = new Date();
      
      this.log(`System ${systemName} stopped`);
      return { success: true };
      
    } catch (error) {
      this.log(`Failed to stop system ${systemName}: ${error.message}`, "ERROR");
      return { success: false, error: error.message };
    }
  }

  async restartSystem(systemName) {
    this.log(`Restarting system: ${systemName}`);
    
    const stopResult = await this.stopSystem(systemName);
    if (!stopResult.success) {
      this.log(`Failed to stop system ${systemName} for restart`, "WARN");
    }
    
    // Wait a moment before restarting
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const systemConfig = this.config.systems[systemName];
    const startResult = await this.startSystem(systemName, systemConfig);
    
    if (startResult.success) {
      this.log(`System ${systemName} restarted successfully`);
      // Reset restart attempts on successful restart
      this.restartAttempts.set(systemName, 0);
    } else {
      this.log(`Failed to restart system ${systemName}`, "ERROR");
    }
    
    return startResult;
  }

  scheduleSystemRestart(systemName) {
    const attempts = this.restartAttempts.get(systemName) || 0;
    const lastRestart = this.lastRestart.get(systemName) || 0;
    const now = Date.now();
    
    if (attempts >= this.config.maxRestartAttempts) {
      this.log(`Max restart attempts reached for system ${systemName}`, "ERROR");
      return;
    }
    
    if (now - lastRestart < this.config.restartCooldown) {
      this.log(`Restart cooldown active for system ${systemName}, skipping restart`, "WARN");
      return;
    }
    
    this.log(`Scheduling restart for system ${systemName} (attempt ${attempts + 1})`);
    
    this.restartAttempts.set(systemName, attempts + 1);
    this.lastRestart.set(systemName, now);
    
    // Schedule restart after cooldown
    setTimeout(async () => {
      await this.restartSystem(systemName);
    }, this.config.restartCooldown);
  }

  async checkSystemHealth(systemName) {
    const systemInfo = this.systemProcesses.get(systemName);
    if (!systemInfo) {
      return { healthy: false, reason: "System not running" };
    }

    const systemConfig = this.config.systems[systemName];
    
    try {
      // Check if process is still alive
      if (systemInfo.process.exitCode !== null) {
        return { healthy: false, reason: "Process exited" };
      }

      // Run health check command
      const result = this.runCommand("node", [systemConfig.manager, "status"]);
      
      if (result.success) {
        return { healthy: true, status: result.stdout };
      } else {
        return { healthy: false, reason: "Health check failed", error: result.stderr };
      }
      
    } catch (error) {
      return { healthy: false, reason: "Health check error", error: error.message };
    }
  }

  async performHealthCheck() {
    this.log("Performing master health check...");
    
    const healthStatus = {
      timestamp: new Date().toISOString(),
      overall: "healthy",
      systems: {},
      issues: []
    };

    for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
      if (!systemConfig.enabled) continue;
      
      const health = await this.checkSystemHealth(systemName);
      healthStatus.systems[systemName] = health;
      
      if (!health.healthy) {
        healthStatus.overall = "degraded";
        healthStatus.issues.push(`${systemName}: ${health.reason}`);
        
        // Attempt recovery if restart is enabled
        if (systemConfig.restartOnFailure) {
          this.scheduleSystemRestart(systemName);
        }
      }
    }

    // Update system health tracking
    this.systemHealth.set(Date.now(), healthStatus);

    // Log health status
    if (healthStatus.overall === "healthy") {
      this.log("Master health check passed");
    } else {
      this.log(`Master health check issues: ${healthStatus.issues.join(", ")}`, "WARN");
    }

    // Generate health report
    const healthReportPath = path.join(this.config.reportDir, `master-health-check-${Date.now()}.json`);
    try {
      fs.writeFileSync(healthReportPath, JSON.stringify(healthStatus, null, 2));
    } catch (error) {
      this.log(`Failed to generate health report: ${error.message}`, "WARN");
    }

    return healthStatus;
  }

  startHealthMonitoring() {
    this.log("Starting master health monitoring...");
    
    this.healthMonitor = setInterval(async () => {
      await this.performHealthCheck();
    }, this.config.healthCheckInterval);
    
    this.log("Master health monitoring started");
  }

  stopHealthMonitoring() {
    if (this.healthMonitor) {
      clearInterval(this.healthMonitor);
      this.healthMonitor = null;
      this.log("Master health monitoring stopped");
    }
  }

  async startAllSystems() {
    this.log("Starting all redundancy systems...");
    
    const results = {};
    
    for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
      if (systemConfig.enabled && systemConfig.autoStart) {
        results[systemName] = await this.startSystem(systemName, systemConfig);
      }
    }
    
    const successCount = Object.values(results).filter(r => r.success).length;
    const totalCount = Object.keys(results).length;
    
    this.log(`Started ${successCount}/${totalCount} systems successfully`);
    
    return results;
  }

  async stopAllSystems() {
    this.log("Stopping all redundancy systems...");
    
    const results = {};
    
    for (const systemName of this.systemProcesses.keys()) {
      results[systemName] = await this.stopSystem(systemName);
    }
    
    this.log("All systems stopped");
    return results;
  }

  getStatus() {
    const status = {
      timestamp: new Date().toISOString(),
      systems: {},
      overall: {
        totalSystems: Object.keys(this.config.systems).length,
        enabledSystems: Object.values(this.config.systems).filter(s => s.enabled).length,
        runningSystems: 0,
        stoppedSystems: 0,
        failedSystems: 0
      }
    };

    for (const [systemName, systemInfo] of this.systemProcesses) {
      const systemConfig = this.config.systems[systemName];
      status.systems[systemName] = {
        name: systemConfig.name,
        status: systemInfo.status,
        startTime: systemInfo.startTime,
        endTime: systemInfo.endTime,
        pid: systemInfo.process?.pid,
        exitCode: systemInfo.exitCode,
        exitSignal: systemInfo.exitSignal,
        restartAttempts: this.restartAttempts.get(systemName) || 0,
        lastRestart: this.lastRestart.get(systemName) || null
      };

      // Update overall counts
      if (systemInfo.status === "running") {
        status.overall.runningSystems++;
      } else if (systemInfo.status === "stopped") {
        status.overall.stoppedSystems++;
      } else if (systemInfo.status === "failed") {
        status.overall.failedSystems++;
      }
    }

    return status;
  }

  generateStatusReport() {
    const status = this.getStatus();
    const report = {
      timestamp: new Date().toISOString(),
      status,
      health: {
        lastHealthCheck: Array.from(this.systemHealth.keys()).pop() || null,
        healthHistory: Array.from(this.systemHealth.entries()).slice(-10) // Last 10 health checks
      }
    };

    const reportPath = path.join(this.config.reportDir, "master-status-report.json");
    try {
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      this.log(`Master status report generated: ${reportPath}`);
    } catch (error) {
      this.log(`Failed to generate status report: ${error.message}`, "WARN");
=======
      maxBuffer: 1024 * 1024 * 10
    });
    return {
      status: result.status,
      stdout: result.stdout || "",
      stderr: result.stderr || "",
      success: result.status === 0
    };
  }

  async setupPM2Redundancy() {
    this.log("Setting up PM2 redundancy...");
    
    if (!this.pm2Manager) {
      this.log("PM2 manager not available, running setup directly...");
      const result = this.runCommand("node", [
        "automation/redundancy/pm2-redundancy-manager.cjs",
        "full-setup"
      ]);
      
      if (result.success) {
        this.log("PM2 redundancy setup completed");
        return true;
      } else {
        this.log(`PM2 redundancy setup failed: ${result.stderr}`);
        return false;
      }
    }

    try {
      const manager = new this.pm2Manager();
      manager.backupPM2Configuration();
      manager.createRedundancyEcosystem();
      manager.startRedundancyProcesses();
      this.log("PM2 redundancy setup completed");
      return true;
    } catch (error) {
      this.log(`PM2 redundancy setup failed: ${error.message}`);
      return false;
    }
  }

  async setupGitHubActionsRedundancy() {
    this.log("Setting up GitHub Actions redundancy...");
    
    if (!this.githubActionsManager) {
      this.log("GitHub Actions manager not available, running setup directly...");
      const result = this.runCommand("node", [
        "automation/redundancy/github-actions-redundancy-manager.cjs",
        "full-setup"
      ]);
      
      if (result.success) {
        this.log("GitHub Actions redundancy setup completed");
        return true;
      } else {
        this.log(`GitHub Actions redundancy setup failed: ${result.stderr}`);
        return false;
      }
    }

    try {
      const manager = new this.githubActionsManager();
      manager.backupWorkflows();
      manager.createRedundancyWorkflows();
      manager.createWorkflowOrchestrator();
      this.log("GitHub Actions redundancy setup completed");
      return true;
    } catch (error) {
      this.log(`GitHub Actions redundancy setup failed: ${error.message}`);
      return false;
    }
  }

  async setupNetlifyFunctionsRedundancy() {
    this.log("Setting up Netlify Functions redundancy...");
    
    if (!this.netlifyFunctionsManager) {
      this.log("Netlify Functions manager not available, running setup directly...");
      const result = this.runCommand("node", [
        "automation/redundancy/netlify-functions-redundancy-manager.cjs",
        "full-setup"
      ]);
      
      if (result.success) {
        this.log("Netlify Functions redundancy setup completed");
        return true;
      } else {
        this.log(`Netlify Functions redundancy setup failed: ${result.stderr}`);
        return false;
      }
    }

    try {
      const manager = new this.netlifyFunctionsManager();
      manager.backupFunctions();
      manager.createRedundancyFunctions();
      manager.createRedundancyManifest();
      manager.createFunctionOrchestrator();
      manager.createRedundancyDeploymentScript();
      this.log("Netlify Functions redundancy setup completed");
      return true;
    } catch (error) {
      this.log(`Netlify Functions redundancy setup failed: ${error.message}`);
      return false;
    }
  }

  async setupAllRedundancy() {
    this.log("Setting up complete redundancy system...");
    
    const results = {
      pm2: false,
      githubActions: false,
      netlifyFunctions: false
    };

    // Setup PM2 redundancy
    try {
      results.pm2 = await this.setupPM2Redundancy();
    } catch (error) {
      this.log(`PM2 redundancy setup error: ${error.message}`);
    }

    // Setup GitHub Actions redundancy
    try {
      results.githubActions = await this.setupGitHubActionsRedundancy();
    } catch (error) {
      this.log(`GitHub Actions redundancy setup error: ${error.message}`);
    }

    // Setup Netlify Functions redundancy
    try {
      results.netlifyFunctions = await this.setupNetlifyFunctionsRedundancy();
    } catch (error) {
      this.log(`Netlify Functions redundancy setup error: ${error.message}`);
    }

    // Generate setup report
    const setupReport = {
      timestamp: new Date().toISOString(),
      results: results,
      overall: Object.values(results).every(r => r),
      summary: {
        pm2: results.pm2 ? "Success" : "Failed",
        githubActions: results.githubActions ? "Success" : "Failed",
        netlifyFunctions: results.netlifyFunctions ? "Success" : "Failed"
      }
    };

    // Save setup report
    const reportPath = path.join(this.redundancyDir, "redundancy-setup-report.json");
    try {
      fs.writeFileSync(reportPath, JSON.stringify(setupReport, null, 2));
      this.log(`Setup report saved to: ${reportPath}`);
    } catch (error) {
      this.log(`Failed to save setup report: ${error.message}`);
    }

    // Log results
    this.log("Redundancy setup results:");
    this.log(`  PM2: ${results.pm2 ? "SUCCESS" : "FAILED"}`);
    this.log(`  GitHub Actions: ${results.githubActions ? "SUCCESS" : "FAILED"}`);
    this.log(`  Netlify Functions: ${results.netlifyFunctions ? "SUCCESS" : "FAILED"}`);
    this.log(`  Overall: ${setupReport.overall ? "SUCCESS" : "FAILED"}`);

    return setupReport;
  }

  async monitorRedundancy() {
    this.log("Starting redundancy monitoring...");
    
    const monitoring = true;
    while (monitoring) {
      try {
        // Check PM2 health
        if (this.pm2Manager) {
          const pm2Result = this.runCommand("node", [
            "automation/pm2-health-monitor.cjs",
            "check"
          ]);
          
          if (pm2Result.success) {
            this.log("PM2 health check passed");
          } else {
            this.log("PM2 health check failed, attempting recovery...");
            this.runCommand("node", [
              "automation/pm2-health-monitor.cjs",
              "recover"
            ]);
          }
        }

        // Check GitHub Actions status
        const workflowsDir = path.join(process.cwd(), ".github", "workflows");
        if (fs.existsSync(workflowsDir)) {
          const workflows = fs.readdirSync(workflowsDir);
          const redundancyWorkflows = workflows.filter(w => w.includes('redundancy'));
          this.log(`Found ${redundancyWorkflows.length} redundancy workflows`);
        }

        // Check Netlify Functions status
        const functionsDir = path.join(process.cwd(), "netlify", "functions");
        if (fs.existsSync(functionsDir)) {
          const manifestPath = path.join(functionsDir, "functions-manifest.json");
          if (fs.existsSync(manifestPath)) {
            try {
              const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
              this.log(`Netlify functions available: ${manifest.functions ? manifest.functions.length : 0}`);
            } catch (error) {
              this.log(`Failed to read Netlify functions manifest: ${error.message}`);
            }
          }
        }

        // Wait before next check
        await new Promise(resolve => setTimeout(resolve, 60000)); // 1 minute

      } catch (error) {
        this.log(`Monitoring error: ${error.message}`);
        await new Promise(resolve => setTimeout(resolve, 30000)); // 30 seconds on error
      }
    }
  }

  generateRedundancyReport() {
    this.log("Generating redundancy report...");
    
    const report = {
      timestamp: new Date().toISOString(),
      systems: {
        pm2: {
          status: "unknown",
          processes: [],
          health: null
        },
        githubActions: {
          status: "unknown",
          workflows: [],
          redundancyWorkflows: []
        },
        netlifyFunctions: {
          status: "unknown",
          functions: [],
          redundancyFunctions: []
        }
      },
      recommendations: []
    };

    // Check PM2 status
    try {
      const pm2Status = this.runCommand("pm2", ["jlist"]);
      if (pm2Status.success) {
        const processes = JSON.parse(pm2Status.stdout);
        report.systems.pm2.status = "operational";
        report.systems.pm2.processes = processes.map(p => ({
          name: p.name,
          status: p.pm2_env?.status,
          restarts: p.pm2_env?.restart_time || 0
        }));
        
        // Check for redundancy processes
        const redundancyProcesses = processes.filter(p => 
          p.name.includes('redundant') || p.name.includes('backup')
        );
        if (redundancyProcesses.length === 0) {
          report.recommendations.push("PM2: No redundancy processes found, consider setting up redundancy");
        }
      } else {
        report.systems.pm2.status = "failed";
        report.recommendations.push("PM2: Failed to get status");
      }
    } catch (error) {
      report.systems.pm2.status = "error";
      report.systems.pm2.processes = [];
    }

    // Check GitHub Actions status
    const workflowsDir = path.join(process.cwd(), ".github", "workflows");
    if (fs.existsSync(workflowsDir)) {
      const workflows = fs.readdirSync(workflowsDir);
      report.systems.githubActions.workflows = workflows;
      report.systems.githubActions.redundancyWorkflows = workflows.filter(w => 
        w.includes('redundancy') || w.includes('backup')
      );
      report.systems.githubActions.status = "operational";
      
      if (report.systems.githubActions.redundancyWorkflows.length === 0) {
        report.recommendations.push("GitHub Actions: No redundancy workflows found, consider setting up redundancy");
      }
    } else {
      report.systems.githubActions.status = "not_found";
      report.recommendations.push("GitHub Actions: Workflows directory not found");
    }

    // Check Netlify Functions status
    const functionsDir = path.join(process.cwd(), "netlify", "functions");
    if (fs.existsSync(functionsDir)) {
      const manifestPath = path.join(functionsDir, "functions-manifest.json");
      if (fs.existsSync(manifestPath)) {
        try {
          const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
          report.systems.netlifyFunctions.functions = manifest.functions || [];
          report.systems.netlifyFunctions.status = "operational";
          
          // Check for redundancy functions
          const redundancyDir = path.join(this.redundancyDir, "netlify-functions");
          if (fs.existsSync(redundancyDir)) {
            const redundancyFunctions = fs.readdirSync(redundancyDir);
            report.systems.netlifyFunctions.redundancyFunctions = redundancyFunctions;
            
            if (redundancyFunctions.length === 0) {
              report.recommendations.push("Netlify Functions: No redundancy functions found, consider setting up redundancy");
            }
          }
        } catch (error) {
          report.systems.netlifyFunctions.status = "error";
          report.recommendations.push(`Netlify Functions: Failed to parse manifest: ${error.message}`);
        }
      } else {
        report.systems.netlifyFunctions.status = "no_manifest";
        report.recommendations.push("Netlify Functions: No functions manifest found");
      }
    } else {
      report.systems.netlifyFunctions.status = "not_found";
      report.recommendations.push("Netlify Functions: Functions directory not found");
    }

    // Save report
    const reportPath = path.join(this.redundancyDir, "redundancy-status-report.json");
    try {
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      this.log(`Redundancy report saved to: ${reportPath}`);
    } catch (error) {
      this.log(`Failed to save redundancy report: ${error.message}`);
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-c86d
    }

    return report;
  }

<<<<<<< HEAD
  start() {
    this.log("Starting Master Redundancy Orchestrator...");
    
    try {
      this.startHealthMonitoring();
      this.startAllSystems();
      this.log("Master Redundancy Orchestrator started successfully");
      
      // Generate initial status report
      this.generateStatusReport();
      
      // Generate status report every 30 minutes
      setInterval(() => {
        this.generateStatusReport();
      }, 30 * 60 * 1000);
      
    } catch (error) {
      this.log(`Failed to start orchestrator: ${error.message}`, "ERROR");
      throw error;
    }
  }

  stop() {
    this.log("Stopping Master Redundancy Orchestrator...");
    
    this.stopHealthMonitoring();
    this.stopAllSystems();
    
    this.log("Master Redundancy Orchestrator stopped");
  }
}

// CLI interface
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  const command = process.argv[2] || "start";
  
  switch (command) {
    case "start":
      orchestrator.start();
      // Keep process alive
      process.on("SIGINT", () => {
        orchestrator.stop();
        process.exit(0);
      });
      break;
    case "stop":
      orchestrator.stop();
      break;
    case "restart":
      orchestrator.stop();
      setTimeout(() => orchestrator.start(), 2000);
      break;
    case "status":
      console.log(JSON.stringify(orchestrator.getStatus(), null, 2));
      break;
    case "report":
      console.log(JSON.stringify(orchestrator.generateStatusReport(), null, 2));
      break;
    case "health":
      orchestrator.performHealthCheck().then(result => {
        console.log(JSON.stringify(result, null, 2));
      });
      break;
    case "start-system":
      const systemName = process.argv[3];
      if (!systemName) {
        console.error("Please specify system name: node master-redundancy-orchestrator.cjs start-system <system-name>");
        process.exit(1);
      }
      const systemConfig = orchestrator.config.systems[systemName];
      if (!systemConfig) {
        console.error(`System ${systemName} not found`);
        process.exit(1);
      }
      orchestrator.startSystem(systemName, systemConfig).then(result => {
        console.log(JSON.stringify(result, null, 2));
        process.exit(result.success ? 0 : 1);
      });
      break;
    case "stop-system":
      const stopSystemName = process.argv[3];
      if (!stopSystemName) {
        console.error("Please specify system name: node master-redundancy-orchestrator.cjs stop-system <system-name>");
        process.exit(1);
      }
      orchestrator.stopSystem(stopSystemName).then(result => {
        console.log(JSON.stringify(result, null, 2));
        process.exit(result.success ? 0 : 1);
      });
      break;
    case "list":
      console.log("Available systems:");
      Object.entries(orchestrator.config.systems).forEach(([name, config]) => {
        console.log(`  ${name}: ${config.enabled ? "enabled" : "disabled"} - ${config.name}`);
      });
      break;
    default:
      console.log(`
Master Redundancy Orchestrator - Usage:
  node master-redundancy-orchestrator.cjs [command]

Commands:
  start                    - Start the orchestrator and all systems
  stop                     - Stop the orchestrator and all systems
  restart                  - Restart the orchestrator
  status                   - Show current status
  report                   - Generate status report
  health                   - Perform health check
  start-system <system>    - Start a specific system
  stop-system <system>     - Stop a specific system
  list                     - List available systems

Examples:
  node master-redundancy-orchestrator.cjs start
  node master-redundancy-orchestrator.cjs status
  node master-redundancy-orchestrator.cjs start-system pm2
      `);
  }
=======
  run() {
    const command = process.argv[2];
    
    switch (command) {
      case "setup":
        this.setupAllRedundancy();
        break;
      case "setup-pm2":
        this.setupPM2Redundancy();
        break;
      case "setup-github":
        this.setupGitHubActionsRedundancy();
        break;
      case "setup-netlify":
        this.setupNetlifyFunctionsRedundancy();
        break;
      case "monitor":
        this.monitorRedundancy();
        break;
      case "report":
        const report = this.generateRedundancyReport();
        console.log(JSON.stringify(report, null, 2));
        break;
      case "status":
        const status = this.generateRedundancyReport();
        console.log("Redundancy System Status:");
        console.log(`  PM2: ${status.systems.pm2.status}`);
        console.log(`  GitHub Actions: ${status.systems.githubActions.status}`);
        console.log(`  Netlify Functions: ${status.systems.netlifyFunctions.status}`);
        break;
      default:
        this.log("Available commands: setup, setup-pm2, setup-github, setup-netlify, monitor, report, status");
        this.log("Usage: node automation/redundancy/master-redundancy-orchestrator.cjs <command>");
    }
  }
}

// Run if called directly
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  orchestrator.run();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-c86d
}

module.exports = MasterRedundancyOrchestrator;