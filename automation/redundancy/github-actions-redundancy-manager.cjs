#!/usr/bin/env node
'use strict';

const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const cron = require('node-cron');

class GitHubActionsRedundancyManager {
  constructor() {
    this.logDir = path.join(process.cwd(), 'automation', 'logs');
    this.workflowsDir = path.join(process.cwd(), '.github', 'workflows');
    this.ensureLogDir();
    this.backupWorkflows = new Map();
    this.healthChecks = new Map();
    this.recoveryAttempts = new Map();
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

  log(message, level = 'INFO') {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    const logFile = path.join(this.logDir, 'github-actions-redundancy.log');
    fs.appendFileSync(logFile, logMessage + '\n');
  }

  runCommand(command, args = [], options = {}) {
    const result = spawnSync(command, args, {
      cwd: process.cwd(),
      env: process.env,
      shell: false,
      encoding: 'utf8',
      maxBuffer: 1024 * 1024 * 10
    });
    return {
      status: result.status,
      stdout: result.stdout || '',
      stderr: result.stderr || '',
      success: result.status === 0
    };
  }

  async scanWorkflows() {
    this.log('Scanning GitHub Actions workflows...');
    
    if (!fs.existsSync(this.workflowsDir)) {
      this.log('Workflows directory not found', 'WARN');
      return [];
    }

    const workflowFiles = fs.readdirSync(this.workflowsDir)
      .filter(file => file.endsWith('.yml') || file.endsWith('.yaml'))
      .map(file => path.join(this.workflowsDir, file));

    this.log(`Found ${workflowFiles.length} workflow files`);
    return workflowFiles;
  }

  async createBackupWorkflows() {
    this.log('Creating backup workflows...');
    
    const workflowFiles = await this.scanWorkflows();
    
    for (const workflowPath of workflowFiles) {
      await this.createBackupWorkflow(workflowPath);
    }
  }

  async createBackupWorkflow(workflowPath) {
    const workflowName = path.basename(workflowPath, path.extname(workflowPath));
    const backupName = `${workflowName}-backup`;
    const backupPath = path.join(this.workflowsDir, `${backupName}.yml`);
    
    try {
      const workflowContent = fs.readFileSync(workflowPath, 'utf8');
      const backupContent = this.generateBackupWorkflow(workflowContent, backupName);
      
      fs.writeFileSync(backupPath, backupContent);
      
      this.log(`Created backup workflow: ${backupName}`);
      this.backupWorkflows.set(backupName, {
        original: workflowName,
        path: backupPath,
        created: new Date(),
        health: 'healthy'
      });
      
    } catch (error) {
      this.log(`Failed to create backup for ${workflowName}: ${error.message}`, 'ERROR');
    }
  }

  generateBackupWorkflow(originalContent, backupName) {
    // Parse the original workflow and create a backup version
    const lines = originalContent.split('\n');
    const backupLines = [];
    
    for (const line of lines) {
      if (line.includes('name:')) {
        backupLines.push(`name: ${backupName}`);
      } else if (line.includes('on:')) {
        // Keep the same triggers but add manual dispatch
        backupLines.push(line);
      } else if (line.includes('schedule:')) {
        // Adjust schedule to run less frequently as backup
        backupLines.push('  schedule:');
        backupLines.push('    - cron: \'0 */24 * * *\'  # Daily backup');
      } else if (line.includes('workflow_dispatch:')) {
        // Keep manual dispatch
        backupLines.push(line);
      } else {
        backupLines.push(line);
      }
    }
    
    // Add backup identifier comment
    backupLines.unshift('# Backup workflow - Auto-generated by redundancy manager');
    backupLines.unshift('# Original workflow: ' + path.basename(originalContent.split('\n')[0]?.replace('name:', '').trim() || 'unknown'));
    
    return backupLines.join('\n');
  }

  async triggerBackupWorkflows() {
    this.log('Triggering backup workflows...');
    
    for (const [name, info] of this.backupWorkflows) {
      try {
        await this.triggerWorkflow(name);
        this.log(`Triggered backup workflow: ${name}`);
      } catch (error) {
        this.log(`Failed to trigger ${name}: ${error.message}`, 'ERROR');
        info.health = 'unhealthy';
      }
    }
  }

  async triggerWorkflow(workflowName) {
    // Use GitHub CLI to trigger workflow
    const result = this.runCommand('gh', [
      'workflow', 'run', `${workflowName}.yml`,
      '--ref', 'main'
    ]);
    
    if (!result.success) {
      throw new Error(`GitHub CLI failed: ${result.stderr}`);
    }
    
    return result.stdout;
  }

  async checkWorkflowHealth() {
    this.log('Checking workflow health...');
    
    for (const [name, info] of this.backupWorkflows) {
      try {
        const health = await this.checkSingleWorkflowHealth(name);
        info.health = health;
        info.lastCheck = new Date();
        
        if (health === 'unhealthy') {
          await this.recoverWorkflow(name, info);
        }
      } catch (error) {
        this.log(`Health check failed for ${name}: ${error.message}`, 'ERROR');
        info.health = 'unhealthy';
      }
    }
  }

  async checkSingleWorkflowHealth(workflowName) {
    // Check if workflow file exists and is valid
    const workflowPath = path.join(this.workflowsDir, `${workflowName}.yml`);
    
    if (!fs.existsSync(workflowPath)) {
      return 'unhealthy';
    }
    
    // Check if workflow can be parsed
    try {
      const content = fs.readFileSync(workflowPath, 'utf8');
      if (!content.includes('name:') || !content.includes('on:')) {
        return 'unhealthy';
      }
      return 'healthy';
    } catch (error) {
      return 'unhealthy';
    }
  }

  async recoverWorkflow(name, info) {
    this.log(`Recovering workflow: ${name}`);
    
    const attempts = this.recoveryAttempts.get(name) || 0;
    if (attempts >= 3) {
      this.log(`Max recovery attempts reached for ${name}`, 'ERROR');
      return;
    }

    this.recoveryAttempts.set(name, attempts + 1);
    
    try {
      // Recreate the backup workflow
      const originalPath = path.join(this.workflowsDir, `${info.original}.yml`);
      if (fs.existsSync(originalPath)) {
        await this.createBackupWorkflow(originalPath);
        this.log(`Recovered workflow: ${name}`);
      } else {
        this.log(`Original workflow not found for ${name}`, 'WARN');
      }
    } catch (error) {
      this.log(`Recovery failed for ${name}: ${error.message}`, 'ERROR');
    }
  }

  async startHealthMonitoring() {
    this.log('Starting health monitoring...');
    
    // Monitor every 10 minutes
    cron.schedule('*/10 * * * *', async () => {
      await this.checkWorkflowHealth();
    });

    // Trigger backups every 6 hours
    cron.schedule('0 */6 * * *', async () => {
      await this.triggerBackupWorkflows();
    });
  }

  async generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      backupWorkflows: Array.from(this.backupWorkflows.entries()).map(([name, info]) => ({
        name,
        original: info.original,
        path: info.path,
        created: info.created,
        health: info.health,
        lastCheck: info.lastCheck
      })),
      recoveryAttempts: Object.fromEntries(this.recoveryAttempts),
      totalBackups: this.backupWorkflows.size,
      healthyBackups: Array.from(this.backupWorkflows.values()).filter(w => w.health === 'healthy').length
    };

    const reportPath = path.join(this.logDir, 'github-actions-redundancy-report.json');
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    this.log(`Report generated: ${reportPath}`);
    return report;
  }

  async start() {
    this.log('Starting GitHub Actions Redundancy Manager...');
    
    try {
      await this.createBackupWorkflows();
      await this.startHealthMonitoring();
      
      this.log('GitHub Actions Redundancy Manager started successfully');
      
      // Generate initial report
      await this.generateReport();
      
      // Keep the process running
      setInterval(async () => {
        await this.generateReport();
      }, 600000); // Every 10 minutes
      
    } catch (error) {
      this.log(`Failed to start GitHub Actions Redundancy Manager: ${error.message}`, 'ERROR');
      process.exit(1);
    }
  }
}

// CLI interface
if (require.main === module) {
  const manager = new GitHubActionsRedundancyManager();
  
  const command = process.argv[2];
  
  switch (command) {
    case 'start':
      manager.start();
      break;
    case 'scan':
      manager.scanWorkflows().then(workflows => {
        console.log('Workflows found:', workflows);
      });
      break;
    case 'backup':
      manager.createBackupWorkflows();
      break;
    case 'trigger':
      manager.triggerBackupWorkflows();
      break;
    case 'health':
      manager.checkWorkflowHealth();
      break;
    case 'report':
      manager.generateReport().then(report => {
        console.log('Report:', JSON.stringify(report, null, 2));
      });
      break;
    default:
      console.log('Usage: node github-actions-redundancy-manager.cjs [start|scan|backup|trigger|health|report]');
      process.exit(1);
  }
}

module.exports = GitHubActionsRedundancyManager;