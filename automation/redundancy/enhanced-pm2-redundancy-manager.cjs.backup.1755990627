#!/usr/bin/env node
'use strict';

<<<<<<< HEAD
const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');
=======
const { spawnSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-a700
const cron = require('node-cron');

class EnhancedPM2RedundancyManager {
  constructor() {
<<<<<<< HEAD
    // Use a more robust path resolution
    this.baseDir = process.cwd() || '.';
    this.logDir = path.resolve(this.baseDir, 'automation', 'logs');
    
=======
    this.logDir = path.join(process.cwd(), 'automation', 'logs');
    this.ensureLogDir();
    this.backupProcesses = new Map();
    this.healthChecks = new Map();
    this.recoveryAttempts = new Map();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-a700
    this.primaryProcesses = [
      'zion-auto-sync',
      'zion-auto-sync-cron'
    ];
<<<<<<< HEAD
    
    this.backupProcesses = [
      'zion-auto-sync-backup',
      'zion-auto-sync-cron-backup'
    ];
    
    this.redundancyProcesses = [
      'redundancy-master-orchestrator',
      'redundancy-pm2-manager',
      'redundancy-github-manager',
      'redundancy-netlify-manager'
    ];
    
    this.allProcesses = [
      ...this.primaryProcesses,
      ...this.backupProcesses,
      ...this.redundancyProcesses
    ];
    
    this.healthStatus = new Map();
    this.recoveryAttempts = new Map();
    this.maxRecoveryAttempts = 5;
    
    this.ensureLogDir();
  }

  ensureLogDir() {
    try {
      if (!fs.existsSync(this.logDir)) {
        fs.mkdirSync(this.logDir, { recursive: true });
      }
    } catch (error) {
      console.error('Failed to create log directory:', error.message);
      // Fallback to current directory
      this.logDir = path.resolve('.', 'logs');
      if (!fs.existsSync(this.logDir)) {
        fs.mkdirSync(this.logDir, { recursive: true });
      }
=======
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-a700
    }
  }

  log(message, level = 'INFO') {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logMessage = `[${timestamp}] [${level}] [PM2-REDUNDANCY] ${message}`;
    console.log(logMessage);
    
    const logFile = path.join(this.logDir, 'pm2-redundancy.log');
    fs.appendFileSync(logFile, logMessage + '\n');
  }

  async executeCommand(command, options = {}) {
    try {
      const result = execSync(command, {
        encoding: 'utf8',
        stdio: 'pipe',
        ...options
      });
      return { success: true, output: result };
    } catch (error) {
      return { success: false, error: error.message, output: error.stdout || error.stderr };
    }
  }

  async getPM2Status() {
    try {
      const result = await this.executeCommand('pm2 jlist');
      if (result.success) {
        return JSON.parse(result.output);
      }
      return [];
    } catch (error) {
      this.log(`Failed to get PM2 status: ${error.message}`, 'ERROR');
      return [];
    }
  }

  async checkProcessHealth(processName) {
    try {
      const status = await this.getPM2Status();
      const process = status.find(p => p.name === processName);
      
      if (!process) {
        return { status: 'not_found', health: 'unhealthy' };
      }
      
      const health = {
        status: process.pm2_env?.status || 'unknown',
        health: 'healthy',
        uptime: process.pm2_env?.pm_uptime || 0,
        restarts: process.pm2_env?.restart_time || 0,
        memory: process.monit?.memory || 0,
        cpu: process.monit?.cpu || 0
      };
      
      // Determine health based on status and metrics
      if (health.status === 'online' && health.restarts < 10) {
        health.health = 'healthy';
      } else if (health.status === 'online' && health.restarts < 20) {
        health.health = 'degraded';
      } else {
        health.health = 'unhealthy';
      }
      
      return health;
    } catch (error) {
      this.log(`Failed to check health for ${processName}: ${error.message}`, 'ERROR');
      return { status: 'error', health: 'unhealthy', error: error.message };
    }
  }

  async startBackupProcesses() {
    this.log('Starting backup PM2 processes...');
    
    for (const processName of this.backupProcesses) {
      try {
        const health = await this.checkProcessHealth(processName);
        
        if (health.status === 'not_found' || health.health === 'unhealthy') {
          this.log(`Starting backup process: ${processName}`);
          
          // Start the process using ecosystem file
          const result = await this.executeCommand(`pm2 start ecosystem-redundancy.pm2.cjs --only ${processName}`);
          
          if (result.success) {
            this.log(`Successfully started backup process: ${processName}`);
          } else {
            this.log(`Failed to start backup process ${processName}: ${result.error}`, 'ERROR');
          }
        } else {
          this.log(`Backup process ${processName} is already running and healthy`);
        }
      } catch (error) {
        this.log(`Error starting backup process ${processName}: ${error.message}`, 'ERROR');
      }
    }
  }

  async startRedundancyProcesses() {
    this.log('Starting redundancy management processes...');
    
    for (const processName of this.redundancyProcesses) {
      try {
        const health = await this.checkProcessHealth(processName);
        
        if (health.status === 'not_found' || health.health === 'unhealthy') {
          this.log(`Starting redundancy process: ${processName}`);
          
          const result = await this.executeCommand(`pm2 start ecosystem-redundancy.pm2.cjs --only ${processName}`);
          
          if (result.success) {
            this.log(`Successfully started redundancy process: ${processName}`);
          } else {
            this.log(`Failed to start redundancy process ${processName}: ${result.error}`, 'ERROR');
          }
        } else {
          this.log(`Redundancy process ${processName} is already running and healthy`);
        }
      } catch (error) {
        this.log(`Error starting redundancy process ${processName}: ${error.message}`, 'ERROR');
      }
    }
  }

  async monitorAndRecover() {
    this.log('Starting PM2 redundancy monitoring and recovery...');
    
    // Monitor all processes every 2 minutes
    cron.schedule('*/2 * * * *', async () => {
      await this.performHealthCheck();
    });
    
    // Full system recovery check every 10 minutes
    cron.schedule('*/10 * * * *', async () => {
      await this.performFullRecovery();
    });
  }

  async performHealthCheck() {
    this.log('Performing health check on all PM2 processes...');
    
    for (const processName of this.allProcesses) {
      try {
        const health = await this.checkProcessHealth(processName);
        this.healthStatus.set(processName, health);
        
        if (health.health === 'unhealthy') {
          this.log(`Process ${processName} is unhealthy, attempting recovery...`);
          await this.attemptRecovery(processName);
        }
      } catch (error) {
        this.log(`Error checking health for ${processName}: ${error.message}`, 'ERROR');
      }
    }
  }

  async attemptRecovery(processName) {
    const attempts = this.recoveryAttempts.get(processName) || 0;
    
    if (attempts >= this.maxRecoveryAttempts) {
      this.log(`Max recovery attempts reached for ${processName}, escalating...`, 'WARN');
      await this.escalateRecovery(processName);
      return;
    }
    
    this.log(`Attempting recovery for ${processName} (attempt ${attempts + 1}/${this.maxRecoveryAttempts})`);
    
    try {
      // Try to restart the process
      const result = await this.executeCommand(`pm2 restart ${processName}`);
      
      if (result.success) {
        this.log(`Successfully restarted ${processName}`);
        this.recoveryAttempts.set(processName, 0); // Reset attempts on success
      } else {
        this.log(`Failed to restart ${processName}: ${result.error}`, 'ERROR');
        this.recoveryAttempts.set(processName, attempts + 1);
      }
    } catch (error) {
      this.log(`Error during recovery for ${processName}: ${error.message}`, 'ERROR');
      this.recoveryAttempts.set(processName, attempts + 1);
    }
  }

  async escalateRecovery(processName) {
    this.log(`Escalating recovery for ${processName}...`);
    
    try {
      // Stop the problematic process
      await this.executeCommand(`pm2 stop ${processName}`);
      
      // Wait a moment
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // Start it fresh
      const result = await this.executeCommand(`pm2 start ecosystem-redundancy.pm2.cjs --only ${processName}`);
      
      if (result.success) {
        this.log(`Successfully escalated recovery for ${processName}`);
        this.recoveryAttempts.set(processName, 0);
      } else {
        this.log(`Failed escalated recovery for ${processName}: ${result.error}`, 'ERROR');
      }
    } catch (error) {
      this.log(`Error during escalated recovery for ${processName}: ${error.message}`, 'ERROR');
    }
  }

  async performFullRecovery() {
    this.log('Performing full system recovery check...');
    
    // Check if any critical processes are down
    const criticalProcesses = ['redundancy-master-orchestrator', 'redundancy-pm2-manager'];
    
    for (const processName of criticalProcesses) {
      const health = await this.checkProcessHealth(processName);
      
      if (health.status === 'not_found' || health.health === 'unhealthy') {
        this.log(`Critical process ${processName} needs recovery, restarting system...`);
        await this.restartRedundancySystem();
        break;
      }
    }
  }

  async restartRedundancySystem() {
    this.log('Restarting entire redundancy system...');
    
    try {
      // Stop all redundancy processes
      for (const processName of this.redundancyProcesses) {
        await this.executeCommand(`pm2 stop ${processName}`);
      }
      
      // Wait for processes to stop
      await new Promise(resolve => setTimeout(resolve, 10000));
      
      // Start all redundancy processes
      await this.startRedundancyProcesses();
      
      this.log('Redundancy system restart completed');
    } catch (error) {
      this.log(`Error restarting redundancy system: ${error.message}`, 'ERROR');
    }
  }

  async getSystemStatus() {
    const status = {
      timestamp: new Date().toISOString(),
      overallHealth: 'healthy',
      processes: {},
      recoveryStats: {
        totalAttempts: 0,
        successfulRecoveries: 0,
        failedRecoveries: 0
      }
    };
    
    // Get status for all processes
    for (const processName of this.allProcesses) {
      const health = await this.checkProcessHealth(processName);
      status.processes[processName] = health;
      
      if (health.health === 'unhealthy') {
        status.overallHealth = 'degraded';
      }
    }
    
    // Calculate recovery stats
    for (const [processName, attempts] of this.recoveryAttempts) {
      status.recoveryStats.totalAttempts += attempts;
      if (attempts === 0) {
        status.recoveryStats.successfulRecoveries++;
      } else {
        status.recoveryStats.failedRecoveries++;
      }
    }
    
    return status;
  }

  async start() {
    this.log('Starting Enhanced PM2 Redundancy Manager...');
    
    try {
      // Start backup processes
      await this.startBackupProcesses();
      
      // Start redundancy processes
      await this.startRedundancyProcesses();
      
      // Start monitoring
      await this.monitorAndRecover();
      
      this.log('Enhanced PM2 Redundancy Manager started successfully');
      
      // Keep the process alive
      setInterval(() => {
        // Heartbeat
      }, 60000);
      
    } catch (error) {
      this.log(`Failed to start Enhanced PM2 Redundancy Manager: ${error.message}`, 'ERROR');
      throw error;
    }
  }
    
    return report;
  }

  async restart() {
    this.log('Restarting Enhanced PM2 Redundancy Manager...');
    await this.stop();
    await new Promise(resolve => setTimeout(resolve, 5000));
    await this.start();
  }
}

// CLI interface
if (require.main === module) {
  const manager = new EnhancedPM2RedundancyManager();
  const command = process.argv[2] || 'start';
  
  (async () => {
    try {
      switch (command) {
        case 'start':
          await manager.start();
          break;
        case 'stop':
          await manager.stop();
          break;
        case 'status':
          await manager.status();
          break;
        case 'restart':
          await manager.restart();
          break;
        case 'report':
          await manager.generateHealthReport();
          break;
        default:
          console.log('Usage: node enhanced-pm2-redundancy-manager.cjs [start|stop|status|restart|report]');
      }
    } catch (error) {
      console.error(`Error: ${error.message}`);
      process.exit(1);
    }
  })();
}

module.exports = EnhancedPM2RedundancyManager;
=======
}

// Export for use in other modules
module.exports = { EnhancedPM2RedundancyManager };

// If run directly, start the manager
if (require.main === module) {
  const manager = new EnhancedPM2RedundancyManager();
  manager.start().catch(error => {
    console.error('Failed to start Enhanced PM2 Redundancy Manager:', error);
    process.exit(1);
  });
}
=======
    const logMessage = `[${timestamp}] [${level}] [ENHANCED-PM2] ${message}`;
    console.log(logMessage);
    
    const logFile = path.join(this.logDir, 'enhanced-pm2-redundancy.log');
    fs.appendFileSync(logFile, logMessage + '\n');
  }

  runCommand(command, args = [], options = {}) {
    const result = spawnSync(command, args, {
      cwd: process.cwd(),
      env: process.env,
      shell: false,
      encoding: 'utf8',
      maxBuffer: 1024 * 1024 * 10
    });
    return {
      status: result.status,
      stdout: result.stdout || '',
      stderr: result.stderr || '',
      success: result.status === 0
    };
  }

  async checkPM2Status() {
    this.log('Checking PM2 status...');
    const result = this.runCommand('pm2', ['status', '--no-daemon']);
    
    if (!result.success) {
      this.log(`PM2 status check failed: ${result.stderr}`, 'ERROR');
      return false;
    }

    const processes = this.parsePM2Status(result.stdout);
    this.log(`Found ${processes.length} PM2 processes`);
    return processes;
  }

  parsePM2Status(output) {
    const lines = output.split('\n');
    const processes = [];
    
    for (const line of lines) {
      if (line.includes('│') && !line.includes('App name')) {
        const parts = line.split('│').map(p => p.trim()).filter(p => p);
        if (parts.length >= 4) {
          processes.push({
            name: parts[0],
            status: parts[1],
            cpu: parts[2],
            memory: parts[3],
            uptime: parts[4] || 'N/A'
          });
        }
      }
    }
    
    return processes;
  }

  async startAllBackupProcesses() {
    this.log('Starting all enhanced backup PM2 processes...');
    
    // Start backup auto-sync processes
    await this.startBackupAutoSync();
    await this.startBackupAutoSyncEnhanced();
    
    // Start backup cron processes
    await this.startBackupCron();
    await this.startBackupCronEnhanced();
    
    // Start backup monitoring processes
    await this.startBackupMonitoring();
    await this.startBackupMonitoringEnhanced();
    
    // Start backup build processes
    await this.startBackupBuildProcesses();
    
    // Start backup git sync processes
    await this.startBackupGitSync();
    
    // Start backup marketing sync processes
    await this.startBackupMarketingSync();
  }

  async startBackupAutoSync() {
    const scriptPath = path.join(process.cwd(), 'automation', 'pm2-auto-sync.js');
    
    if (!fs.existsSync(scriptPath)) {
      this.log(`Script not found: ${scriptPath}`, 'ERROR');
      return false;
    }

    const processName = 'zion-auto-sync-backup';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'true',
      '--max-restarts', '15',
      '--exp-backoff-restart-delay', '1000',
      '--env', 'NODE_ENV=production',
      '--env', 'AUTO_SYNC_REMOTE=origin',
      '--env', 'AUTO_SYNC_BRANCH=main',
      '--env', 'AUTO_SYNC_STRATEGY=hardreset',
      '--env', 'AUTO_SYNC_CLEAN=1',
      '--env', 'AUTO_SYNC_GC=0'
    ]);

    if (result.success) {
      this.log(`Started backup auto-sync process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'auto-sync',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start backup auto-sync: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startBackupAutoSyncEnhanced() {
    const scriptPath = path.join(process.cwd(), 'automation', 'pm2-auto-sync.js');
    
    if (!fs.existsSync(scriptPath)) {
      this.log(`Script not found: ${scriptPath}`, 'ERROR');
      return false;
    }

    const processName = 'zion-auto-sync-backup-enhanced';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'true',
      '--max-restarts', '20',
      '--exp-backoff-restart-delay', '2000',
      '--env', 'NODE_ENV=production',
      '--env', 'AUTO_SYNC_REMOTE=origin',
      '--env', 'AUTO_SYNC_BRANCH=main',
      '--env', 'AUTO_SYNC_STRATEGY=hardreset',
      '--env', 'AUTO_SYNC_CLEAN=1',
      '--env', 'AUTO_SYNC_GC=1'
    ]);

    if (result.success) {
      this.log(`Started enhanced backup auto-sync process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'auto-sync-enhanced',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start enhanced backup auto-sync: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startBackupCron() {
    const scriptPath = path.join(process.cwd(), 'automation', 'pm2-auto-sync.js');
    
    if (!fs.existsSync(scriptPath)) {
      this.log(`Script not found: ${scriptPath}`, 'ERROR');
      return false;
    }

    const processName = 'zion-auto-sync-cron-backup';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'false',
      '--instances', '1',
      '--cron-restart', '*/15 * * * *',
      '--env', 'NODE_ENV=production',
      '--env', 'AUTO_SYNC_REMOTE=origin',
      '--env', 'AUTO_SYNC_BRANCH=main',
      '--env', 'AUTO_SYNC_STRATEGY=hardreset',
      '--env', 'AUTO_SYNC_CLEAN=0',
      '--env', 'AUTO_SYNC_GC=0'
    ]);

    if (result.success) {
      this.log(`Started backup cron process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'cron',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start backup cron: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startBackupCronEnhanced() {
    const scriptPath = path.join(process.cwd(), 'automation', 'pm2-auto-sync.js');
    
    if (!fs.existsSync(scriptPath)) {
      this.log(`Script not found: ${scriptPath}`, 'ERROR');
      return false;
    }

    const processName = 'zion-auto-sync-cron-backup-enhanced';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'false',
      '--instances', '1',
      '--cron-restart', '*/20 * * * *',
      '--env', 'NODE_ENV=production',
      '--env', 'AUTO_SYNC_REMOTE=origin',
      '--env', 'AUTO_SYNC_BRANCH=main',
      '--env', 'AUTO_SYNC_STRATEGY=hardreset',
      '--env', 'AUTO_SYNC_CLEAN=0',
      '--env', 'AUTO_SYNC_GC=1'
    ]);

    if (result.success) {
      this.log(`Started enhanced backup cron process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'cron-enhanced',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start enhanced backup cron: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startBackupMonitoring() {
    const processName = 'zion-monitoring-backup';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    // Create a simple monitoring script
    const monitoringScript = `
#!/usr/bin/env node
const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function log(message) {
  const timestamp = new Date().toISOString();
  console.log(\`[\${timestamp}] [MONITORING] \${message}\`);
}

function checkProcessHealth() {
  const result = spawnSync('pm2', ['status', '--no-daemon'], {
    cwd: process.cwd(),
    encoding: 'utf8'
  });
  
  if (result.status === 0) {
    log('PM2 processes health check completed');
  } else {
    log('PM2 health check failed');
  }
}

// Run health check every 5 minutes
setInterval(checkProcessHealth, 5 * 60 * 1000);
checkProcessHealth(); // Initial check

log('Backup monitoring process started');
`;

    const scriptPath = path.join(process.cwd(), 'automation', 'backup-monitoring.js');
    fs.writeFileSync(scriptPath, monitoringScript);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'true',
      '--max-restarts', '10'
    ]);

    if (result.success) {
      this.log(`Started backup monitoring process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'monitoring',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start backup monitoring: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startBackupMonitoringEnhanced() {
    const processName = 'zion-monitoring-backup-enhanced';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    // Create an enhanced monitoring script
    const enhancedMonitoringScript = `
#!/usr/bin/env node
const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function log(message) {
  const timestamp = new Date().toISOString();
  console.log(\`[\${timestamp}] [ENHANCED-MONITORING] \${message}\`);
}

function checkProcessHealth() {
  const result = spawnSync('pm2', ['status', '--no-daemon'], {
    cwd: process.cwd(),
    encoding: 'utf8'
  });
  
  if (result.status === 0) {
    log('Enhanced PM2 processes health check completed');
    
    // Check for failed processes and restart them
    const output = result.stdout;
    const lines = output.split('\\n');
    
    for (const line of lines) {
      if (line.includes('│') && line.includes('errored')) {
        const processName = line.split('│')[0].trim();
        log(\`Found errored process: \${processName}, attempting restart\`);
        spawnSync('pm2', ['restart', processName], { cwd: process.cwd() });
      }
    }
  } else {
    log('Enhanced PM2 health check failed');
  }
}

// Run health check every 3 minutes
setInterval(checkProcessHealth, 3 * 60 * 1000);
checkProcessHealth(); // Initial check

log('Enhanced backup monitoring process started');
`;

    const scriptPath = path.join(process.cwd(), 'automation', 'enhanced-backup-monitoring.js');
    fs.writeFileSync(scriptPath, enhancedMonitoringScript);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'true',
      '--max-restarts', '15'
    ]);

    if (result.success) {
      this.log(`Started enhanced backup monitoring process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'monitoring-enhanced',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start enhanced backup monitoring: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startBackupBuildProcesses() {
    const processName = 'zion-build-backup';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    // Create a build monitoring script
    const buildScript = `
#!/usr/bin/env node
const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function log(message) {
  const timestamp = new Date().toISOString();
  console.log(\`[\${timestamp}] [BUILD-BACKUP] \${message}\`);
}

function checkBuildHealth() {
  log('Checking build health...');
  
  // Check if build artifacts exist
  const nextDir = path.join(process.cwd(), '.next');
  const outDir = path.join(process.cwd(), 'out');
  
  if (!fs.existsSync(nextDir) && !fs.existsSync(outDir)) {
    log('No build artifacts found, triggering build health check');
    try {
      spawnSync('npm', ['run', 'build:health-check'], {
        cwd: process.cwd(),
        stdio: 'inherit'
      });
    } catch (error) {
      log(\`Build health check failed: \${error.message}\`);
    }
  } else {
    log('Build artifacts found, build health OK');
  }
}

// Run build health check every 30 minutes
setInterval(checkBuildHealth, 30 * 60 * 1000);
checkBuildHealth(); // Initial check

log('Backup build process started');
`;

    const scriptPath = path.join(process.cwd(), 'automation', 'backup-build.js');
    fs.writeFileSync(scriptPath, buildScript);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'true',
      '--max-restarts', '8'
    ]);

    if (result.success) {
      this.log(`Started backup build process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'build',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start backup build process: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startBackupGitSync() {
    const scriptPath = path.join(process.cwd(), 'automation', 'git-sync.cjs');
    
    if (!fs.existsSync(scriptPath)) {
      this.log(`Script not found: ${scriptPath}`, 'ERROR');
      return false;
    }

    const processName = 'zion-git-sync-backup';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'true',
      '--max-restarts', '12',
      '--cron-restart', '*/25 * * * *'
    ]);

    if (result.success) {
      this.log(`Started backup git sync process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'git-sync',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start backup git sync: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startBackupMarketingSync() {
    const scriptPath = path.join(process.cwd(), 'automation', 'marketing-sync.js');
    
    if (!fs.existsSync(scriptPath)) {
      this.log(`Script not found: ${scriptPath}`, 'ERROR');
      return false;
    }

    const processName = 'zion-marketing-sync-backup';
    
    // Stop existing backup process if running
    this.runCommand('pm2', ['stop', processName]);
    this.runCommand('pm2', ['delete', processName]);

    const result = this.runCommand('pm2', [
      'start', scriptPath,
      '--name', processName,
      '--interpreter', 'node',
      '--cwd', process.cwd(),
      '--watch', 'false',
      '--autorestart', 'true',
      '--max-restarts', '10',
      '--cron-restart', '0 */6 * * *'
    ]);

    if (result.success) {
      this.log(`Started backup marketing sync process: ${processName}`);
      this.backupProcesses.set(processName, {
        type: 'marketing-sync',
        started: new Date(),
        status: 'running'
      });
      return true;
    } else {
      this.log(`Failed to start backup marketing sync: ${result.stderr}`, 'ERROR');
      return false;
    }
  }

  async startHealthMonitoring() {
    this.log('Starting health monitoring for backup processes...');
    
    // Monitor process health every 3 minutes
    cron.schedule('*/3 * * * *', async () => {
      await this.checkBackupProcessHealth();
    });

    // Full health check every 15 minutes
    cron.schedule('*/15 * * * *', async () => {
      await this.fullHealthCheck();
    });
  }

  async checkBackupProcessHealth() {
    const processes = await this.checkPM2Status();
    if (!processes) return;

    for (const process of processes) {
      if (process.name.includes('backup') || process.name.includes('enhanced')) {
        if (process.status === 'errored' || process.status === 'stopped') {
          this.log(`Backup process ${process.name} is ${process.status}, attempting recovery`, 'WARN');
          await this.recoverProcess(process.name);
        }
      }
    }
  }

  async recoverProcess(processName) {
    this.log(`Attempting to recover process: ${processName}`);
    
    const recoveryCount = this.recoveryAttempts.get(processName) || 0;
    if (recoveryCount >= 3) {
      this.log(`Max recovery attempts reached for ${processName}`, 'ERROR');
      return false;
    }

    this.recoveryAttempts.set(processName, recoveryCount + 1);
    
    // Restart the process
    const result = this.runCommand('pm2', ['restart', processName]);
    if (result.success) {
      this.log(`Successfully recovered process: ${processName}`);
      this.recoveryAttempts.set(processName, 0); // Reset counter
      return true;
    } else {
      this.log(`Failed to recover process: ${processName}`, 'ERROR');
      return false;
    }
  }

  async fullHealthCheck() {
    this.log('Running full health check...');
    
    const processes = await this.checkPM2Status();
    if (!processes) return;

    let healthyCount = 0;
    let totalCount = 0;

    for (const process of processes) {
      if (process.name.includes('backup') || process.name.includes('enhanced')) {
        totalCount++;
        if (process.status === 'online') {
          healthyCount++;
        }
      }
    }

    const healthPercentage = totalCount > 0 ? (healthyCount / totalCount) * 100 : 0;
    this.log(`Backup processes health: ${healthyCount}/${totalCount} (${healthPercentage.toFixed(1)}%)`);

    if (healthPercentage < 80) {
      this.log('Backup processes health below threshold, triggering recovery', 'WARN');
      await this.triggerRecovery();
    }
  }

  async triggerRecovery() {
    this.log('Triggering comprehensive recovery...');
    
    // Restart all backup processes
    for (const [name, info] of this.backupProcesses) {
      if (info.status !== 'running') {
        this.log(`Restarting ${name}...`);
        this.runCommand('pm2', ['restart', name]);
      }
    }
  }

  async getStatus() {
    const processes = await this.checkPM2Status();
    if (!processes) return { error: 'Failed to get PM2 status' };

    const backupProcesses = processes.filter(p => 
      p.name.includes('backup') || p.name.includes('enhanced')
    );

    return {
      totalBackupProcesses: backupProcesses.length,
      healthyProcesses: backupProcesses.filter(p => p.status === 'online').length,
      processes: backupProcesses,
      recoveryAttempts: Object.fromEntries(this.recoveryAttempts),
      lastHealthCheck: new Date().toISOString()
    };
  }

  async stopAllBackupProcesses() {
    this.log('Stopping all backup processes...');
    
    for (const [name, info] of this.backupProcesses) {
      this.log(`Stopping ${name}...`);
      this.runCommand('pm2', ['stop', name]);
      this.runCommand('pm2', ['delete', name]);
    }
    
    this.backupProcesses.clear();
    this.log('All backup processes stopped');
  }
}

module.exports = EnhancedPM2RedundancyManager;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-a700
