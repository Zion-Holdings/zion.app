#!/usr/bin/env node
"use strict";

<<<<<<< HEAD
const { spawnSync, execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

class NetlifyFunctionsRedundancyManager {
  constructor() {
    this.config = {
      // Netlify functions configuration
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        functionsDir: "netlify/functions",
        criticalFunctions: [
          "netlify-auto-healer-runner",
          "continuous-orchestrator",
          "automation-matrix",
          "maintenance-scheduler",
          "netlify-auto-healer-runner",
          "continuous-front-runner",
          "front-index-orchestrator",
          "homepage-updater",
          "marketing-scheduler",
          "link-and-health-scheduler"
        ],
        healthCheckInterval: 120000, // 2 minutes
        maxFailureThreshold: 2
      },
      
      // Backup npm scripts for Netlify operations
      backupScripts: {
        trigger: [
          "netlify:trigger",
          "netlify:manifest"
        ],
        build: [
          "build",
          "build:smart",
          "build:orchestrator"
        ],
        deploy: [
          "export",
          "start"
        ]
      },
      
      // Function execution scripts
      functionScripts: {
        "netlify-auto-healer-runner": "automation/enhanced-netlify-healer.cjs",
        "continuous-orchestrator": "automation/continuous-orchestrator.cjs",
        "automation-matrix": "automation/automation-matrix.cjs",
        "maintenance-scheduler": "automation/maintenance-scheduler.cjs",
        "continuous-front-runner": "automation/continuous-front-runner.cjs",
        "front-index-orchestrator": "automation/front-index-orchestrator.cjs",
        "homepage-updater": "automation/homepage-updater.cjs",
        "marketing-scheduler": "automation/marketing-scheduler.cjs",
        "link-and-health-scheduler": "automation/link-and-health-scheduler.cjs"
      },
      
      // Health check configuration
      healthCheck: {
        interval: 120000, // 2 minutes
        maxFailureThreshold: 2,
        functionValidation: true,
        manifestValidation: true
      },
      
      // Logging configuration
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024, // 10MB
        maxLogFiles: 30
      }
    };
    
    this.ensureLogDirectory();
    this.functionStatus = new Map();
    this.failureCounts = new Map();
    this.lastRunTimes = new Map();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
=======
const fs = require("fs");
const path = require("path");
const { spawnSync } = require("child_process");

class NetlifyFunctionsRedundancyManager {
  constructor() {
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "netlify-functions-redundancy.log");
    this.ensureLogDir();
    
    this.config = {
      // Netlify functions directory
      functionsDir: path.join(this.workspace, "netlify/functions"),
      
      // Functions manifest file
      manifestFile: "functions-manifest.json",
      
      // Expected functions based on the manifest
      expectedFunctions: [
        "a11y-alt-text-runner",
        "adaptive-orchestrator",
        "ai-changelog-runner",
        "ai-trends-radar-runner",
        "anchor-links-auto-fixer",
        "auto-discovery-runner",
        "auto-scheduler",
        "automation-matrix",
        "autonomous-invention-orchestrator",
        "autonomous-meta-orchestrator",
        "broken-image-scanner",
        "broken-image-scanner-runner",
        "canonical-auditor",
        "cloud_deep_research",
        "cloud_orchestrator",
        "code-smell-audit-runner",
        "component-coupling-graph-runner",
        "component-props-docs-runner",
        "component-size-report",
        "content-freshness-score-runner",
        "continuous-front-runner",
        "continuous-orchestrator",
        "dead-code-audit",
        "dead-code-report",
        "deps-auto-upgrade-runner",
        "docs-index-runner",
        "docs-search-index-runner",
        "duplicate-media-finder-runner",
        "external-link-check-runner",
        "fast-front-promoter",
        "fast-orchestrator",
        "feature-advertiser",
        "features-capabilities-benefits-advertiser",
        "front-ads-promoter",
        "front-enhancer",
        "front-index-futurizer",
        "front-index-orchestrator",
        "front-index-scheduler",
        "front-maximizer",
        "front-visionary-expander",
        "frontpage-enhancer",
        "frontpage-scheduler",
        "headers-enforcer",
        "home-visionary-expander",
        "homepage-advertiser-scheduler",
        "homepage-enhancer",
        "homepage-updater",
        "homepage-updater-scheduler",
        "homepage_advertiser",
        "hyper-front-index-accelerator",
        "image-optimizer-runner",
        "innovation-lab",
        "innovations-promoter",
        "intelligent-meta-orchestrator",
        "internal-link-graph-runner",
        "knowledge-pack-runner",
        "license-compliance-auditor",
        "link-and-health-scheduler",
        "link-crawler",
        "maintenance-scheduler",
        "marketing-and-features-promo",
        "marketing-scheduler",
        "media-og-and-optimize",
        "metadata-optimizer-runner",
        "netlify-auto-healer-runner",
        "newsroom-auto-publisher",
        "newsroom-runner",
        "og-image-update-runner",
        "orphan-pages-detector",
        "pagespeed-insights-runner",
        "readme-advertiser",
        "repo-knowledge-graph-runner",
        "repo-radar-and-graph",
        "repo-radar-runner",
        "revenue-ideas-lab",
        "roadmap-curator",
        "robots-auditor",
        "schedule-content-index",
        "schedule-homepage",
        "schedule-knowledge-graph",
        "schedule-site-health",
        "security-audit",
        "security-audit-runner",
        "seo-audit-runner",
        "site-404-map-runner",
        "site-crawler",
        "sitemap_runner",
        "stale-content-auditor-runner",
        "todo-scanner-runner",
        "todo-summary-runner",
        "topic-cluster-builder-runner",
        "topics-map-runner",
        "trigger-all-and-commit",
        "ui-enhancer",
        "ultrafast-front-orchestrator",
        "ultrafast-orchestrator",
        "unused-media-scanner"
      ],
      
      // Function validation rules
      validationRules: {
        requiredExports: ["exports.handler", "module.exports"],
        maxFileSize: 100 * 1024, // 100KB
        maxFunctionDuration: 30000, // 30 seconds
        requiredStructure: ["function", "async", "await"]
      },
      
      // Monitoring intervals
      intervals: {
        functionHealth: 120000,     // 2 minutes
        manifestValidation: 300000, // 5 minutes
        overallHealth: 900000       // 15 minutes
      },
      
      // Recovery settings
      recovery: {
        maxAttempts: 3,
        retryDelay: 15000,          // 15 seconds
        regenerateManifest: true
      }
    };
    
    this.monitoring = false;
    this.checkIntervals = new Map();
    this.functionHealth = new Map();
    this.manifestStatus = new Map();
    this.recoveryAttempts = new Map();
    this.lastManifestRegeneration = new Date();
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-e3e4
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `netlify-functions-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
=======
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-e3e4
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
<<<<<<< HEAD
        cwd: process.cwd(),
=======
        cwd: this.workspace,
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-e3e4
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
<<<<<<< HEAD
=======
        timeout: options.timeout || 30000,
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-e3e4
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  validateManifestFile() {
    try {
      if (!fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        return { valid: false, error: "Manifest file not found" };
      }
      
      const content = fs.readFileSync(this.config.netlifyFunctions.manifestFile, 'utf8');
      
      try {
        const manifest = JSON.parse(content);
        
        if (!manifest.functions || !Array.isArray(manifest.functions)) {
          return { valid: false, error: "Invalid functions array in manifest" };
        }
        
        if (!manifest.generatedAt) {
          return { valid: false, error: "Missing generation timestamp" };
        }
        
        return { valid: true, manifest };
      } catch (jsonError) {
        return { valid: false, error: `JSON parsing error: ${jsonError.message}` };
      }
    } catch (error) {
      return { valid: false, error: `File read error: ${error.message}` };
    }
  }

  async checkFunctionHealth(functionName) {
    this.log(`Checking function health: ${functionName}`);
    
    try {
      // Check if function exists in manifest
      const manifestValidation = this.validateManifestFile();
      if (!manifestValidation.valid) {
        this.log(`Manifest validation failed: ${manifestValidation.error}`, "ERROR");
        return false;
      }
      
      const manifest = manifestValidation.manifest;
      const functionExists = manifest.functions.includes(functionName);
      
      if (!functionExists) {
        this.log(`Function ${functionName} not found in manifest`, "WARN");
        return false;
      }
      
      // Check if function file exists
      const functionFile = path.join(this.config.netlifyFunctions.functionsDir, `${functionName}.js`);
      if (!fs.existsSync(functionFile)) {
        this.log(`Function file not found: ${functionFile}`, "ERROR");
        return false;
      }
      
      // Check if function has a backup script
      const backupScript = this.config.functionScripts[functionName];
      if (backupScript && fs.existsSync(backupScript)) {
        this.log(`Function ${functionName} has backup script: ${backupScript}`);
      }
      
      this.log(`Function ${functionName} is healthy`);
      return true;
    } catch (error) {
      this.log(`Error checking function ${functionName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkAllFunctions() {
    this.log("Checking health of all Netlify functions...");
    
    const results = {};
    let allHealthy = true;
    
    for (const functionName of this.config.netlifyFunctions.criticalFunctions) {
      const isHealthy = await this.checkFunctionHealth(functionName);
      results[functionName] = isHealthy;
      
      if (!isHealthy) {
        allHealthy = false;
        this.failureCounts.set(functionName, (this.failureCounts.get(functionName) || 0) + 1);
      } else {
        this.failureCounts.set(functionName, 0);
      }
      
      this.functionStatus.set(functionName, {
        healthy: isHealthy,
        lastCheck: new Date().toISOString(),
        failureCount: this.failureCounts.get(functionName) || 0
      });
    }
    
    if (allHealthy) {
      this.log("All Netlify functions are healthy");
    } else {
      this.log("Some Netlify functions are unhealthy, check logs for details", "WARN");
    }
    
    return results;
  }

  async executeFunction(functionName) {
    this.log(`Executing function: ${functionName}`);
    
    try {
      // Try to execute the function directly if it exists
      const functionFile = path.join(this.config.netlifyFunctions.functionsDir, `${functionName}.js`);
      if (fs.existsSync(functionFile)) {
        const result = await this.runCommand("node", [functionFile]);
        if (result.status === 0) {
          this.log(`Successfully executed function ${functionName}`);
          this.lastRunTimes.set(functionName, new Date().toISOString());
          return true;
        }
      }
      
      // Try backup script
      const backupScript = this.config.functionScripts[functionName];
      if (backupScript && fs.existsSync(backupScript)) {
        const result = await this.runCommand("node", [backupScript]);
        if (result.status === 0) {
          this.log(`Successfully executed backup script for ${functionName}: ${backupScript}`);
          this.lastRunTimes.set(functionName, new Date().toISOString());
          return true;
        }
      }
      
      // Try npm scripts as backup
      for (const script of this.config.backupScripts.trigger) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Successfully executed backup script: ${script}`);
            return true;
          }
        } catch (error) {
          this.log(`Error running backup script ${script}: ${error.message}`, "WARN");
        }
      }
      
      this.log(`Failed to execute function ${functionName} with all methods`, "ERROR");
      return false;
    } catch (error) {
      this.log(`Error executing function ${functionName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async executeAllFunctions() {
    this.log("Executing all Netlify functions...");
    
    const results = {};
    
    for (const functionName of this.config.netlifyFunctions.criticalFunctions) {
      const success = await this.executeFunction(functionName);
      results[functionName] = success;
      
      if (success) {
        this.log(`Successfully executed function: ${functionName}`);
      } else {
        this.log(`Failed to execute function: ${functionName}`, "ERROR");
      }
      
      // Add delay between executions
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
    
    return results;
  }

  async testBackupScripts() {
    this.log("Testing backup scripts...");
    
    const results = {};
    
    for (const category in this.config.backupScripts) {
      results[category] = {};
      
      for (const script of this.config.backupScripts[category]) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          results[category][script] = {
            success: result.status === 0,
            status: result.status,
            output: result.stdout
          };
          
          if (result.status === 0) {
            this.log(`Backup script ${script} is working`);
          } else {
            this.log(`Backup script ${script} failed`, "WARN");
          }
        } catch (error) {
          results[category][script] = {
            success: false,
            error: error.message
          };
          this.log(`Error testing backup script ${script}: ${error.message}`, "ERROR");
        }
      }
    }
    
    return results;
  }

  async regenerateManifest() {
    this.log("Regenerating Netlify functions manifest...");
    
    try {
      // Try npm script first
      let result = await this.runCommand("npm", ["run", "netlify:manifest"]);
      
      if (result.status === 0) {
        this.log("Successfully regenerated manifest via npm script");
        return true;
      }
      
      // Try direct script execution
      const manifestScript = "scripts/generate-netlify-functions-manifest.cjs";
      if (fs.existsSync(manifestScript)) {
        result = await this.runCommand("node", [manifestScript]);
        if (result.status === 0) {
          this.log("Successfully regenerated manifest via direct script");
          return true;
        }
      }
      
      // Try to manually create a basic manifest
      this.log("Attempting to create basic manifest manually", "WARN");
      
      const functionsDir = this.config.netlifyFunctions.functionsDir;
      if (fs.existsSync(functionsDir)) {
        const functions = fs.readdirSync(functionsDir)
          .filter(file => file.endsWith('.js'))
          .map(file => file.replace('.js', ''));
        
        const manifest = {
          generatedAt: new Date().toISOString(),
          functions: functions
        };
        
        const manifestContent = JSON.stringify(manifest, null, 2);
        fs.writeFileSync(this.config.netlifyFunctions.manifestFile, manifestContent);
        
        this.log("Successfully created basic manifest manually");
        return true;
      }
      
      this.log("Failed to regenerate manifest with all methods", "ERROR");
      return false;
    } catch (error) {
      this.log(`Error regenerating manifest: ${error.message}`, "ERROR");
      return false;
    }
  }

  async triggerNetlifyDeploy() {
    this.log("Triggering Netlify deployment...");
    
    try {
      // Try npm scripts first
      for (const script of this.config.backupScripts.trigger) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Successfully triggered deployment via script: ${script}`);
            return true;
          }
        } catch (error) {
          this.log(`Error running trigger script ${script}: ${error.message}`, "WARN");
        }
      }
      
      // Try build commands
      for (const script of this.config.backupScripts.build) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Successfully triggered build via script: ${script}`);
            return true;
          }
        } catch (error) {
          this.log(`Error running build script ${script}: ${error.message}`, "WARN");
        }
      }
      
      this.log("Failed to trigger Netlify deployment with all methods", "ERROR");
      return false;
    } catch (error) {
      this.log(`Error triggering Netlify deployment: ${error.message}`, "ERROR");
      return false;
    }
  }

  async generateHealthReport() {
    const report = {
      timestamp: new Date().toISOString(),
      functions: {},
      backupScripts: {},
      manifest: this.validateManifestFile(),
      summary: {
        totalFunctions: this.config.netlifyFunctions.criticalFunctions.length,
        healthyFunctions: 0,
        unhealthyFunctions: 0,
        lastRunTimes: Object.fromEntries(this.lastRunTimes)
      }
    };
    
    // Function status
    for (const [functionName, status] of this.functionStatus) {
      report.functions[functionName] = status;
      
      if (status.healthy) {
        report.summary.healthyFunctions++;
      } else {
        report.summary.unhealthyFunctions++;
      }
    }
    
    // Test backup scripts
    report.backupScripts = await this.testBackupScripts();
    
    const reportFile = path.join(this.config.logging.logDir, `netlify-functions-health-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    this.log(`Health report generated: ${reportFile}`);
    return report;
  }

  async startMonitoring() {
    this.log("Starting Netlify functions redundancy monitoring...");
    
    // Initial health check
    await this.checkAllFunctions();
    
    // Set up periodic health checks
    setInterval(async () => {
      await this.checkAllFunctions();
    }, this.config.healthCheck.interval);
    
    // Set up periodic function execution
    setInterval(async () => {
      await this.executeAllFunctions();
    }, 600000); // 10 minutes
    
    // Set up periodic manifest regeneration
    setInterval(async () => {
      await this.regenerateManifest();
    }, 1800000); // 30 minutes
    
    // Set up periodic report generation
    setInterval(async () => {
      await this.generateHealthReport();
    }, 600000); // 10 minutes
    
    this.log("Netlify functions redundancy monitoring started");
  }

  async start() {
    this.log("Starting Netlify Functions Redundancy Manager...");
    
    try {
      // Check all functions
      await this.checkAllFunctions();
      
      // Regenerate manifest if needed
      const manifestValidation = this.validateManifestFile();
      if (!manifestValidation.valid) {
        this.log("Manifest is invalid, attempting to regenerate", "WARN");
        await this.regenerateManifest();
      }
      
      // Test backup scripts
      await this.testBackupScripts();
      
      // Start monitoring
      await this.startMonitoring();
      
      this.log("Netlify Functions Redundancy Manager started successfully");
      
      // Keep the process running
      setInterval(() => {
        this.log("Netlify Functions Redundancy Manager heartbeat");
      }, 300000); // 5 minutes
      
    } catch (error) {
      this.log(`Error starting Netlify Functions Redundancy Manager: ${error.message}`, "ERROR");
      process.exit(1);
    }
  }
=======
  // Check if functions directory exists
  checkFunctionsDirectory() {
    if (!fs.existsSync(this.config.functionsDir)) {
      this.log("Netlify functions directory not found", "ERROR");
      return false;
    }
    return true;
  }

  // Get list of existing function files
  getExistingFunctions() {
    try {
      if (!this.checkFunctionsDirectory()) {
        return [];
      }
      
      const files = fs.readdirSync(this.config.functionsDir);
      return files.filter(file => file.endsWith('.js') || file.endsWith('.mjs'));
    } catch (error) {
      this.log(`Failed to read functions directory: ${error.message}`, "ERROR");
      return [];
    }
  }

  // Validate individual function
  validateFunction(functionName) {
    try {
      const functionPath = path.join(this.config.functionsDir, `${functionName}.js`);
      
      if (!fs.existsSync(functionPath)) {
        return {
          valid: false,
          errors: [`Function file not found: ${functionName}.js`]
        };
      }
      
      const stats = fs.statSync(functionPath);
      const content = fs.readFileSync(functionPath, "utf8");
      
      const validation = {
        valid: true,
        errors: [],
        warnings: [],
        info: {
          size: stats.size,
          lastModified: stats.mtime,
          lines: content.split('\n').length
        }
      };
      
      // Check file size
      if (stats.size > this.config.validationRules.maxFileSize) {
        validation.warnings.push(`File size (${stats.size} bytes) exceeds recommended limit`);
      }
      
      // Check for required exports
      let hasValidExport = false;
      for (const exportPattern of this.config.validationRules.requiredExports) {
        if (content.includes(exportPattern)) {
          hasValidExport = true;
          break;
        }
      }
      
      if (!hasValidExport) {
        validation.errors.push("Missing required export (exports.handler or module.exports)");
        validation.valid = false;
      }
      
      // Check for basic function structure
      if (!content.includes('function') && !content.includes('=>')) {
        validation.warnings.push("File may not contain function definitions");
      }
      
      // Check for async/await usage (recommended for Netlify functions)
      if (!content.includes('async') && !content.includes('await')) {
        validation.warnings.push("Function may not be async (recommended for Netlify)");
      }
      
      // Check for common Netlify function patterns
      if (!content.includes('exports.handler') && !content.includes('module.exports')) {
        validation.errors.push("Missing Netlify function handler export");
        validation.valid = false;
      }
      
      // Check for proper error handling
      if (!content.includes('try') && !content.includes('catch')) {
        validation.warnings.push("Function may lack proper error handling");
      }
      
      // Check for proper response format
      if (!content.includes('statusCode') && !content.includes('body')) {
        validation.warnings.push("Function may not return proper Netlify response format");
      }
      
      return validation;
      
    } catch (error) {
      return {
        valid: false,
        errors: [`Validation failed: ${error.message}`]
      };
    }
  }

  // Validate functions manifest
  validateFunctionsManifest() {
    try {
      this.log("Validating functions manifest", "INFO");
      
      const manifestPath = path.join(this.config.functionsDir, this.config.manifestFile);
      
      if (!fs.existsSync(manifestPath)) {
        this.log("Functions manifest not found", "WARN");
        return {
          valid: false,
          errors: ["Functions manifest not found"],
          manifest: null
        };
      }
      
      const manifestContent = fs.readFileSync(manifestPath, "utf8");
      let manifest;
      
      try {
        manifest = JSON.parse(manifestContent);
      } catch (error) {
        return {
          valid: false,
          errors: [`Invalid JSON in manifest: ${error.message}`],
          manifest: null
        };
      }
      
      const validation = {
        valid: true,
        errors: [],
        warnings: [],
        manifest: manifest
      };
      
      // Check required manifest fields
      if (!manifest.functions || !Array.isArray(manifest.functions)) {
        validation.errors.push("Manifest missing or invalid functions array");
        validation.valid = false;
      }
      
      if (!manifest.generatedAt) {
        validation.warnings.push("Manifest missing generation timestamp");
      }
      
      // Check if manifest functions match expected functions
      if (manifest.functions) {
        const missingFunctions = this.config.expectedFunctions.filter(
          expected => !manifest.functions.includes(expected)
        );
        
        if (missingFunctions.length > 0) {
          validation.warnings.push(`Manifest missing functions: ${missingFunctions.join(', ')}`);
        }
        
        const extraFunctions = manifest.functions.filter(
          func => !this.config.expectedFunctions.includes(func)
        );
        
        if (extraFunctions.length > 0) {
          validation.warnings.push(`Manifest contains extra functions: ${extraFunctions.join(', ')}`);
        }
      }
      
      // Check manifest age
      if (manifest.generatedAt) {
        try {
          const generatedAt = new Date(manifest.generatedAt);
          const now = new Date();
          const ageHours = (now - generatedAt) / (1000 * 60 * 60);
          
          if (ageHours > 24) {
            validation.warnings.push(`Manifest is ${ageHours.toFixed(1)} hours old`);
          }
        } catch (error) {
          validation.warnings.push("Could not parse manifest generation time");
        }
      }
      
      this.manifestStatus.set("manifest", validation);
      
      if (validation.valid) {
        this.log("Functions manifest is valid", "INFO");
      } else {
        this.log("Functions manifest has validation issues", "WARN");
      }
      
      return validation;
      
    } catch (error) {
      this.log(`Manifest validation failed: ${error.message}`, "ERROR");
      return {
        valid: false,
        error: error.message,
        manifest: null
      };
    }
  }

  // Regenerate functions manifest
  async regenerateFunctionsManifest() {
    try {
      this.log("Regenerating functions manifest", "INFO");
      
      const manifestScript = path.join(this.workspace, "scripts/generate-netlify-functions-manifest.cjs");
      
      if (!fs.existsSync(manifestScript)) {
        this.log("Manifest generation script not found", "ERROR");
        return false;
      }
      
      const result = await this.runCommand("node", [manifestScript]);
      
      if (result.status === 0) {
        this.log("Functions manifest regenerated successfully", "INFO");
        this.lastManifestRegeneration = new Date();
        return true;
      } else {
        this.log(`Failed to regenerate manifest: ${result.stderr}`, "ERROR");
        return false;
      }
      
    } catch (error) {
      this.log(`Manifest regeneration failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  // Check function file integrity
  async checkFunctionIntegrity() {
    try {
      this.log("Checking function file integrity", "INFO");
      
      const existingFunctions = this.getExistingFunctions();
      const integrityResults = {};
      let overallHealthy = true;
      
      for (const functionName of this.config.expectedFunctions) {
        const functionFile = `${functionName}.js`;
        const functionPath = path.join(this.config.functionsDir, functionFile);
        
        const integrity = {
          exists: fs.existsSync(functionPath),
          accessible: false,
          valid: false,
          issues: []
        };
        
        if (integrity.exists) {
          try {
            // Check if file is readable
            fs.accessSync(functionPath, fs.constants.R_OK);
            integrity.accessible = true;
            
            // Validate function
            const validation = this.validateFunction(functionName);
            integrity.valid = validation.valid;
            
            if (!validation.valid) {
              integrity.issues.push(...validation.errors);
              overallHealthy = false;
            }
            
            if (validation.warnings.length > 0) {
              integrity.issues.push(...validation.warnings);
            }
            
          } catch (error) {
            integrity.issues.push(`File access error: ${error.message}`);
            overallHealthy = false;
          }
        } else {
          integrity.issues.push("Function file not found");
          overallHealthy = false;
        }
        
        integrityResults[functionName] = integrity;
      }
      
      // Check for orphaned function files
      const orphanedFunctions = existingFunctions.filter(
        func => !this.config.expectedFunctions.includes(func.replace('.js', ''))
      );
      
      if (orphanedFunctions.length > 0) {
        integrityResults.orphaned = {
          functions: orphanedFunctions,
          warning: "Found function files not in expected list"
        };
      }
      
      if (overallHealthy) {
        this.log("All function files are healthy", "INFO");
      } else {
        this.log("Some function files have issues", "WARN");
      }
      
      return {
        overall: overallHealthy,
        functions: integrityResults
      };
      
    } catch (error) {
      this.log(`Function integrity check failed: ${error.message}`, "ERROR");
      return {
        overall: false,
        error: error.message
      };
    }
  }

  // Test function execution (basic syntax check)
  async testFunctionExecution(functionName) {
    try {
      const functionPath = path.join(this.config.functionsDir, `${functionName}.js`);
      
      if (!fs.existsSync(functionPath)) {
        return {
          testable: false,
          error: "Function file not found"
        };
      }
      
      // Basic syntax check using Node.js
      const result = await this.runCommand("node", ["--check", functionPath]);
      
      if (result.status === 0) {
        return {
          testable: true,
          syntaxValid: true,
          message: "Function syntax is valid"
        };
      } else {
        return {
          testable: true,
          syntaxValid: false,
          error: result.stderr || "Syntax check failed"
        };
      }
      
    } catch (error) {
      return {
        testable: false,
        error: error.message
      };
    }
  }

  // Perform recovery actions
  async performRecovery() {
    try {
      this.log("Performing Netlify functions recovery", "INFO");
      
      const recoveryResults = {
        timestamp: new Date().toISOString(),
        actions: [],
        success: true
      };
      
      // Check manifest
      const manifestValidation = this.validateFunctionsManifest();
      if (!manifestValidation.valid || !manifestValidation.manifest) {
        this.log("Regenerating functions manifest", "INFO");
        
        const manifestRegenerated = await this.regenerateFunctionsManifest();
        if (manifestRegenerated) {
          recoveryResults.actions.push("Functions manifest regenerated");
        } else {
          recoveryResults.actions.push("Failed to regenerate functions manifest");
          recoveryResults.success = false;
        }
      }
      
      // Check function integrity
      const integrityResults = await this.checkFunctionIntegrity();
      if (!integrityResults.overall) {
        recoveryResults.actions.push("Function integrity issues detected");
        recoveryResults.success = false;
      }
      
      // Test critical functions
      const criticalFunctions = [
        "netlify-auto-healer-runner",
        "continuous-orchestrator",
        "automation-matrix"
      ];
      
      for (const functionName of criticalFunctions) {
        const testResult = await this.testFunctionExecution(functionName);
        if (!testResult.testable || !testResult.syntaxValid) {
          recoveryResults.actions.push(`Critical function ${functionName} has issues`);
          recoveryResults.success = false;
        }
      }
      
      if (recoveryResults.success) {
        this.log("Netlify functions recovery completed successfully", "INFO");
      } else {
        this.log("Netlify functions recovery completed with issues", "WARN");
      }
      
      return recoveryResults;
      
    } catch (error) {
      this.log(`Recovery failed: ${error.message}`, "ERROR");
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Overall health check
  async checkOverallHealth() {
    try {
      this.log("Performing overall Netlify functions health check", "INFO");
      
      // Check functions directory
      if (!this.checkFunctionsDirectory()) {
        return {
          overall: false,
          error: "Functions directory not found"
        };
      }
      
      // Validate manifest
      const manifestValidation = this.validateFunctionsManifest();
      
      // Check function integrity
      const integrityResults = await this.checkFunctionIntegrity();
      
      // Test sample functions
      const sampleFunctions = this.config.expectedFunctions.slice(0, 5); // Test first 5
      const testResults = {};
      
      for (const functionName of sampleFunctions) {
        testResults[functionName] = await this.testFunctionExecution(functionName);
      }
      
      const overallHealth = {
        timestamp: new Date().toISOString(),
        functionsDirectory: true,
        manifest: manifestValidation,
        integrity: integrityResults,
        testResults: testResults,
        overall: manifestValidation.valid && integrityResults.overall
      };
      
      if (overallHealth.overall) {
        this.log("All Netlify functions systems are healthy", "INFO");
      } else {
        this.log("Some Netlify functions systems have issues", "WARN");
        
        // Trigger recovery if needed
        const recoveryAttempts = this.recoveryAttempts.get("overall") || 0;
        if (recoveryAttempts < this.config.recovery.maxAttempts) {
          this.log(`Triggering recovery (attempt ${recoveryAttempts + 1})`, "INFO");
          this.recoveryAttempts.set("overall", recoveryAttempts + 1);
          
          setTimeout(async () => {
            await this.performRecovery();
          }, this.config.recovery.retryDelay);
        } else {
          this.log("Maximum recovery attempts exceeded", "ERROR");
        }
      }
      
      return overallHealth;
      
    } catch (error) {
      this.log(`Overall health check failed: ${error.message}`, "ERROR");
      return {
        overall: false,
        error: error.message
      };
    }
  }

  // Start monitoring
  start() {
    if (this.monitoring) {
      this.log("Monitoring already started", "WARN");
      return;
    }
    
    this.monitoring = true;
    this.log("Starting Netlify functions redundancy monitoring", "INFO");
    
    // Start function health monitoring
    this.checkIntervals.set("function", setInterval(async () => {
      await this.checkFunctionIntegrity();
    }, this.config.intervals.functionHealth));
    
    // Start manifest validation monitoring
    this.checkIntervals.set("manifest", setInterval(async () => {
      this.validateFunctionsManifest();
    }, this.config.intervals.manifestValidation));
    
    // Start overall health monitoring
    this.checkIntervals.set("overall", setInterval(async () => {
      await this.checkOverallHealth();
    }, this.config.intervals.overallHealth));
    
    this.log("Netlify functions redundancy monitoring started", "INFO");
  }

  // Stop monitoring
  stop() {
    if (!this.monitoring) {
      this.log("Monitoring not started", "WARN");
      return;
    }
    
    this.monitoring = false;
    
    // Clear all intervals
    for (const [name, interval] of this.checkIntervals) {
      clearInterval(interval);
      this.log(`Stopped ${name} monitoring`, "INFO");
    }
    this.checkIntervals.clear();
    
    this.log("Netlify functions redundancy monitoring stopped", "INFO");
  }

  // Get status
  getStatus() {
    return {
      monitoring: this.monitoring,
      functionHealth: Object.fromEntries(this.functionHealth),
      manifestStatus: Object.fromEntries(this.manifestStatus),
      recoveryAttempts: Object.fromEntries(this.recoveryAttempts),
      lastManifestRegeneration: this.lastManifestRegeneration,
      config: this.config
    };
  }

  // Run once
  async runOnce() {
    this.log("Running Netlify functions redundancy check once", "INFO");
    return await this.checkOverallHealth();
  }
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-e3e4
}

// CLI interface
if (require.main === module) {
  const manager = new NetlifyFunctionsRedundancyManager();
<<<<<<< HEAD
  
  const command = process.argv[2] || 'start';
  
  switch (command) {
    case 'start':
      manager.start();
      break;
    case 'monitor':
      manager.startMonitoring();
      break;
    case 'health':
      manager.checkAllFunctions();
      break;
    case 'execute':
      manager.executeAllFunctions();
      break;
    case 'execute-function':
      const functionName = process.argv[3];
      if (functionName) {
        manager.executeFunction(functionName);
      } else {
        console.log("Please specify a function name to execute");
      }
      break;
    case 'regenerate-manifest':
      manager.regenerateManifest();
      break;
    case 'trigger-deploy':
      manager.triggerNetlifyDeploy();
      break;
    case 'test-backups':
      manager.testBackupScripts();
      break;
    case 'report':
      manager.generateHealthReport();
      break;
    default:
      console.log(`
Netlify Functions Redundancy Manager

Usage: node netlify-functions-redundancy-manager.cjs [command]

Commands:
  start               Start the manager and monitoring (default)
  monitor             Start monitoring only
  health              Check health of all functions
  execute             Execute all functions
  execute-function <name> Execute a specific function
  regenerate-manifest Regenerate functions manifest
  trigger-deploy      Trigger Netlify deployment
  test-backups        Test all backup scripts
  report              Generate health report
      `);
      process.exit(0);
=======
  const command = process.argv[2] || "start";
  
  switch (command) {
    case "start":
      manager.start();
      break;
    case "stop":
      manager.stop();
      break;
    case "status":
      console.log(JSON.stringify(manager.getStatus(), null, 2));
      break;
    case "once":
      manager.runOnce().then(status => {
        console.log(JSON.stringify(status, null, 2));
        process.exit(0);
      });
      break;
    case "health":
      manager.checkOverallHealth().then(status => {
        console.log(JSON.stringify(status, null, 2));
        process.exit(0);
      });
      break;
    case "recovery":
      manager.performRecovery().then(results => {
        console.log(JSON.stringify(results, null, 2));
        process.exit(0);
      });
      break;
    case "regenerate":
      manager.regenerateFunctionsManifest().then(success => {
        console.log(JSON.stringify({ success }, null, 2));
        process.exit(0);
      });
      break;
    default:
      console.log("Usage: node netlify-functions-redundancy-manager.cjs [start|stop|status|once|health|recovery|regenerate]");
      process.exit(1);
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-e3e4
  }
}

module.exports = NetlifyFunctionsRedundancyManager;