#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");
<<<<<<< HEAD
const { execSync } = require("child_process");
=======
const { spawnSync } = require("child_process");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-f8c0

class AutomationCoverageAnalyzer {
  constructor() {
    this.workspace = process.cwd();
<<<<<<< HEAD
    this.logDir = path.join(this.workspace, "automation/logs");
    this.ensureLogDirectory();
    
    this.coverage = {
      pm2: { covered: [], uncovered: [], total: 0 },
      githubActions: { covered: [], uncovered: [], total: 0 },
      netlifyFunctions: { covered: [], uncovered: [], total: 0 },
      npmScripts: { covered: [], uncovered: [], total: 0 },
      overall: { coverage: 0, total: 0, covered: 0 }
    };
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    const logFile = path.join(this.logDir, `automation-coverage-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logMessage + "\n");
  }

  async discoverPM2Automations() {
    this.log("Discovering PM2 automations...");
    
    const pm2Automations = [];
=======
    this.coverage = {
      pm2: { total: 0, covered: 0, processes: [] },
      githubActions: { total: 0, covered: 0, workflows: [] },
      netlifyFunctions: { total: 0, covered: 0, functions: [] },
      npmScripts: { total: 0, covered: 0, scripts: [] },
      overall: { total: 0, covered: 0, percentage: 0 }
    };
  }

  async analyzePM2Coverage() {
    console.log("🔍 Analyzing PM2 automation coverage...");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-f8c0
    
    // Check ecosystem files
    const ecosystemFiles = [
      "ecosystem.pm2.cjs",
      "ecosystem.redundancy.cjs",
<<<<<<< HEAD
      "ecosystem.comprehensive-redundancy.cjs"
    ];
    
    for (const file of ecosystemFiles) {
      if (fs.existsSync(file)) {
        try {
          const content = fs.readFileSync(file, 'utf8');
          const appMatches = content.match(/name:\s*["']([^"']+)["']/g);
          if (appMatches) {
            appMatches.forEach(match => {
              const name = match.match(/name:\s*["']([^"']+)["']/)[1];
              pm2Automations.push({
                name,
                file,
                type: 'ecosystem'
=======
      "ecosystem.comprehensive-redundancy.cjs",
      "ecosystem-redundancy.pm2.cjs"
    ];
    
    const processes = [];
    for (const file of ecosystemFiles) {
      if (fs.existsSync(file)) {
        try {
          const content = fs.readFileSync(file, "utf8");
          const processMatches = content.match(/name:\s*"([^"]+)"/g);
          if (processMatches) {
            processMatches.forEach(match => {
              const processName = match.match(/name:\s*"([^"]+)"/)[1];
              processes.push({
                name: processName,
                ecosystemFile: file,
                status: "configured"
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-f8c0
              });
            });
          }
        } catch (error) {
<<<<<<< HEAD
          this.log(`Failed to parse ${file}: ${error.message}`, "WARN");
=======
          console.log(`⚠️  Error reading ${file}: ${error.message}`);
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-f8c0
        }
      }
    }
    
<<<<<<< HEAD
    // Check running PM2 processes
    try {
      const pm2List = execSync("pm2 list", { encoding: 'utf8' });
      const processes = [];
      
      // Parse PM2 list output manually
      const lines = pm2List.split('\n');
      for (const line of lines) {
        if (line.includes('│') && !line.includes('App name')) {
          const parts = line.split('│').map(p => p.trim()).filter(p => p);
          if (parts.length >= 4) {
            processes.push({
              name: parts[1],
              pm2_env: { status: parts[4] }
            });
          }
        }
      }
      
      processes.forEach(process => {
        if (!pm2Automations.find(p => p.name === process.name)) {
          pm2Automations.push({
            name: process.name,
            file: 'running',
            type: 'process'
          });
        }
      });
    } catch (error) {
      this.log("PM2 not running or accessible", "WARN");
    }
    
    this.coverage.pm2.total = pm2Automations.length;
    this.log(`Found ${pm2Automations.length} PM2 automations`);
    
    return pm2Automations;
  }

  async discoverGitHubActionsAutomations() {
    this.log("Discovering GitHub Actions automations...");
    
    const githubAutomations = [];
    const workflowsDir = ".github/workflows";
    
    if (fs.existsSync(workflowsDir)) {
      const workflowFiles = fs.readdirSync(workflowsDir).filter(file => file.endsWith('.yml') || file.endsWith('.yaml'));
=======
    // Check if processes are actually running
    try {
      const pm2Status = spawnSync("pm2", ["status"], { encoding: "utf8" });
      if (pm2Status.status === 0) {
        const output = pm2Status.stdout;
        processes.forEach(process => {
          if (output.includes(process.name)) {
            process.status = "running";
          } else {
            process.status = "stopped";
          }
        });
      }
    } catch (error) {
      console.log("⚠️  PM2 not available or not running");
    }
    
    this.coverage.pm2.processes = processes;
    this.coverage.pm2.total = processes.length;
    this.coverage.pm2.covered = processes.filter(p => p.status === "running").length;
    
    console.log(`📊 PM2 Coverage: ${this.coverage.pm2.covered}/${this.coverage.pm2.total} processes running`);
  }

  async analyzeGitHubActionsCoverage() {
    console.log("🔍 Analyzing GitHub Actions automation coverage...");
    
    const workflowsDir = ".github/workflows";
    const workflows = [];
    
    if (fs.existsSync(workflowsDir)) {
      const workflowFiles = fs.readdirSync(workflowsDir).filter(f => f.endsWith('.yml') || f.endsWith('.yaml'));
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-f8c0
      
      for (const file of workflowFiles) {
        const filePath = path.join(workflowsDir, file);
        try {
<<<<<<< HEAD
          const content = fs.readFileSync(filePath, 'utf8');
          const nameMatch = content.match(/^name:\s*(.+)$/m);
          const name = nameMatch ? nameMatch[1].trim() : file;
          
          githubAutomations.push({
            name,
            file,
            path: filePath,
            type: 'workflow'
          });
        } catch (error) {
          this.log(`Failed to read ${filePath}: ${error.message}`, "WARN");
=======
          const content = fs.readFileSync(filePath, "utf8");
          const workflowName = content.match(/name:\s*(.+)$/m)?.[1]?.trim() || file;
          
          // Check for automation triggers
          const hasSchedule = content.includes("schedule:");
          const hasWorkflowDispatch = content.includes("workflow_dispatch:");
          const hasPush = content.includes("push:");
          const hasPullRequest = content.includes("pull_request:");
          
          workflows.push({
            name: workflowName,
            file: file,
            triggers: {
              schedule: hasSchedule,
              manual: hasWorkflowDispatch,
              push: hasPush,
              pullRequest: hasPullRequest
            },
            status: "configured"
          });
        } catch (error) {
          console.log(`⚠️  Error reading ${filePath}: ${error.message}`);
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-f8c0
        }
      }
    }
    
<<<<<<< HEAD
    this.coverage.githubActions.total = githubAutomations.length;
    this.log(`Found ${githubAutomations.length} GitHub Actions workflows`);
    
    return githubAutomations;
  }

  async discoverNetlifyFunctionsAutomations() {
    this.log("Discovering Netlify Functions automations...");
    
    const netlifyAutomations = [];
    const functionsDir = "netlify/functions";
    
    if (fs.existsSync(functionsDir)) {
      // Check functions manifest
      const manifestFile = path.join(functionsDir, "functions-manifest.json");
      if (fs.existsSync(manifestFile)) {
        try {
          const manifest = JSON.parse(fs.readFileSync(manifestFile, 'utf8'));
          if (manifest.functions) {
            manifest.functions.forEach(func => {
              netlifyAutomations.push({
                name: func.name || func.function || 'unknown',
                file: manifestFile,
                type: 'manifest'
              });
            });
          }
        } catch (error) {
          this.log(`Failed to parse Netlify manifest: ${error.message}`, "WARN");
        }
      }
      
      // Check for individual function files
      const functionFiles = fs.readdirSync(functionsDir).filter(file => 
        file.endsWith('.js') || file.endsWith('.cjs') || file.endsWith('.mjs')
      );
      
      functionFiles.forEach(file => {
        if (!netlifyAutomations.find(f => f.name === file.replace(/\.[^/.]+$/, ''))) {
          netlifyAutomations.push({
            name: file.replace(/\.[^/.]+$/, ''),
            file,
            type: 'function'
          });
=======
    this.coverage.githubActions.workflows = workflows;
    this.coverage.githubActions.total = workflows.length;
    this.coverage.githubActions.covered = workflows.length; // All configured workflows are considered covered
    
    console.log(`📊 GitHub Actions Coverage: ${this.coverage.githubActions.covered}/${this.coverage.githubActions.total} workflows configured`);
  }

  async analyzeNetlifyFunctionsCoverage() {
    console.log("🔍 Analyzing Netlify Functions automation coverage...");
    
    const functions = [];
    
    // Check manifest file
    const manifestPath = "netlify/functions/functions-manifest.json";
    if (fs.existsSync(manifestPath)) {
      try {
        const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
        if (manifest.functions && Array.isArray(manifest.functions)) {
          manifest.functions.forEach(funcName => {
            const funcPath = path.join("netlify/functions", funcName);
            const funcPathJs = funcPath + ".js";
            const funcPathTs = funcPath + ".ts";
            
            let status = "missing";
            if (fs.existsSync(funcPath) || fs.existsSync(funcPathJs) || fs.existsSync(funcPathTs)) {
              status = "exists";
            }
            
            functions.push({
              name: funcName,
              status: status,
              path: funcPath
            });
          });
        }
      } catch (error) {
        console.log(`⚠️  Error reading manifest: ${error.message}`);
      }
    }
    
    // Check for additional functions not in manifest
    const functionsDir = "netlify/functions";
    if (fs.existsSync(functionsDir)) {
      const files = fs.readdirSync(functionsDir);
      files.forEach(file => {
        if (file.endsWith('.js') || file.endsWith('.ts')) {
          const funcName = path.basename(file, path.extname(file));
          if (!functions.find(f => f.name === funcName)) {
            functions.push({
              name: funcName,
              status: "exists",
              path: path.join(functionsDir, file)
            });
          }
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-f8c0
        }
      });
    }
    
<<<<<<< HEAD
    this.coverage.netlifyFunctions.total = netlifyAutomations.length;
    this.log(`Found ${netlifyAutomations.length} Netlify Functions`);
    
    return netlifyAutomations;
  }

  async discoverNPMScriptsAutomations() {
    this.log("Discovering NPM scripts automations...");
    
    const npmAutomations = [];
    const packageJsonPath = "package.json";
    
    if (fs.existsSync(packageJsonPath)) {
      try {
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        const scripts = packageJson.scripts || {};
        
        Object.keys(scripts).forEach(scriptName => {
          const script = scripts[scriptName];
          
          // Categorize scripts by type
          let type = 'general';
          if (script.includes('pm2') || script.includes('redundancy')) {
            type = 'pm2';
          } else if (script.includes('github') || script.includes('gh:')) {
            type = 'github';
          } else if (script.includes('netlify') || script.includes('functions')) {
            type = 'netlify';
          } else if (script.includes('build') || script.includes('dev') || script.includes('start')) {
            type = 'build';
          } else if (script.includes('automation') || script.includes('ai:') || script.includes('cursor:')) {
            type = 'automation';
          }
          
          npmAutomations.push({
            name: scriptName,
            script,
            type,
            category: this.categorizeNPMScript(scriptName, script)
          });
        });
      } catch (error) {
        this.log(`Failed to parse package.json: ${error.message}`, "ERROR");
      }
    }
    
    this.coverage.npmScripts.total = npmAutomations.length;
    this.log(`Found ${npmAutomations.length} NPM scripts`);
    
    return npmAutomations;
  }

  categorizeNPMScript(name, script) {
    if (name.includes('pm2') || script.includes('pm2')) return 'pm2';
    if (name.includes('redundancy') || script.includes('redundancy')) return 'redundancy';
    if (name.includes('github') || script.includes('gh:')) return 'github';
    if (name.includes('netlify') || script.includes('netlify')) return 'netlify';
    if (name.includes('build') || script.includes('build')) return 'build';
    if (name.includes('automation') || script.includes('automation')) return 'automation';
    if (name.includes('ai:') || script.includes('ai:')) return 'ai';
    if (name.includes('cursor:') || script.includes('cursor:')) return 'cursor';
    if (name.includes('design:') || script.includes('design:')) return 'design';
    if (name.includes('syntax:') || script.includes('syntax:')) return 'syntax';
    if (name.includes('linting:') || script.includes('linting:')) return 'linting';
    if (name.includes('healing:') || script.includes('healing:')) return 'healing';
    if (name.includes('linkedin:') || script.includes('linkedin:')) return 'linkedin';
    if (name.includes('marketing:') || script.includes('marketing:')) return 'marketing';
    return 'other';
  }

  analyzeRedundancyCoverage() {
    this.log("Analyzing redundancy coverage...");
    
    // PM2 Redundancy Coverage
    const pm2RedundancyScripts = [
      "automation/ultimate-redundancy-system.cjs",
      "automation/comprehensive-pm2-redundancy.cjs",
      "automation/enhanced-pm2-redundancy.cjs",
      "automation/pm2-redundancy-monitor.cjs"
    ];
    
    this.coverage.pm2.covered = pm2RedundancyScripts.filter(script => fs.existsSync(script));
    this.coverage.pm2.uncovered = pm2RedundancyScripts.filter(script => !fs.existsSync(script));
    
    // GitHub Actions Redundancy Coverage
    const githubRedundancyScripts = [
      "automation/comprehensive-github-actions-redundancy.cjs",
      "automation/enhanced-github-actions-redundancy.cjs",
      "automation/github-actions-redundancy.cjs"
    ];
    
    this.coverage.githubActions.covered = githubRedundancyScripts.filter(script => fs.existsSync(script));
    this.coverage.githubActions.uncovered = githubRedundancyScripts.filter(script => !fs.existsSync(script));
    
    // Netlify Functions Redundancy Coverage
    const netlifyRedundancyScripts = [
      "automation/comprehensive-netlify-functions-redundancy.cjs",
      "automation/enhanced-netlify-functions-redundancy.cjs",
      "automation/netlify-functions-redundancy.cjs"
    ];
    
    this.coverage.netlifyFunctions.covered = netlifyRedundancyScripts.filter(script => fs.existsSync(script));
    this.coverage.netlifyFunctions.uncovered = netlifyRedundancyScripts.filter(script => !fs.existsSync(script));
    
    // NPM Scripts Redundancy Coverage
    const npmRedundancyScripts = [
      "automation/ultimate-redundancy-system.cjs",
      "automation/comprehensive-redundancy-orchestrator.cjs",
      "automation/master-redundancy-orchestrator.cjs"
    ];
    
    this.coverage.npmScripts.covered = npmRedundancyScripts.filter(script => fs.existsSync(script));
    this.coverage.npmScripts.uncovered = npmRedundancyScripts.filter(script => !fs.existsSync(script));
    
    // Calculate overall coverage
    const totalComponents = this.coverage.pm2.total + this.coverage.githubActions.total + 
                           this.coverage.netlifyFunctions.total + this.coverage.npmScripts.total;
    const totalCovered = this.coverage.pm2.covered.length + this.coverage.githubActions.covered.length + 
                         this.coverage.netlifyFunctions.covered.length + this.coverage.npmScripts.covered.length;
    
    this.coverage.overall = {
      total: totalComponents,
      covered: totalCovered,
      coverage: totalComponents > 0 ? (totalCovered / totalComponents) * 100 : 0
    };
  }

  generateCoverageReport() {
    this.log("Generating coverage report...");
    
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        overall: this.coverage.overall,
        pm2: {
          total: this.coverage.pm2.total,
          covered: this.coverage.pm2.covered.length,
          uncovered: this.coverage.pm2.uncovered.length,
          coverage: this.coverage.pm2.total > 0 ? (this.coverage.pm2.covered.length / this.coverage.pm2.total) * 100 : 0
        },
        githubActions: {
          total: this.coverage.githubActions.total,
          covered: this.coverage.githubActions.covered.length,
          uncovered: this.coverage.githubActions.uncovered.length,
          coverage: this.coverage.githubActions.total > 0 ? (this.coverage.githubActions.covered.length / this.coverage.githubActions.total) * 100 : 0
        },
        netlifyFunctions: {
          total: this.coverage.netlifyFunctions.total,
          covered: this.coverage.netlifyFunctions.covered.length,
          uncovered: this.coverage.netlifyFunctions.uncovered.length,
          coverage: this.coverage.netlifyFunctions.total > 0 ? (this.coverage.netlifyFunctions.covered.length / this.coverage.netlifyFunctions.total) * 100 : 0
        },
        npmScripts: {
          total: this.coverage.npmScripts.total,
          covered: this.coverage.npmScripts.covered.length,
          uncovered: this.coverage.npmScripts.uncovered.length,
          coverage: this.coverage.npmScripts.total > 0 ? (this.coverage.netlifyFunctions.covered.length / this.coverage.npmScripts.total) * 100 : 0
        }
      },
      details: {
        pm2: {
          covered: this.coverage.pm2.covered,
          uncovered: this.coverage.pm2.uncovered
        },
        githubActions: {
          covered: this.coverage.githubActions.covered,
          covered: this.coverage.githubActions.covered,
          uncovered: this.coverage.githubActions.uncovered
        },
        netlifyFunctions: {
          covered: this.coverage.netlifyFunctions.covered,
          uncovered: this.coverage.netlifyFunctions.uncovered
        },
        npmScripts: {
          covered: this.coverage.npmScripts.covered,
          uncovered: this.coverage.npmScripts.uncovered
        }
      },
      recommendations: this.generateRecommendations()
    };
    
    // Save report to file
    const reportFile = path.join(this.logDir, `automation-coverage-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    this.log(`Coverage report saved to: ${reportFile}`);
    
    return report;
  }

  generateRecommendations() {
    const recommendations = [];
    
    if (this.coverage.pm2.uncovered.length > 0) {
      recommendations.push({
        type: "pm2",
        priority: "high",
        message: `Create redundancy scripts for ${this.coverage.pm2.uncovered.length} uncovered PM2 automations`,
        actions: this.coverage.pm2.uncovered.map(script => `Create ${script}`)
      });
    }
    
    if (this.coverage.githubActions.uncovered.length > 0) {
      recommendations.push({
        type: "github",
        priority: "high",
        message: `Create redundancy scripts for ${this.coverage.githubActions.uncovered.length} uncovered GitHub Actions`,
        actions: this.coverage.githubActions.uncovered.map(script => `Create ${script}`)
      });
    }
    
    if (this.coverage.netlifyFunctions.uncovered.length > 0) {
      recommendations.push({
        type: "netlify",
        priority: "medium",
        message: `Create redundancy scripts for ${this.coverage.netlifyFunctions.uncovered.length} uncovered Netlify Functions`,
        actions: this.coverage.netlifyFunctions.uncovered.map(script => `Create ${script}`)
      });
    }
    
    if (this.coverage.npmScripts.uncovered.length > 0) {
      recommendations.push({
        type: "npm",
        priority: "medium",
        message: `Create redundancy scripts for ${this.coverage.npmScripts.uncovered.length} uncovered NPM scripts`,
        actions: this.coverage.npmScripts.uncovered.map(script => `Create ${script}`)
      });
    }
    
    if (this.coverage.overall.coverage < 80) {
      recommendations.push({
        type: "overall",
        priority: "critical",
        message: `Overall automation coverage is ${this.coverage.overall.coverage.toFixed(1)}%. Target: 80%+`,
        actions: ["Review uncovered automations", "Implement missing redundancy scripts", "Test redundancy coverage"]
      });
    }
    
    return recommendations;
  }

  async runAnalysis() {
    this.log("Starting automation coverage analysis...");
    
    try {
      // Discover all automations
      await this.discoverPM2Automations();
      await this.discoverGitHubActionsAutomations();
      await this.discoverNetlifyFunctionsAutomations();
      await this.discoverNPMScriptsAutomations();
      
      // Analyze redundancy coverage
      this.analyzeRedundancyCoverage();
      
      // Generate report
      const report = this.generateCoverageReport();
      
      // Display summary
      console.log("\n" + "=".repeat(60));
      console.log("AUTOMATION COVERAGE ANALYSIS SUMMARY");
      console.log("=".repeat(60));
      console.log(`Overall Coverage: ${report.summary.overall.coverage.toFixed(1)}%`);
      console.log(`Total Components: ${report.summary.overall.total}`);
      console.log(`Covered: ${report.summary.overall.covered}`);
      console.log("");
      console.log("Component Coverage:");
      console.log(`  PM2: ${report.summary.pm2.coverage.toFixed(1)}% (${report.summary.pm2.covered}/${report.summary.pm2.total})`);
      console.log(`  GitHub Actions: ${report.summary.githubActions.coverage.toFixed(1)}% (${report.summary.githubActions.covered}/${report.summary.githubActions.total})`);
      console.log(`  Netlify Functions: ${report.summary.netlifyFunctions.coverage.toFixed(1)}% (${report.summary.netlifyFunctions.covered}/${report.summary.netlifyFunctions.total})`);
      console.log(`  NPM Scripts: ${report.summary.npmScripts.coverage.toFixed(1)}% (${report.summary.npmScripts.covered}/${report.summary.npmScripts.total})`);
      console.log("");
      
      if (report.recommendations.length > 0) {
        console.log("Recommendations:");
        report.recommendations.forEach((rec, index) => {
          console.log(`  ${index + 1}. [${rec.priority.toUpperCase()}] ${rec.message}`);
        });
      }
      
      console.log("=".repeat(60));
      
      return report;
    } catch (error) {
      this.log(`Analysis failed: ${error.message}`, "ERROR");
      throw error;
    }
  }
}

// CLI interface
if (require.main === module) {
  const analyzer = new AutomationCoverageAnalyzer();
  
  analyzer.runAnalysis().catch(error => {
    console.error(`Error: ${error.message}`);
    process.exit(1);
    process.exit(1);
  });
}

module.exports = AutomationCoverageAnalyzer;
=======
    this.coverage.netlifyFunctions.functions = functions;
    this.coverage.netlifyFunctions.total = functions.length;
    this.coverage.netlifyFunctions.covered = functions.filter(f => f.status === "exists").length;
    
    console.log(`📊 Netlify Functions Coverage: ${this.coverage.netlifyFunctions.covered}/${this.coverage.netlifyFunctions.total} functions exist`);
  }

  async analyzeNPMScriptsCoverage() {
    console.log("🔍 Analyzing NPM scripts automation coverage...");
    
    const packageJsonPath = "package.json";
    if (!fs.existsSync(packageJsonPath)) {
      console.log("⚠️  package.json not found");
      return;
    }
    
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
      const scripts = packageJson.scripts || {};
      
      const scriptCategories = {
        redundancy: [],
        automation: [],
        build: [],
        pm2: [],
        other: []
      };
      
      Object.entries(scripts).forEach(([name, script]) => {
        const scriptStr = String(script);
        
        if (name.includes("redundancy") || scriptStr.includes("redundancy")) {
          scriptCategories.redundancy.push({ name, script: scriptStr, status: "available" });
        } else if (name.includes("automation") || scriptStr.includes("automation")) {
          scriptCategories.automation.push({ name, script: scriptStr, status: "available" });
        } else if (name.includes("build") || scriptStr.includes("build")) {
          scriptCategories.build.push({ name, script: scriptStr, status: "available" });
        } else if (name.includes("pm2") || scriptStr.includes("pm2")) {
          scriptCategories.pm2.push({ name, script: scriptStr, status: "available" });
        } else {
          scriptCategories.other.push({ name, script: scriptStr, status: "available" });
        }
      });
      
      this.coverage.npmScripts.scripts = Object.values(scriptCategories).flat();
      this.coverage.npmScripts.total = this.coverage.npmScripts.scripts.length;
      this.coverage.npmScripts.covered = this.coverage.npmScripts.scripts.length; // All scripts are considered covered
      
      console.log(`📊 NPM Scripts Coverage: ${this.coverage.npmScripts.covered}/${this.coverage.npmScripts.total} scripts available`);
      
      // Log script categories
      Object.entries(scriptCategories).forEach(([category, categoryScripts]) => {
        if (categoryScripts.length > 0) {
          console.log(`  📁 ${category}: ${categoryScripts.length} scripts`);
        }
      });
    } catch (error) {
      console.log(`⚠️  Error reading package.json: ${error.message}`);
    }
  }

  calculateOverallCoverage() {
    const total = this.coverage.pm2.total + this.coverage.githubActions.total + 
                  this.coverage.netlifyFunctions.total + this.coverage.npmScripts.total;
    const covered = this.coverage.pm2.covered + this.coverage.githubActions.covered + 
                    this.coverage.netlifyFunctions.covered + this.coverage.npmScripts.covered;
    
    this.coverage.overall.total = total;
    this.coverage.overall.covered = covered;
    this.coverage.overall.percentage = total > 0 ? Math.round((covered / total) * 100) : 0;
  }

  generateCoverageReport() {
    console.log("\n" + "=".repeat(80));
    console.log("🎯 ULTIMATE AUTOMATION COVERAGE REPORT");
    console.log("=".repeat(80));
    
    // PM2 Coverage
    console.log("\n🔧 PM2 AUTOMATION COVERAGE");
    console.log("-".repeat(40));
    console.log(`Total Processes: ${this.coverage.pm2.total}`);
    console.log(`Running: ${this.coverage.pm2.covered}`);
    console.log(`Coverage: ${this.coverage.pm2.total > 0 ? Math.round((this.coverage.pm2.covered / this.coverage.pm2.total) * 100) : 0}%`);
    
    if (this.coverage.pm2.processes.length > 0) {
      console.log("\nProcesses:");
      this.coverage.pm2.processes.forEach(process => {
        const statusIcon = process.status === "running" ? "🟢" : process.status === "stopped" ? "🟡" : "🔴";
        console.log(`  ${statusIcon} ${process.name} (${process.ecosystemFile}) - ${process.status}`);
      });
    }
    
    // GitHub Actions Coverage
    console.log("\n🚀 GITHUB ACTIONS COVERAGE");
    console.log("-".repeat(40));
    console.log(`Total Workflows: ${this.coverage.githubActions.total}`);
    console.log(`Configured: ${this.coverage.githubActions.covered}`);
    console.log(`Coverage: ${this.coverage.githubActions.total > 0 ? Math.round((this.coverage.githubActions.covered / this.coverage.githubActions.total) * 100) : 0}%`);
    
    if (this.coverage.githubActions.workflows.length > 0) {
      console.log("\nWorkflows:");
      this.coverage.githubActions.workflows.forEach(workflow => {
        const triggers = Object.entries(workflow.triggers)
          .filter(([_, enabled]) => enabled)
          .map(([trigger, _]) => trigger)
          .join(", ");
        console.log(`  📄 ${workflow.name} (${workflow.file}) - Triggers: ${triggers || "none"}`);
      });
    }
    
    // Netlify Functions Coverage
    console.log("\n☁️  NETLIFY FUNCTIONS COVERAGE");
    console.log("-".repeat(40));
    console.log(`Total Functions: ${this.coverage.netlifyFunctions.total}`);
    console.log(`Existing: ${this.coverage.netlifyFunctions.covered}`);
    console.log(`Coverage: ${this.coverage.netlifyFunctions.total > 0 ? Math.round((this.coverage.netlifyFunctions.covered / this.coverage.netlifyFunctions.total) * 100) : 0}%`);
    
    if (this.coverage.netlifyFunctions.functions.length > 0) {
      const missingFunctions = this.coverage.netlifyFunctions.functions.filter(f => f.status === "missing");
      if (missingFunctions.length > 0) {
        console.log("\nMissing Functions:");
        missingFunctions.forEach(func => {
          console.log(`  ❌ ${func.name}`);
        });
      }
    }
    
    // NPM Scripts Coverage
    console.log("\n📦 NPM SCRIPTS COVERAGE");
    console.log("-".repeat(40));
    console.log(`Total Scripts: ${this.coverage.npmScripts.total}`);
    console.log(`Available: ${this.coverage.npmScripts.covered}`);
    console.log(`Coverage: ${this.coverage.npmScripts.total > 0 ? Math.round((this.coverage.npmScripts.covered / this.coverage.npmScripts.total) * 100) : 0}%`);
    
    // Overall Coverage
    console.log("\n🎯 OVERALL AUTOMATION COVERAGE");
    console.log("-".repeat(40));
    console.log(`Total Components: ${this.coverage.overall.total}`);
    console.log(`Covered Components: ${this.coverage.overall.covered}`);
    console.log(`Overall Coverage: ${this.coverage.overall.percentage}%`);
    
    // Coverage Status
    let statusIcon, statusText;
    if (this.coverage.overall.percentage >= 90) {
      statusIcon = "🟢";
      statusText = "EXCELLENT";
    } else if (this.coverage.overall.percentage >= 75) {
      statusIcon = "🟡";
      statusText = "GOOD";
    } else if (this.coverage.overall.percentage >= 50) {
      statusIcon = "🟠";
      statusText = "FAIR";
    } else {
      statusIcon = "🔴";
      statusText = "POOR";
    }
    
    console.log(`\n${statusIcon} Coverage Status: ${statusText}`);
    
    // Recommendations
    console.log("\n💡 RECOMMENDATIONS");
    console.log("-".repeat(40));
    
    if (this.coverage.pm2.covered < this.coverage.pm2.total) {
      console.log("🔧 Start PM2 processes to improve PM2 coverage");
    }
    
    if (this.coverage.netlifyFunctions.covered < this.coverage.netlifyFunctions.total) {
      console.log("☁️  Create missing Netlify functions to improve functions coverage");
    }
    
    if (this.coverage.overall.percentage < 90) {
      console.log("📈 Consider adding more automation scripts to reach 90%+ coverage");
    }
    
    console.log("\n" + "=".repeat(80));
  }

  async runFullAnalysis() {
    console.log("🚀 Starting comprehensive automation coverage analysis...\n");
    
    await this.analyzePM2Coverage();
    await this.analyzeGitHubActionsCoverage();
    await this.analyzeNetlifyFunctionsCoverage();
    await this.analyzeNPMScriptsCoverage();
    
    this.calculateOverallCoverage();
    this.generateCoverageReport();
    
    return this.coverage;
  }
}

// CLI Interface
if (require.main === module) {
  const analyzer = new AutomationCoverageAnalyzer();
  analyzer.runFullAnalysis().catch(console.error);
}

module.exports = AutomationCoverageAnalyzer;
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-f8c0
