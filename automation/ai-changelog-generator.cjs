#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function run(command) {
  return execSync(command, { encoding: 'utf8' }).trim();
}

function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

function getRecentCommits(hours = 24) {
  const sinceArg = `--since="${hours} hours"`;
  const format = '%H|%s|%an|%cI';
  const raw = run(`git log ${sinceArg} --pretty=format:"${format}" || true`);
  if (!raw) return [];
  return raw
    .split('\n')
    .map((line) => {
      const [hash, subject, author, date] = line.split('|');
      return { hash, subject, author, date };
    })
    .filter((c) => c.hash && c.subject && !/github-actions\[bot\]/i.test(c.author));
}

function classify(subject) {
  const lower = subject.toLowerCase();
  if (lower.startsWith('feat')) return 'Features';
  if (lower.startsWith('fix')) return 'Fixes';
  if (lower.startsWith('perf')) return 'Performance';
  if (lower.startsWith('refactor')) return 'Refactors';
  if (lower.startsWith('docs')) return 'Docs';
  if (lower.startsWith('test')) return 'Tests';
  if (lower.startsWith('ci')) return 'CI';
  if (lower.startsWith('build')) return 'Build';
  if (lower.startsWith('style')) return 'Style';
  if (lower.startsWith('chore')) return 'Chores';
  if (lower.startsWith('revert')) return 'Reverts';
  return 'Other';
}

function formatEntry(commit) {
  const short = commit.hash.slice(0, 7);
  const cleaned = commit.subject.replace(/^\w+(\(.*?\))?:\s*/i, '');
  return `- ${cleaned} (${short})`;
}

function generateChangelog(commits) {
  const byType = {};
  for (const c of commits) {
    const type = classify(c.subject);
    if (!byType[type]) byType[type] = [];
    byType[type].push(c);
  }

  const date = new Date().toISOString().slice(0, 10);
  let out = `## ${date}\n`;
  const order = [
    'Features',
    'Fixes',
    'Performance',
    'Refactors',
    'Docs',
    'Tests',
    'CI',
    'Build',
    'Style',
    'Chores',
    'Reverts',
    'Other',
  ];

  let added = 0;
  for (const key of order) {
    const items = byType[key];
    if (!items || items.length === 0) continue;
    out += `\n### ${key}\n`;
    for (const it of items) {
      out += `${formatEntry(it)}\n`;
      added += 1;
    }
  }

  if (added === 0) return '';
  out += '\n';
  return out;
}

function prependFile(targetPath, content) {
  const existing = fs.existsSync(targetPath) ? fs.readFileSync(targetPath, 'utf8') : '';
  const header = '# AI Changelog (autogenerated)\n\n';
  const hasHeader = existing.startsWith('# AI Changelog');
  const body = content + (existing ? `\n${existing}` : '');
  fs.writeFileSync(targetPath, hasHeader ? body : header + body, 'utf8');
}

(function main() {
  try {
    const commits = getRecentCommits(24);
    if (commits.length === 0) {
      console.log('No recent commits to include.');
      process.exit(0);
    }
    const section = generateChangelog(commits);
    if (!section) {
      console.log('No meaningful changes to record.');
      process.exit(0);
    }
    const docsDir = path.join(process.cwd(), 'docs');
    ensureDir(docsDir);
    const outPath = path.join(docsDir, 'CHANGELOG_AI.md');
    prependFile(outPath, section);
    console.log(`Updated ${outPath}`);
  } catch (err) {
    console.error('ai-changelog-generator failed:', err.message);
    process.exit(0); // do not fail CI
  }
})();