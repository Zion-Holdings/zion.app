#!/usr/bin/env node
"use strict";

const { spawnSync, execSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

class UltimateRedundancyMaster {
  constructor() {
<<<<<<< HEAD
=======
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "ultimate-redundancy-master.log");
    this.ensureLogDir();
    
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
    this.config = {
      // PM2 Redundancy Configuration
      pm2: {
        ecosystemFiles: [
          "ecosystem.pm2.cjs",
          "ecosystem.redundancy.cjs",
<<<<<<< HEAD
          "ecosystem.comprehensive-redundancy.cjs",
          "ecosystem-redundancy.pm2.cjs"
=======
          "ecosystem.comprehensive-redundancy.cjs"
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
        ],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor",
          "enhanced-pm2-redundancy",
          "enhanced-github-actions-redundancy",
          "enhanced-netlify-functions-redundancy",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor"
        ],
        healthCheckInterval: 15000,
        maxRestartAttempts: 10,
        restartDelay: 3000,
        autoRecovery: true,
        processMonitoring: true,
        logRotation: true
      },
      
      // GitHub Actions Redundancy Configuration
      github: {
        workflows: [
          "marketing-sync",
          "sync-health"
        ],
        backupWorkflows: [
          "marketing-sync-backup",
          "sync-health-backup"
        ],
        healthCheckInterval: 30000,
<<<<<<< HEAD
        maxFailureThreshold: 5,
        autoTrigger: true,
        backupTriggers: true,
        workflowValidation: true,
        apiHealthCheck: true,
        autoHealing: true
      },
      
=======
        maxRestartAttempts: 5,
        restartDelay: 5000
      },
      
      // GitHub Actions Redundancy Configuration
      githubActions: {
        workflows: [
          "marketing-sync",
          "sync-health"
        ],
        backupWorkflows: [
          "marketing-sync-backup",
          "sync-health-backup"
        ],
        triggerInterval: 300000, // 5 minutes
        healthCheckInterval: 60000 // 1 minute
      },
      
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
      // Netlify Functions Redundancy Configuration
      netlify: {
        functionsDir: "netlify/functions",
        manifestFile: "netlify/functions/functions-manifest.json",
<<<<<<< HEAD
        healthCheckInterval: 60000,
        maxFailureThreshold: 3,
        autoRegenerate: true,
        deploymentCheck: true,
        logRotation: true,
        functionMonitoring: true,
        autoHealing: true
      },
      logging: {
        logDir: "automation/logs",
        maxLogSize: 20 * 1024 * 1024,
        maxLogFiles: 50,
        compression: true,
        rotation: true
      },
      monitoring: {
        enabled: true,
        interval: 15000,
        alertThreshold: 5,
        autoRestart: true,
        loadBalancing: true,
        healthDashboard: true
      },
      git: {
        syncInterval: 900000, // 15 minutes
        autoSync: true,
        conflictResolution: true,
        backupStrategy: true
      },
      build: {
        monitoring: true,
        autoRecovery: true,
        healthChecks: true,
        performanceOptimization: true
      }
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
    this.startUltimateMonitoring();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
=======
        healthCheckInterval: 120000, // 2 minutes
        functionTimeout: 30000,
        maxRetries: 3
      },
      
      // General Configuration
      monitoring: false,
      checkInterval: null,
      restartCounts: new Map(),
      healthHistory: new Map()
    };
    
    this.restartCounts = new Map();
    this.healthHistory = new Map();
    this.lastHealthCheck = new Map();
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `ultimate-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
=======
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
<<<<<<< HEAD
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 50,
=======
        cwd: this.workspace,
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
        timeout: options.timeout || 30000,
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
<<<<<<< HEAD
  }

  async checkPM2UltimateHealth() {
    this.log("ðŸ” Checking ultimate PM2 process health...");
    
    try {
      // Check PM2 status
      const pm2Status = await this.runCommand("pm2", ["status"]);
      
      if (pm2Status.status !== 0) {
        this.log("âŒ PM2 not running, attempting to start...", "ERROR");
        await this.startPM2Services();
        return false;
      }

      // Check each process
      let healthyProcesses = 0;
      let totalProcesses = 0;

      for (const processName of this.config.pm2.processes) {
        try {
          const processInfo = await this.runCommand("pm2", ["show", processName]);
          if (processInfo.status === 0 && processInfo.stdout.includes("online")) {
            healthyProcesses++;
          } else {
            this.log(`âš ï¸ Process ${processName} is not healthy, attempting restart...`, "WARN");
            await this.restartPM2Process(processName);
          }
          totalProcesses++;
        } catch (error) {
          this.log(`âŒ Error checking process ${processName}: ${error.message}`, "ERROR");
        }
      }

      this.log(`âœ… PM2 Health: ${healthyProcesses}/${totalProcesses} processes healthy`);
      return healthyProcesses === totalProcesses;
    } catch (error) {
      this.log(`âŒ PM2 health check failed: ${error.message}`, "ERROR");
=======
  }

  // PM2 Redundancy Methods
  async checkPM2Status() {
    try {
      const result = await this.runCommand("pm2", ["status", "--no-daemon"]);
      return result.status === 0;
    } catch (error) {
      this.log(`PM2 status check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async getPM2ProcessInfo(processName) {
    try {
      const result = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
      if (result.status === 0) {
        const output = result.stdout;
        const statusMatch = output.match(/status\s*:\s*(\w+)/);
        const memoryMatch = output.match(/memory\s*:\s*(\d+)/);
        const cpuMatch = output.match(/cpu\s*:\s*(\d+)/);
        
        return {
          name: processName,
          status: statusMatch ? statusMatch[1] : "unknown",
          memory: memoryMatch ? parseInt(memoryMatch[1]) : 0,
          cpu: cpuMatch ? parseInt(cpuMatch[1]) : 0,
          lastCheck: Date.now()
        };
      }
      return null;
    } catch (error) {
      this.log(`Failed to get PM2 process info for ${processName}: ${error.message}`, "ERROR");
      return null;
    }
  }

  async startPM2Process(processName) {
    try {
      this.log(`Starting PM2 process: ${processName}`);
      const result = await this.runCommand("pm2", ["start", processName, "--update-env"]);
      if (result.status === 0) {
        this.log(`Successfully started PM2 process: ${processName}`);
        return true;
      } else {
        this.log(`Failed to start PM2 process: ${processName}`, "ERROR");
        return false;
      }
    } catch (error) {
      this.log(`Error starting PM2 process ${processName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async restartPM2Process(processName) {
    try {
      this.log(`Restarting PM2 process: ${processName}`);
      const result = await this.runCommand("pm2", ["restart", processName]);
      if (result.status === 0) {
        this.log(`Successfully restarted PM2 process: ${processName}`);
        return true;
      } else {
        this.log(`Failed to restart PM2 process: ${processName}`, "ERROR");
        return false;
      }
    } catch (error) {
      this.log(`Error restarting PM2 process ${processName}: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
      return false;
    }
  }

<<<<<<< HEAD
  async startPM2Services() {
    this.log("ðŸš€ Starting PM2 services...");
    
    try {
      // Start comprehensive redundancy ecosystem
      await this.runCommand("pm2", ["start", "ecosystem.comprehensive-redundancy.cjs"]);
      
      // Start additional redundancy systems
      await this.runCommand("pm2", ["start", "ecosystem.redundancy.pm2.cjs"]);
      
      // Save PM2 configuration
      await this.runCommand("pm2", ["save"]);
      
      this.log("âœ… PM2 services started successfully");
    } catch (error) {
      this.log(`âŒ Failed to start PM2 services: ${error.message}`, "ERROR");
    }
  }

  async restartPM2Process(processName) {
    try {
      await this.runCommand("pm2", ["restart", processName]);
      this.log(`âœ… Restarted PM2 process: ${processName}`);
    } catch (error) {
      this.log(`âŒ Failed to restart PM2 process ${processName}: ${error.message}`, "ERROR");
    }
  }

  async checkGitHubActionsUltimateHealth() {
    this.log("ðŸ” Checking ultimate GitHub Actions health...");
    
    try {
      // Check workflow files exist
      for (const workflow of this.config.githubActions.workflows) {
        if (!fs.existsSync(workflow)) {
          this.log(`âš ï¸ Workflow file missing: ${workflow}`, "WARN");
          continue;
        }
        
        // Validate workflow syntax
        const workflowContent = fs.readFileSync(workflow, 'utf8');
        if (!workflowContent.includes('name:') || !workflowContent.includes('on:')) {
          this.log(`âš ï¸ Invalid workflow syntax: ${workflow}`, "WARN");
        }
      }

      // Check GitHub API health (if token available)
      if (process.env.GITHUB_TOKEN) {
        try {
          const response = await fetch('https://api.github.com/rate_limit', {
            headers: { 'Authorization': `token ${process.env.GITHUB_TOKEN}` }
          });
          if (response.ok) {
            this.log("âœ… GitHub API is healthy");
          } else {
            this.log("âš ï¸ GitHub API health check failed", "WARN");
          }
        } catch (error) {
          this.log(`âš ï¸ GitHub API health check error: ${error.message}`, "WARN");
        }
      }

      this.log("âœ… GitHub Actions health check completed");
      return true;
    } catch (error) {
      this.log(`âŒ GitHub Actions health check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkNetlifyFunctionsUltimateHealth() {
    this.log("ðŸ” Checking ultimate Netlify Functions health...");
    
    try {
      // Check manifest file
      if (!fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        this.log("âš ï¸ Netlify functions manifest missing, regenerating...", "WARN");
        await this.regenerateNetlifyManifest();
      }

      // Validate manifest content
      try {
        const manifest = JSON.parse(fs.readFileSync(this.config.netlifyFunctions.manifestFile, 'utf8'));
        if (!manifest.functions || !Array.isArray(manifest.functions)) {
          throw new Error("Invalid manifest structure");
        }
        this.log(`âœ… Netlify Functions manifest valid: ${manifest.functions.length} functions`);
      } catch (error) {
        this.log(`âŒ Invalid manifest content: ${error.message}`, "ERROR");
        await this.regenerateNetlifyManifest();
      }

      // Check function files
      const functionsDir = path.dirname(this.config.netlifyFunctions.manifestFile);
      const functionFiles = fs.readdirSync(functionsDir).filter(f => f.endsWith('.js') || f.endsWith('.cjs'));
      
      this.log(`âœ… Netlify Functions health check completed: ${functionFiles.length} function files found`);
      return true;
    } catch (error) {
      this.log(`âŒ Netlify Functions health check failed: ${error.message}`, "ERROR");
=======
  async ensurePM2Processes() {
    this.log("Ensuring all PM2 processes are running...");
    
    for (const processName of this.config.pm2.processes) {
      const processInfo = await this.getPM2ProcessInfo(processName);
      
      if (!processInfo || processInfo.status !== "online") {
        this.log(`Process ${processName} is not running, attempting to start...`);
        
        if (processInfo && processInfo.status === "errored") {
          await this.restartPM2Process(processName);
        } else {
          await this.startPM2Process(processName);
        }
        
        // Wait a bit before checking the next process
        await new Promise(resolve => setTimeout(resolve, 2000));
      } else {
        this.log(`Process ${processName} is running (${processInfo.status})`);
      }
    }
  }

  // GitHub Actions Redundancy Methods
  async checkGitHubWorkflowStatus(workflowName) {
    try {
      const workflowFile = path.join(this.workspace, ".github/workflows", `${workflowName}.yml`);
      if (!fs.existsSync(workflowFile)) {
        this.log(`Workflow file not found: ${workflowFile}`, "WARN");
        return false;
      }
      
      // Check if workflow is properly configured
      const workflowContent = fs.readFileSync(workflowFile, "utf8");
      const isValid = workflowContent.includes("on:") && workflowContent.includes("jobs:");
      
      if (!isValid) {
        this.log(`Invalid workflow configuration: ${workflowName}`, "ERROR");
        return false;
      }
      
      this.log(`Workflow ${workflowName} is properly configured`);
      return true;
    } catch (error) {
      this.log(`Error checking GitHub workflow ${workflowName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async triggerGitHubWorkflow(workflowName) {
    try {
      this.log(`Triggering GitHub workflow: ${workflowName}`);
      
      // Create a trigger file to simulate workflow dispatch
      const triggerFile = path.join(this.workspace, `.github/workflows/.${workflowName}-trigger`);
      fs.writeFileSync(triggerFile, Date.now().toString());
      
      // Commit and push the trigger
      await this.runCommand("git", ["add", triggerFile]);
      await this.runCommand("git", ["commit", "-m", `chore(workflow): trigger ${workflowName} [skip ci]`]);
      await this.runCommand("git", ["push", "origin", "main"]);
      
      // Clean up trigger file
      fs.unlinkSync(triggerFile);
      await this.runCommand("git", ["add", triggerFile]);
      await this.runCommand("git", ["commit", "-m", `chore(workflow): cleanup ${workflowName} trigger [skip ci]`]);
      await this.runCommand("git", ["push", "origin", "main"]);
      
      this.log(`Successfully triggered GitHub workflow: ${workflowName}`);
      return true;
    } catch (error) {
      this.log(`Error triggering GitHub workflow ${workflowName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async ensureGitHubWorkflows() {
    this.log("Ensuring all GitHub workflows are properly configured...");
    
    for (const workflow of this.config.githubActions.workflows) {
      const isHealthy = await this.checkGitHubWorkflowStatus(workflow);
      
      if (!isHealthy) {
        this.log(`Workflow ${workflow} is unhealthy, attempting to trigger...`);
        await this.triggerGitHubWorkflow(workflow);
      }
    }
  }

  // Netlify Functions Redundancy Methods
  async checkNetlifyFunctionHealth(functionName) {
    try {
      const functionDir = path.join(this.config.netlify.functionsDir, functionName);
      if (!fs.existsSync(functionDir)) {
        this.log(`Netlify function directory not found: ${functionDir}`, "WARN");
        return false;
      }
      
      // Check if function has required files
      const requiredFiles = ["index.js", "index.mjs", "index.ts"];
      const hasRequiredFile = requiredFiles.some(file => fs.existsSync(path.join(functionDir, file)));
      
      if (!hasRequiredFile) {
        this.log(`Netlify function ${functionName} missing required files`, "ERROR");
        return false;
      }
      
      this.log(`Netlify function ${functionName} is healthy`);
      return true;
    } catch (error) {
      this.log(`Error checking Netlify function ${functionName}: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
      return false;
    }
  }

  async regenerateNetlifyManifest() {
    try {
<<<<<<< HEAD
      this.log("ðŸ”„ Regenerating Netlify functions manifest...");
      await this.runCommand("node", ["scripts/generate-netlify-functions-manifest.cjs"]);
      this.log("âœ… Netlify functions manifest regenerated");
    } catch (error) {
      this.log(`âŒ Failed to regenerate manifest: ${error.message}`, "ERROR");
    }
  }

  async checkGitUltimateHealth() {
    this.log("ðŸ” Checking ultimate Git health...");
    
    try {
      // Check git status
      const gitStatus = await this.runCommand("git", ["status"]);
      if (gitStatus.status !== 0) {
        this.log("âŒ Git repository not accessible", "ERROR");
        return false;
      }

      // Check remote status
      const remoteStatus = await this.runCommand("git", ["remote", "-v"]);
      if (remoteStatus.status !== 0) {
        this.log("âŒ Git remotes not accessible", "ERROR");
        return false;
      }

      // Check for conflicts
      if (gitStatus.stdout.includes("conflict")) {
        this.log("âš ï¸ Git conflicts detected, attempting resolution...", "WARN");
        await this.resolveGitConflicts();
      }

      this.log("âœ… Git health check completed");
      return true;
    } catch (error) {
      this.log(`âŒ Git health check failed: ${error.message}`, "ERROR");
=======
      this.log("Regenerating Netlify functions manifest...");
      const result = await this.runCommand("node", ["scripts/generate-netlify-functions-manifest.cjs"]);
      
      if (result.status === 0) {
        this.log("Successfully regenerated Netlify functions manifest");
        return true;
      } else {
        this.log("Failed to regenerate Netlify functions manifest", "ERROR");
        return false;
      }
    } catch (error) {
      this.log(`Error regenerating Netlify functions manifest: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
      return false;
    }
  }

<<<<<<< HEAD
  async resolveGitConflicts() {
    try {
      this.log("ðŸ”§ Resolving Git conflicts...");
      
      // Stash changes
      await this.runCommand("git", ["stash"]);
      
      // Pull latest
      await this.runCommand("git", ["pull", "origin", "main"]);
      
      // Pop stashed changes
      await this.runCommand("git", ["stash", "pop"]);
      
      this.log("âœ… Git conflicts resolved");
    } catch (error) {
      this.log(`âŒ Failed to resolve Git conflicts: ${error.message}`, "ERROR");
    }
  }

  async checkBuildUltimateHealth() {
    this.log("ðŸ” Checking ultimate build health...");
    
    try {
      // Check if build artifacts exist
      const buildDirs = ['.next', 'out', 'dist'];
      let buildHealthy = true;

      for (const dir of buildDirs) {
        if (fs.existsSync(dir)) {
          const stats = fs.statSync(dir);
          if (stats.isDirectory() && fs.readdirSync(dir).length > 0) {
            this.log(`âœ… Build directory ${dir} exists and has content`);
          } else {
            this.log(`âš ï¸ Build directory ${dir} is empty`, "WARN");
            buildHealthy = false;
          }
        } else {
          this.log(`âš ï¸ Build directory ${dir} missing`, "WARN");
          buildHealthy = false;
        }
      }

      // Check package.json scripts
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      const requiredScripts = ['build', 'dev', 'start'];
      
      for (const script of requiredScripts) {
        if (!packageJson.scripts[script]) {
          this.log(`âš ï¸ Required script missing: ${script}`, "WARN");
          buildHealthy = false;
        }
      }

      this.log(`âœ… Build health check completed: ${buildHealthy ? 'Healthy' : 'Issues detected'}`);
      return buildHealthy;
    } catch (error) {
      this.log(`âŒ Build health check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async performUltimateHealthCheck() {
    this.log("ðŸš€ Starting ultimate comprehensive health check...");
    
    const results = {
      pm2: false,
      githubActions: false,
      netlifyFunctions: false,
      git: false,
      build: false,
      timestamp: new Date().toISOString()
    };

    try {
      // Parallel health checks
      const [pm2Health, githubHealth, netlifyHealth, gitHealth, buildHealth] = await Promise.allSettled([
        this.checkPM2UltimateHealth(),
        this.checkGitHubActionsUltimateHealth(),
        this.checkNetlifyFunctionsUltimateHealth(),
        this.checkGitUltimateHealth(),
        this.checkBuildUltimateHealth()
      ]);

      results.pm2 = pm2Health.status === 'fulfilled' ? pm2Health.value : false;
      results.githubActions = githubHealth.status === 'fulfilled' ? githubHealth.value : false;
      results.netlifyFunctions = netlifyHealth.status === 'fulfilled' ? netlifyHealth.value : false;
      results.git = gitHealth.status === 'fulfilled' ? gitHealth.value : false;
      results.build = buildHealth.status === 'fulfilled' ? buildHealth.value : false;

      // Generate health report
      const healthyServices = Object.values(results).filter(v => v === true).length - 1; // -1 for timestamp
      const totalServices = 5;
      
      this.log(`ðŸ“Š Ultimate Health Report: ${healthyServices}/${totalServices} services healthy`);
      
      if (healthyServices < totalServices) {
        this.log("âš ï¸ Some services are unhealthy, initiating recovery...", "WARN");
        await this.initiateRecovery(results);
      } else {
        this.log("ðŸŽ‰ All services are healthy!", "INFO");
      }

      // Save health report
      this.saveHealthReport(results);
      
    } catch (error) {
      this.log(`âŒ Ultimate health check failed: ${error.message}`, "ERROR");
    }
  }

  async initiateRecovery(results) {
    this.log("ðŸ”„ Initiating recovery procedures...");
    
    try {
      if (!results.pm2) {
        this.log("ðŸ”§ Recovering PM2 services...");
        await this.startPM2Services();
      }

      if (!results.netlifyFunctions) {
        this.log("ðŸ”§ Recovering Netlify Functions...");
        await this.regenerateNetlifyManifest();
      }

      if (!results.git) {
        this.log("ðŸ”§ Recovering Git repository...");
        await this.resolveGitConflicts();
      }

      if (!results.build) {
        this.log("ðŸ”§ Recovering build system...");
        await this.runCommand("npm", ["run", "build:health-check"]);
      }

      this.log("âœ… Recovery procedures completed");
    } catch (error) {
      this.log(`âŒ Recovery failed: ${error.message}`, "ERROR");
    }
  }

  saveHealthReport(results) {
    try {
      const reportFile = path.join(this.config.logging.logDir, `ultimate-health-report-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(reportFile, JSON.stringify(results, null, 2));
      this.log(`ðŸ“„ Health report saved to: ${reportFile}`);
    } catch (error) {
      this.log(`âŒ Failed to save health report: ${error.message}`, "ERROR");
    }
  }

  initializeMonitoring() {
    this.log("ðŸ”§ Initializing ultimate monitoring system...");
    
    // Set up log rotation
    if (this.config.logging.rotation) {
      this.setupLogRotation();
    }
    
    // Set up health dashboard
    if (this.config.monitoring.healthDashboard) {
      this.setupHealthDashboard();
    }
  }

  setupLogRotation() {
    setInterval(() => {
      this.rotateLogs();
    }, 24 * 60 * 60 * 1000); // Daily
  }

  rotateLogs() {
    try {
      const logFiles = fs.readdirSync(this.config.logging.logDir)
        .filter(f => f.startsWith('ultimate-redundancy-') && f.endsWith('.log'))
        .sort()
        .reverse();

      // Keep only the latest 50 log files
      if (logFiles.length > this.config.logging.maxLogFiles) {
        const filesToDelete = logFiles.slice(this.config.logging.maxLogFiles);
        filesToDelete.forEach(file => {
          fs.unlinkSync(path.join(this.config.logging.logDir, file));
        });
        this.log(`ðŸ—‘ï¸ Rotated ${filesToDelete.length} old log files`);
      }
    } catch (error) {
      this.log(`âŒ Log rotation failed: ${error.message}`, "ERROR");
    }
  }

  setupHealthDashboard() {
    // Create a simple health dashboard endpoint
    this.log("ðŸ“Š Setting up health dashboard...");
  }

  startUltimateMonitoring() {
    this.log("ðŸš€ Starting ultimate monitoring system...");
    
    // Initial health check
    this.performUltimateHealthCheck();
    
    // Continuous monitoring
    setInterval(() => {
      this.performUltimateHealthCheck();
    }, this.config.monitoring.interval);
    
    this.log("âœ… Ultimate monitoring system started");
  }

  async getStatus() {
    return {
      status: "running",
      uptime: process.uptime(),
      config: this.config,
      lastCheck: new Date().toISOString()
    };
=======
  async ensureNetlifyFunctions() {
    try {
      this.log("Ensuring all Netlify functions are healthy...");
      
      // Read the manifest to get function names
      if (fs.existsSync(this.config.netlify.manifestFile)) {
        const manifest = JSON.parse(fs.readFileSync(this.config.netlify.manifestFile, "utf8"));
        
        if (manifest.functions && Array.isArray(manifest.functions)) {
          for (const functionName of manifest.functions) {
            const isHealthy = await this.checkNetlifyFunctionHealth(functionName);
            
            if (!isHealthy) {
              this.log(`Netlify function ${functionName} is unhealthy, attempting to regenerate...`);
              await this.regenerateNetlifyManifest();
              break; // Break after one regeneration attempt
            }
          }
        }
      } else {
        this.log("Netlify functions manifest not found, regenerating...");
        await this.regenerateNetlifyManifest();
      }
    } catch (error) {
      this.log(`Error ensuring Netlify functions: ${error.message}`, "ERROR");
    }
  }

  // Health Monitoring Methods
  async performHealthCheck() {
    this.log("Performing comprehensive health check...");
    
    const healthResults = {
      timestamp: Date.now(),
      pm2: {},
      githubActions: {},
      netlify: {},
      overall: "healthy"
    };
    
    // Check PM2 processes
    for (const processName of this.config.pm2.processes) {
      const processInfo = await this.getPM2ProcessInfo(processName);
      healthResults.pm2[processName] = processInfo;
      
      if (!processInfo || processInfo.status !== "online") {
        healthResults.overall = "unhealthy";
      }
    }
    
    // Check GitHub workflows
    for (const workflow of this.config.githubActions.workflows) {
      const isHealthy = await this.checkGitHubWorkflowStatus(workflow);
      healthResults.githubActions[workflow] = isHealthy;
      
      if (!isHealthy) {
        healthResults.overall = "unhealthy";
      }
    }
    
    // Check Netlify functions
    try {
      if (fs.existsSync(this.config.netlify.manifestFile)) {
        const manifest = JSON.parse(fs.readFileSync(this.config.netlify.manifestFile, "utf8"));
        healthResults.netlify.manifestExists = true;
        healthResults.netlify.functionCount = manifest.functions ? manifest.functions.length : 0;
      } else {
        healthResults.netlify.manifestExists = false;
        healthResults.overall = "unhealthy";
      }
    } catch (error) {
      healthResults.netlify.error = error.message;
      healthResults.overall = "unhealthy";
    }
    
    // Store health results
    this.healthHistory.set(Date.now(), healthResults);
    
    // Clean up old health history (keep last 100 entries)
    const healthKeys = Array.from(this.healthHistory.keys()).sort((a, b) => b - a);
    if (healthKeys.length > 100) {
      healthKeys.slice(100).forEach(key => this.healthHistory.delete(key));
    }
    
    // Update last health check timestamp
    this.lastHealthCheck.set('overall', Date.now());
    
    this.log(`Health check completed. Overall status: ${healthResults.overall}`);
    return healthResults;
  }

  // Main Orchestration Methods
  async startMonitoring() {
    if (this.config.monitoring) {
      this.log("Monitoring is already running");
      return;
    }
    
    this.log("Starting ultimate redundancy monitoring...");
    this.config.monitoring = true;
    
    // Initial health check
    await this.performHealthCheck();
    
    // Start monitoring loop
    this.config.checkInterval = setInterval(async () => {
      try {
        await this.performHealthCheck();
        await this.ensurePM2Processes();
        await this.ensureGitHubWorkflows();
        await this.ensureNetlifyFunctions();
      } catch (error) {
        this.log(`Error in monitoring loop: ${error.message}`, "ERROR");
      }
    }, this.config.pm2.healthCheckInterval);
    
    this.log("Ultimate redundancy monitoring started successfully");
  }

  async stopMonitoring() {
    if (!this.config.monitoring) {
      this.log("Monitoring is not running");
      return;
    }
    
    this.log("Stopping ultimate redundancy monitoring...");
    this.config.monitoring = false;
    
    if (this.config.checkInterval) {
      clearInterval(this.config.checkInterval);
      this.config.checkInterval = null;
    }
    
    this.log("Ultimate redundancy monitoring stopped");
  }

  async getStatus() {
    const status = {
      monitoring: this.config.monitoring,
      lastHealthCheck: this.lastHealthCheck.size > 0 ? 
        Math.max(...Array.from(this.lastHealthCheck.keys())) : null,
      healthHistorySize: this.healthHistory.size,
      restartCounts: Object.fromEntries(this.config.restartCounts),
      config: {
        pm2: {
          processCount: this.config.pm2.processes.length,
          healthCheckInterval: this.config.pm2.healthCheckInterval
        },
        githubActions: {
          workflowCount: this.config.githubActions.workflows.length,
          triggerInterval: this.config.githubActions.triggerInterval
        },
        netlify: {
          healthCheckInterval: this.config.netlify.healthCheckInterval
        }
      }
    };
    
    return status;
  }

  async generateReport() {
    const status = await this.getStatus();
    const latestHealth = this.healthHistory.size > 0 ? 
      this.healthHistory.get(Math.max(...Array.from(this.healthHistory.keys()))) : null;
    
    const report = {
      timestamp: new Date().toISOString(),
      status,
      latestHealth,
      recommendations: []
    };
    
    // Generate recommendations based on health status
    if (latestHealth) {
      if (latestHealth.overall === "unhealthy") {
        report.recommendations.push("System health is degraded. Review PM2 processes, GitHub workflows, and Netlify functions.");
      }
      
      // PM2 recommendations
      Object.entries(latestHealth.pm2).forEach(([processName, processInfo]) => {
        if (!processInfo || processInfo.status !== "online") {
          report.recommendations.push(`PM2 process ${processName} needs attention. Current status: ${processInfo?.status || 'unknown'}`);
        }
      });
      
      // GitHub Actions recommendations
      Object.entries(latestHealth.githubActions).forEach(([workflow, isHealthy]) => {
        if (!isHealthy) {
          report.recommendations.push(`GitHub workflow ${workflow} needs attention.`);
        }
      });
      
      // Netlify recommendations
      if (!latestHealth.netlify.manifestExists) {
        report.recommendations.push("Netlify functions manifest is missing. Regenerate using npm run netlify:manifest");
      }
    }
    
    return report;
  }

  // CLI Interface
  async runCommandLine(args) {
    const command = args[0];
    
    switch (command) {
      case "start":
        await this.startMonitoring();
        break;
      case "stop":
        await this.stopMonitoring();
        break;
      case "status":
        const status = await this.getStatus();
        console.log(JSON.stringify(status, null, 2));
        break;
      case "report":
        const report = await this.generateReport();
        console.log(JSON.stringify(report, null, 2));
        break;
      case "health":
        const health = await this.performHealthCheck();
        console.log(JSON.stringify(health, null, 2));
        break;
      case "ensure":
        await this.ensurePM2Processes();
        await this.ensureGitHubWorkflows();
        await this.ensureNetlifyFunctions();
        this.log("All systems ensured");
        break;
      default:
        console.log(`
Ultimate Redundancy Master - Comprehensive Automation Redundancy System

Usage:
  node automation/ultimate-redundancy-master.cjs <command>

Commands:
  start     - Start monitoring and redundancy management
  stop      - Stop monitoring
  status    - Show current status
  report    - Generate comprehensive health report
  health    - Perform immediate health check
  ensure    - Ensure all systems are running

This system provides redundancy for:
- PM2 process management
- GitHub Actions workflows
- Netlify functions
- Comprehensive health monitoring
- Automatic recovery and restart
        `);
    }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
  }
}

// Main execution
if (require.main === module) {
<<<<<<< HEAD
  const args = process.argv.slice(2);
  const system = new UltimateRedundancyMaster();
  
  switch (args[0]) {
    case 'start':
      console.log("ðŸš€ Ultimate redundancy system started");
      break;
    case 'status':
      console.log(JSON.stringify(system.getStatus(), null, 2));
      break;
    case 'health':
      system.performUltimateHealthCheck();
      break;
    case 'recovery':
      system.initiateRecovery({});
      break;
    default:
      console.log("Usage: node ultimate-redundancy-master.cjs [start|status|health|recovery]");
  }
=======
  const master = new UltimateRedundancyMaster();
  const args = process.argv.slice(2);
  
  master.runCommandLine(args).catch(error => {
    console.error("Fatal error:", error);
    process.exit(1);
  });
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-da67
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = UltimateRedundancyMaster;