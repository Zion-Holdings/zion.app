#!/usr/bin/env node
"use strict";

<<<<<<< HEAD
const { spawnSync, execSync } = require("child_process");
=======
const { spawnSync } = require("child_process");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5b71
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

<<<<<<< HEAD
class MasterRedundancyOrchestrator {
  constructor() {
    this.config = {
      // PM2 Automation Coverage
      pm2: {
        ecosystemFiles: [
          "ecosystem.pm2.cjs",
          "ecosystem.redundancy.cjs"
        ],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor"
        ],
        healthCheckInterval: 30000,
        maxRestartAttempts: 5,
        restartDelay: 5000,
        backupProcesses: [
          "automation:pm2",
          "automation:pm2:restart",
          "automation:pm2:status"
        ]
      },
      
      // GitHub Actions Coverage
      githubActions: {
        workflows: [
          ".github/workflows/marketing-sync.yml",
          ".github/workflows/sync-health.yml"
        ],
        healthCheckInterval: 60000,
        maxFailureThreshold: 3,
        backupTriggers: [
          "gh:trigger",
          "gh:auto-heal"
        ],
        scheduledTasks: [
          "marketing-sync",
          "sync-health"
        ]
      },
      
      // Netlify Functions Coverage
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        healthCheckInterval: 120000,
        maxFailureThreshold: 2,
        criticalFunctions: [
          "netlify-auto-healer-runner",
          "continuous-orchestrator",
          "automation-matrix",
          "maintenance-scheduler"
        ],
        backupTriggers: [
          "netlify:trigger",
          "netlify:manifest"
        ]
      },
      
      // Build System Coverage
      build: {
        commands: [
          "npm run build",
          "npm run build:smart",
          "npm run build:orchestrator",
          "npm run build:recovery"
        ],
        healthCheckInterval: 300000, // 5 minutes
        maxBuildFailures: 3,
        backupCommands: [
          "npm run build:heal",
          "npm run build:auto-fix"
        ]
      },
      
      // Package Scripts Coverage
      packageScripts: {
        critical: [
          "automation:all",
          "redundancy:start",
          "git:sync",
          "content:fix",
          "security:scan"
        ],
        backup: [
          "automation:status",
          "redundancy:health",
          "git:health",
          "healing:scan"
        ]
      },
      
      // Logging Configuration
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024, // 10MB
        maxLogFiles: 30,
        logLevels: ["INFO", "WARN", "ERROR", "DEBUG"]
      }
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
    this.startHealthChecks();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
=======
// Import the enhanced redundancy systems
const EnhancedPM2Redundancy = require("./enhanced-pm2-redundancy.cjs");
const EnhancedGitHubActionsRedundancy = require("./enhanced-github-actions-redundancy.cjs");
const EnhancedNetlifyFunctionsRedundancy = require("./enhanced-netlify-functions-redundancy.cjs");

class MasterRedundancyOrchestrator {
  constructor() {
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "master-redundancy-orchestrator.log");
    this.ensureLogDir();
    
    this.config = {
      checkInterval: 60000, // 1 minute
      healthCheckTimeout: 30000,
      backupInterval: 900000, // 15 minutes
      maxLogSize: 10 * 1024 * 1024, // 10MB
      systems: {
        pm2: {
          enabled: true,
          priority: 1,
          autoRecovery: true,
          healthThreshold: 0.8
        },
        githubActions: {
          enabled: true,
          priority: 2,
          autoRecovery: true,
          healthThreshold: 0.8
        },
        netlifyFunctions: {
          enabled: true,
          priority: 3,
          autoRecovery: true,
          healthThreshold: 0.8
        }
      },
      monitoring: false,
      checkInterval: null,
      emergencyMode: false
    };
    
    // Initialize redundancy systems
    this.pm2Redundancy = new EnhancedPM2Redundancy();
    this.githubActionsRedundancy = new EnhancedGitHubActionsRedundancy();
    this.netlifyFunctionsRedundancy = new EnhancedNetlifyFunctionsRedundancy();
    
    this.systemStates = new Map();
    this.overallHealth = 1.0;
    this.lastBackup = Date.now();
    this.recoveryAttempts = 0;
    this.maxRecoveryAttempts = 5;
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5b71
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `master-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
=======
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
      this.rotateLogs();
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
  }

  rotateLogs() {
    try {
      const stats = fs.statSync(this.logFile);
      if (stats.size > this.config.maxLogSize) {
        const backupFile = `${this.logFile}.${Date.now()}`;
        fs.renameSync(this.logFile, backupFile);
        this.log("Log file rotated", "INFO");
      }
    } catch (error) {
      // Ignore rotation errors
    }
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5b71
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
<<<<<<< HEAD
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
=======
        cwd: this.workspace,
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 10,
        timeout: options.timeout || this.config.healthCheckTimeout,
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5b71
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  async checkPM2Health() {
    this.log("Checking PM2 process health...");
    
    try {
      const statusResult = await this.runCommand("pm2", ["status", "--no-daemon"]);
      
      if (statusResult.status !== 0) {
        this.log("PM2 status check failed, attempting to restart PM2", "WARN");
        await this.runCommand("pm2", ["kill"]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFiles[0]]);
        return false;
      }

      const processes = this.config.pm2.processes;
      let allHealthy = true;

      for (const processName of processes) {
        const processStatus = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
        
        if (processStatus.status !== 0) {
          this.log(`PM2 process ${processName} not found, restarting...`, "WARN");
          await this.runCommand("pm2", ["restart", processName]);
          allHealthy = false;
        } else {
          // Check if process is actually running
          const statusOutput = processStatus.stdout;
          if (statusOutput.includes("errored") || statusOutput.includes("stopped")) {
            this.log(`PM2 process ${processName} is not running, restarting...`, "WARN");
            await this.runCommand("pm2", ["restart", processName]);
            allHealthy = false;
          }
        }
      }

      if (allHealthy) {
        this.log("All PM2 processes are healthy");
      }

      return allHealthy;
    } catch (error) {
      this.log(`PM2 health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkGitHubActionsHealth() {
    this.log("Checking GitHub Actions health...");
    
    try {
      // Check if workflow files exist and are valid
      for (const workflow of this.config.githubActions.workflows) {
        if (!fs.existsSync(workflow)) {
          this.log(`Workflow file ${workflow} not found`, "ERROR");
          continue;
        }
        
        // Validate YAML syntax (basic check)
        try {
          const content = fs.readFileSync(workflow, 'utf8');
          if (!content.includes('name:') || !content.includes('on:')) {
            this.log(`Workflow file ${workflow} appears to be invalid`, "WARN");
          }
        } catch (error) {
          this.log(`Error reading workflow ${workflow}: ${error.message}`, "ERROR");
        }
      }

      // Check if we can trigger workflows manually
      for (const trigger of this.config.githubActions.backupTriggers) {
        try {
          const result = await this.runCommand("npm", ["run", trigger]);
          if (result.status === 0) {
            this.log(`GitHub Actions trigger ${trigger} is working`);
          } else {
            this.log(`GitHub Actions trigger ${trigger} failed`, "WARN");
          }
        } catch (error) {
          this.log(`Error testing GitHub Actions trigger ${trigger}: ${error.message}`, "WARN");
        }
      }

      return true;
    } catch (error) {
      this.log(`GitHub Actions health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkNetlifyFunctionsHealth() {
    this.log("Checking Netlify functions health...");
    
    try {
      if (!fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        this.log("Netlify functions manifest not found", "ERROR");
        return false;
      }

      const manifest = JSON.parse(fs.readFileSync(this.config.netlifyFunctions.manifestFile, 'utf8'));
      
      if (!manifest.functions || manifest.functions.length === 0) {
        this.log("No Netlify functions found in manifest", "WARN");
        return false;
      }

      this.log(`Found ${manifest.functions.length} Netlify functions`);

      // Check critical functions
      for (const criticalFunc of this.config.netlifyFunctions.criticalFunctions) {
        if (!manifest.functions.includes(criticalFunc)) {
          this.log(`Critical function ${criticalFunc} not found in manifest`, "WARN");
        }
      }

      // Test backup triggers
      for (const trigger of this.config.netlifyFunctions.backupTriggers) {
        try {
          const result = await this.runCommand("npm", ["run", trigger]);
          if (result.status === 0) {
            this.log(`Netlify trigger ${trigger} is working`);
          } else {
            this.log(`Netlify trigger ${trigger} failed`, "WARN");
          }
        } catch (error) {
          this.log(`Error testing Netlify trigger ${trigger}: ${error.message}`, "WARN");
        }
      }

      return true;
    } catch (error) {
      this.log(`Netlify functions health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkBuildSystemHealth() {
    this.log("Checking build system health...");
    
    try {
      // Check if build commands are available
      for (const command of this.config.build.commands) {
        try {
          const result = await this.runCommand("npm", ["run", command.replace("npm run ", "")]);
          if (result.status === 0) {
            this.log(`Build command ${command} is working`);
          } else {
            this.log(`Build command ${command} failed`, "WARN");
          }
        } catch (error) {
          this.log(`Error testing build command ${command}: ${error.message}`, "WARN");
        }
      }

      return true;
    } catch (error) {
      this.log(`Build system health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkPackageScriptsHealth() {
    this.log("Checking package scripts health...");
    
    try {
      // Check critical scripts
      for (const script of this.config.packageScripts.critical) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Critical script ${script} is working`);
          } else {
            this.log(`Critical script ${script} failed`, "WARN");
          }
        } catch (error) {
          this.log(`Error testing critical script ${script}: ${error.message}`, "WARN");
        }
      }

      return true;
    } catch (error) {
      this.log(`Package scripts health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async runFullHealthCheck() {
    this.log("Running full health check...");
    
    const results = {
      pm2: await this.checkPM2Health(),
      githubActions: await this.checkGitHubActionsHealth(),
      netlifyFunctions: await this.checkNetlifyFunctionsHealth(),
      buildSystem: await this.checkBuildSystemHealth(),
      packageScripts: await this.checkPackageScriptsHealth(),
      timestamp: new Date().toISOString()
    };

    const allHealthy = Object.values(results).filter(v => typeof v === 'boolean').every(v => v);
    
    if (allHealthy) {
      this.log("All systems are healthy");
    } else {
      this.log("Some systems have issues, check logs for details", "WARN");
    }

    // Save health check results
    const healthFile = path.join(this.config.logging.logDir, `health-check-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(healthFile, JSON.stringify(results, null, 2));

    return results;
  }

Timestamp: ${results.timestamp}
Uptime: ${this.getUptime()}

ðŸ“Š System Health Summary:
Total Systems: ${results.summary.total}
Healthy: ${results.summary.healthy}
Unhealthy: ${results.summary.unhealthy}
Failed: ${results.summary.failed}

ðŸ” Individual System Status:
${systemStatus}

ðŸ”— Cross-System Issues:
${crossSystemIssues}

ðŸ’¡ Recommendations:
${recommendations}

${results.summary.healthy === results.summary.total ? 
  "ðŸŽ‰ All redundancy systems are operating normally!" : 
  "âš ï¸ Some redundancy systems require attention. Check recommendations above."}
`;
  }

  getUptime() {
    if (!this.startupTime) return "Not started";
    
    const uptime = Date.now() - this.startupTime.getTime();
    const days = Math.floor(uptime / (1000 * 60 * 60 * 24));
    const hours = Math.floor((uptime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
    
    return `${days}d ${hours}h ${minutes}m`;
  }

  saveOrchestratedHealthReport(results) {
    try {
      const reportPath = path.join(this.logDir, `orchestrated-health-report-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      this.log(`ðŸ“ Orchestrated health report saved to ${reportPath}`);
    } catch (error) {
      this.log(`âŒ Failed to save orchestrated health report: ${error.message}`, "ERROR");
    }
  }

  updatePerformanceMetrics(results) {
    const timestamp = new Date().toISOString();
    
    for (const [systemName, systemResult] of Object.entries(results.systems)) {
      if (!this.performanceMetrics.has(systemName)) {
        this.performanceMetrics.set(systemName, []);
      }
      
      const metrics = this.performanceMetrics.get(systemName);
      metrics.push({
        timestamp,
        status: systemResult.status,
        responseTime: Date.now() - new Date(results.timestamp).getTime()
      });
      
      // Keep only last 100 metrics per system
      if (metrics.length > 100) {
        metrics.splice(0, metrics.length - 100);
      }
    }
  }

  async startOrchestration() {
    if (this.monitoring) {
      this.log("âš ï¸ Orchestration is already running");
      return;
    }

    this.log("ðŸš€ Starting master redundancy orchestration...");
    
    try {
      // Initialize systems
      const initialized = await this.initializeSystems();
      if (!initialized) {
        throw new Error("Failed to initialize systems");
      }

      // Start systems
      const started = await this.startSystems();
      if (!started) {
        throw new Error("Failed to start systems");
      }

      this.monitoring = true;

      // Set up orchestrated monitoring
      this.orchestrationInterval = setInterval(async () => {
        await this.performOrchestratedHealthCheck();
      }, this.config.orchestration.healthCheckInterval);

      this.log("âœ… Master redundancy orchestration started successfully");
    } catch (error) {
      this.log(`âŒ Failed to start orchestration: ${error.message}`, "ERROR");
      throw error;
    }
  }

  async stopOrchestration() {
    if (!this.monitoring) {
      this.log("âš ï¸ Orchestration is not running");
      return;
    }

    this.log("ðŸ›‘ Stopping master redundancy orchestration...");
    this.monitoring = false;

    if (this.orchestrationInterval) {
      clearInterval(this.orchestrationInterval);
      this.orchestrationInterval = null;
    }

    // Stop all systems
    for (const [systemName, system] of Object.entries(this.systems)) {
      try {
        if (system && typeof system.stopMonitoring === 'function') {
          await system.stopMonitoring();
          this.log(`âœ… Stopped ${systemName} system`);
        }
      } catch (error) {
        this.log(`âš ï¸ Error stopping ${systemName} system: ${error.message}`, "WARN");
      }
    }

    this.log("âœ… Master redundancy orchestration stopped");
  }

  async emergencyRecovery() {
    this.log("ðŸš¨ Starting emergency recovery for all systems...");
    
    try {
      for (const [systemName, system] of Object.entries(this.systems)) {
        try {
          if (system && typeof system.emergencyRecovery === 'function') {
            this.log(`ðŸš¨ Starting emergency recovery for ${systemName} system...`);
            await system.emergencyRecovery();
            this.log(`âœ… Emergency recovery completed for ${systemName} system`);
          }
        } catch (error) {
          this.log(`âŒ Emergency recovery failed for ${systemName} system: ${error.message}`, "ERROR");
        }
      }

      this.log("âœ… Emergency recovery completed for all systems");
      return true;
    } catch (error) {
      this.log(`âŒ Emergency recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  getStatus() {
    return {
      monitoring: this.monitoring,
      config: this.config,
      systemStatus: Object.fromEntries(this.systemStatus),
      performanceMetrics: Object.fromEntries(this.performanceMetrics),
      startupTime: this.startupTime,
      uptime: this.getUptime()
    };
  }
}

// Start the master redundancy orchestrator
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  
  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\nðŸ›‘ Shutting down master redundancy orchestrator...');
    await orchestrator.stopOrchestration();
    process.exit(0);
  });
  
  process.on('SIGTERM', async () => {
    console.log('\nðŸ›‘ Terminating master redundancy orchestrator...');
    await orchestrator.stopOrchestration();
    process.exit(0);
  });

  // Start orchestration
  orchestrator.startOrchestration().catch(error => {
    console.error('Failed to start orchestration:', error);
    process.exit(1);
  });
=======
  async startHealthChecks() {
    this.log("Starting health check monitoring...");
    
    // Run initial health check
    await this.runFullHealthCheck();
    
    // Set up periodic health checks
    setInterval(async () => {
      await this.runFullHealthCheck();
    }, this.config.pm2.healthCheckInterval);
  }

  async initializeMonitoring() {
    this.log("Initializing master redundancy monitoring...");
    
    // Ensure all required directories exist
    const requiredDirs = [
      this.config.logging.logDir,
      "automation/backups",
      "automation/redundancy"
    ];
    
    for (const dir of requiredDirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        this.log(`Created directory: ${dir}`);
      }
    }
  }

  async generateRedundancyReport() {
    this.log("Generating redundancy report...");
    
    const report = {
      timestamp: new Date().toISOString(),
      systems: {
        pm2: {
          status: "monitored",
          processes: this.config.pm2.processes.length,
          ecosystemFiles: this.config.pm2.ecosystemFiles.length
        },
        githubActions: {
          status: "monitored",
          workflows: this.config.githubActions.workflows.length,
          scheduledTasks: this.config.githubActions.scheduledTasks.length
        },
        netlifyFunctions: {
          status: "monitored",
          criticalFunctions: this.config.netlifyFunctions.criticalFunctions.length
        },
        buildSystem: {
          status: "monitored",
          commands: this.config.build.commands.length
        },
        packageScripts: {
          status: "monitored",
          critical: this.config.packageScripts.critical.length
        }
      },
      redundancy: {
        pm2Backup: this.config.pm2.backupProcesses,
        githubBackup: this.config.githubActions.backupTriggers,
        netlifyBackup: this.config.netlifyFunctions.backupTriggers,
        buildBackup: this.config.build.backupCommands,
        scriptsBackup: this.config.packageScripts.backup
      }
    };

    const reportFile = path.join(this.config.logging.logDir, `redundancy-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    this.log(`Redundancy report generated: ${reportFile}`);
    return report;
  }

  async start() {
    this.log("Starting Master Redundancy Orchestrator...");
    
    try {
      await this.initializeMonitoring();
      await this.runFullHealthCheck();
      await this.generateRedundancyReport();
      
      this.log("Master Redundancy Orchestrator started successfully");
      
      // Keep the process running
      setInterval(() => {
        // Heartbeat
        this.log("Master Redundancy Orchestrator heartbeat");
      }, 300000); // 5 minutes
      
    } catch (error) {
      this.log(`Error starting Master Redundancy Orchestrator: ${error.message}`, "ERROR");
=======
  async checkSystemHealth(systemName) {
    try {
      let health = 0;
      let details = {};

      switch (systemName) {
        case 'pm2':
          if (this.config.systems.pm2.enabled) {
            const report = await this.pm2Redundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;

        case 'githubActions':
          if (this.config.systems.githubActions.enabled) {
            const report = await this.githubActionsRedundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;

        case 'netlifyFunctions':
          if (this.config.systems.netlifyFunctions.enabled) {
            const report = await this.netlifyFunctionsRedundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;
      }

      return { health, details };
    } catch (error) {
      this.log(`Error checking ${systemName} health: ${error.message}`, "ERROR");
      return { health: 0, details: { error: error.message } };
    }
  }

  async backupAllSystems() {
    try {
      const backupDir = path.join(this.workspace, "automation/backups/master");
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(backupDir, `master-backup-${timestamp}`);
      fs.mkdirSync(backupPath, { recursive: true });

      // Backup PM2 ecosystem files
      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.backupEcosystemFiles();
      }

      // Backup GitHub Actions workflows
      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.backupWorkflows();
      }

      // Backup Netlify functions
      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.backupFunctions();
      }

      // Backup configuration files
      const configFiles = [
        "ecosystem.pm2.cjs",
        "ecosystem.redundancy.cjs",
        ".github/workflows/",
        "netlify/",
        "automation/redundancy-config.json"
      ];

      for (const configFile of configFiles) {
        const sourcePath = path.join(this.workspace, configFile);
        if (fs.existsSync(sourcePath)) {
          const targetPath = path.join(backupPath, configFile);
          if (fs.lstatSync(sourcePath).isDirectory()) {
            await this.runCommand("cp", ["-r", sourcePath, targetPath]);
          } else {
            fs.copyFileSync(sourcePath, targetPath);
          }
        }
      }

      this.log(`Master backup completed: ${backupPath}`, "INFO");
      this.lastBackup = Date.now();
      return true;
    } catch (error) {
      this.log(`Failed to backup all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async restoreAllSystems(backupTimestamp = null) {
    try {
      this.log("Starting system-wide restoration", "WARN");
      
      // Stop all monitoring
      await this.stopAllMonitoring();

      // Restore each system
      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.restoreFromBackup();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.restoreWorkflowsFromBackup();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.restoreFunctionsFromBackup();
      }

      // Restart monitoring
      await this.startAllMonitoring();

      this.log("System-wide restoration completed", "INFO");
      return true;
    } catch (error) {
      this.log(`System-wide restoration failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async startAllMonitoring() {
    try {
      this.log("Starting all redundancy systems", "INFO");

      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.startMonitoring();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.startMonitoring();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.startMonitoring();
      }

      this.log("All redundancy systems started", "INFO");
      return true;
    } catch (error) {
      this.log(`Failed to start all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async stopAllMonitoring() {
    try {
      this.log("Stopping all redundancy systems", "INFO");

      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.stopMonitoring();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.stopMonitoring();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.stopMonitoring();
      }

      this.log("All redundancy systems stopped", "INFO");
      return true;
    } catch (error) {
      this.log(`Failed to stop all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async monitorAllSystems() {
    this.log("Starting master system monitoring...", "INFO");
    
    const systemNames = Object.keys(this.config.systems);
    let totalHealth = 0;
    let healthySystems = 0;

    for (const systemName of systemNames) {
      if (this.config.systems[systemName].enabled) {
        try {
          const { health, details } = await this.checkSystemHealth(systemName);
          
          this.systemStates.set(systemName, { health, details, lastCheck: Date.now() });
          
          if (health >= this.config.systems[systemName].healthThreshold) {
            healthySystems++;
            this.log(`System ${systemName} healthy (${(health * 100).toFixed(1)}%)`, "INFO");
          } else {
            this.log(`System ${systemName} unhealthy (${(health * 100).toFixed(1)}%)`, "WARN");
            
            // Attempt auto-recovery if enabled
            if (this.config.systems[systemName].autoRecovery) {
              await this.attemptSystemRecovery(systemName);
            }
          }
          
          totalHealth += health;
          
        } catch (error) {
          this.log(`Error monitoring system ${systemName}: ${error.message}`, "ERROR");
          this.systemStates.set(systemName, { health: 0, details: { error: error.message }, lastCheck: Date.now() });
        }
      }
    }

    // Calculate overall health
    this.overallHealth = totalHealth / systemNames.length;
    
    // Check if emergency mode is needed
    if (this.overallHealth < 0.5 && !this.config.emergencyMode) {
      await this.enterEmergencyMode();
    } else if (this.overallHealth >= 0.8 && this.config.emergencyMode) {
      await this.exitEmergencyMode();
    }

    this.log(`Overall system health: ${(this.overallHealth * 100).toFixed(1)}% (${healthySystems}/${systemNames.length} healthy)`, "INFO");
  }

  async attemptSystemRecovery(systemName) {
    try {
      this.log(`Attempting recovery for system: ${systemName}`, "WARN");
      
      let recoverySuccess = false;
      
      switch (systemName) {
        case 'pm2':
          recoverySuccess = await this.pm2Redundancy.emergencyRecovery();
          break;
        case 'githubActions':
          recoverySuccess = await this.githubActionsRedundancy.emergencyRecovery();
          break;
        case 'netlifyFunctions':
          recoverySuccess = await this.netlifyFunctionsRedundancy.emergencyRecovery();
          break;
      }

      if (recoverySuccess) {
        this.log(`Successfully recovered system: ${systemName}`, "INFO");
        this.recoveryAttempts = 0;
      } else {
        this.recoveryAttempts++;
        this.log(`Failed to recover system: ${systemName} (attempt ${this.recoveryAttempts})`, "ERROR");
      }

      return recoverySuccess;
    } catch (error) {
      this.log(`Error during system recovery: ${error.message}`, "ERROR");
      return false;
    }
  }

  async enterEmergencyMode() {
    this.config.emergencyMode = true;
    this.log("ðŸš¨ ENTERING EMERGENCY MODE - System health critically low", "ERROR");
    
    try {
      // Stop all monitoring to prevent interference
      await this.stopAllMonitoring();
      
      // Perform emergency backup
      await this.backupAllSystems();
      
      // Attempt full system recovery
      if (this.recoveryAttempts < this.maxRecoveryAttempts) {
        await this.attemptFullSystemRecovery();
      } else {
        this.log("Maximum recovery attempts reached, manual intervention required", "ERROR");
      }
      
      // Restart monitoring
      await this.startAllMonitoring();
      
    } catch (error) {
      this.log(`Emergency mode error: ${error.message}`, "ERROR");
    }
  }

  async exitEmergencyMode() {
    this.config.emergencyMode = false;
    this.log("âœ… EXITING EMERGENCY MODE - System health restored", "INFO");
    this.recoveryAttempts = 0;
  }

  async attemptFullSystemRecovery() {
    try {
      this.log("Attempting full system recovery", "WARN");
      
      // Restore from latest backup
      if (await this.restoreAllSystems()) {
        this.log("Full system recovery successful", "INFO");
        return true;
      }
      
      // If backup restoration fails, try individual system recovery
      const systemNames = Object.keys(this.config.systems);
      let recoveryCount = 0;
      
      for (const systemName of systemNames) {
        if (this.config.systems[systemName].enabled) {
          if (await this.attemptSystemRecovery(systemName)) {
            recoveryCount++;
          }
        }
      }
      
      this.log(`Recovered ${recoveryCount}/${systemNames.length} systems`, "INFO");
      return recoveryCount > 0;
      
    } catch (error) {
      this.log(`Full system recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async generateMasterReport() {
    try {
      const report = {
        timestamp: new Date().toISOString(),
        overallHealth: this.overallHealth,
        emergencyMode: this.config.emergencyMode,
        recoveryAttempts: this.recoveryAttempts,
        systems: {},
        summary: {
          total: Object.keys(this.config.systems).length,
          healthy: 0,
          unhealthy: 0,
          disabled: 0
        }
      };

      for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
        const state = this.systemStates.get(systemName);
        
        if (systemConfig.enabled) {
          if (state && state.health >= systemConfig.healthThreshold) {
            report.summary.healthy++;
          } else {
            report.summary.unhealthy++;
          }
          
          report.systems[systemName] = {
            enabled: true,
            health: state ? state.health : 0,
            priority: systemConfig.priority,
            autoRecovery: systemConfig.autoRecovery,
            lastCheck: state ? state.lastCheck : null,
            details: state ? state.details : {}
          };
        } else {
          report.summary.disabled++;
          report.systems[systemName] = {
            enabled: false,
            health: 0,
            priority: systemConfig.priority,
            autoRecovery: systemConfig.autoRecovery
          };
        }
      }

      // Save report
      const reportPath = path.join(this.logDir, "master-redundancy-report.json");
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      
      this.log(`Master report generated: ${reportPath}`, "INFO");
      return report;
    } catch (error) {
      this.log(`Failed to generate master report: ${error.message}`, "ERROR");
      return null;
    }
  }

  async startMonitoring() {
    if (this.monitoring) {
      this.log("Monitoring already started", "WARN");
      return;
    }

    this.monitoring = true;
    this.log("Starting master redundancy orchestrator", "INFO");

    // Initial backup
    await this.backupAllSystems();

    // Start all system monitoring
    await this.startAllMonitoring();

    // Start master monitoring loop
    this.checkInterval = setInterval(async () => {
      try {
        await this.monitorAllSystems();
        
        // Backup all systems periodically
        if (Date.now() - this.lastBackup > this.config.backupInterval) {
          await this.backupAllSystems();
        }
        
        // Generate master report every 5 minutes
        if (Date.now() % 300000 < this.config.checkInterval) {
          await this.generateMasterReport();
        }
        
      } catch (error) {
        this.log(`Error in master monitoring loop: ${error.message}`, "ERROR");
      }
    }, this.config.checkInterval);

    this.log("Master redundancy orchestrator started", "INFO");
  }

  async stopMonitoring() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    
    await this.stopAllMonitoring();
    this.monitoring = false;
    this.log("Master redundancy orchestrator stopped", "INFO");
  }

  async emergencyShutdown() {
    this.log("ðŸš¨ EMERGENCY SHUTDOWN INITIATED", "ERROR");
    
    try {
      // Stop all monitoring
      await this.stopAllMonitoring();
      
      // Perform final backup
      await this.backupAllSystems();
      
      this.log("Emergency shutdown completed", "INFO");
      process.exit(1);
    } catch (error) {
      this.log(`Emergency shutdown error: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5b71
      process.exit(1);
    }
  }
}

// CLI interface
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  
<<<<<<< HEAD
  const command = process.argv[2] || 'start';
  
  switch (command) {
    case 'start':
      orchestrator.start();
      break;
    case 'health':
      orchestrator.runFullHealthCheck();
      break;
    case 'report':
      orchestrator.generateRedundancyReport();
      break;
    case 'pm2':
      orchestrator.checkPM2Health();
      break;
    case 'github':
      orchestrator.checkGitHubActionsHealth();
      break;
    case 'netlify':
      orchestrator.checkNetlifyFunctionsHealth();
      break;
    case 'build':
      orchestrator.checkBuildSystemHealth();
      break;
    case 'scripts':
      orchestrator.checkPackageScriptsHealth();
      break;
    default:
      console.log(`
Master Redundancy Orchestrator

Usage: node master-redundancy-orchestrator.cjs [command]

Commands:
  start     Start the orchestrator (default)
  health    Run full health check
  report    Generate redundancy report
  pm2       Check PM2 health
  github    Check GitHub Actions health
  netlify   Check Netlify functions health
  build     Check build system health
  scripts   Check package scripts health
      `);
      process.exit(0);
=======
  const command = process.argv[2];
  
  switch (command) {
    case "start":
      orchestrator.startMonitoring();
      break;
    case "stop":
      orchestrator.stopMonitoring();
      break;
    case "status":
      orchestrator.monitorAllSystems();
      break;
    case "report":
      orchestrator.generateMasterReport();
      break;
    case "backup":
      orchestrator.backupAllSystems();
      break;
    case "restore":
      orchestrator.restoreAllSystems();
      break;
    case "recovery":
      orchestrator.attemptFullSystemRecovery();
      break;
    case "emergency":
      orchestrator.enterEmergencyMode();
      break;
    case "shutdown":
      orchestrator.emergencyShutdown();
      break;
    default:
      console.log("Usage: node master-redundancy-orchestrator.cjs [start|stop|status|report|backup|restore|recovery|emergency|shutdown]");
      process.exit(1);
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5b71
  }
}

module.exports = MasterRedundancyOrchestrator;