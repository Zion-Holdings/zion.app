#!/usr/bin/env node
<<<<<<< HEAD
"use strict";

const { spawnSync, execSync, spawn } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

class ComprehensiveRedundancyAutomationSystem {
  constructor() {
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "comprehensive-redundancy-automation.log");
    this.statusFile = path.join(this.workspace, "automation/comprehensive-redundancy-status.json");
    this.ensureLogDir();
    
    this.config = {
      // All PM2 Ecosystems with full coverage
      pm2Ecosystems: [
        "ecosystem.pm2.cjs",
        "ecosystem.redundancy.cjs", 
        "ecosystem.comprehensive-redundancy.cjs",
        "ecosystem.ultimate-redundancy.pm2.cjs",
        "ecosystem.fast-ads.local.cjs",
        "ecosystem.cron.local.cjs"
      ],
      
      // All PM2 Process Groups with complete coverage
      pm2ProcessGroups: {
        core: ["zion-auto-sync", "zion-auto-sync-cron"],
        redundancy: [
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync", 
          "redundancy-build-monitor",
          "pm2-redundancy-monitor",
          "comprehensive-redundancy-orchestrator"
        ],
        fastads: ["fast-ads-orchestrator", "fast-ads-scheduler"],
        cron: ["cron-automation-system", "cron-scheduler"],
        enhanced: [
          "enhanced-pm2-redundancy-manager",
          "enhanced-github-actions-redundancy-manager",
          "enhanced-netlify-functions-redundancy-manager"
        ],
        comprehensive: [
          "comprehensive-pm2-redundancy",
          "comprehensive-github-actions-redundancy",
          "comprehensive-netlify-functions-redundancy"
        ],
        ultimate: [
          "ultimate-redundancy-master",
          "ultimate-redundancy-orchestrator"
        ]
      },
      
      // All GitHub Actions Workflows with complete coverage
      githubWorkflows: [
        "marketing-sync.yml",
        "sync-health.yml",
        "marketing-sync-backup.yml",
        "sync-health-backup.yml"
      ],
      
      // All Netlify Functions from manifest with complete coverage
      netlifyFunctions: [
        "a11y-alt-text-runner",
        "adaptive-orchestrator",
        "ai-changelog-runner",
        "ai-trends-radar-runner",
        "anchor-links-auto-fixer",
        "auto-discovery-runner",
        "auto-scheduler",
        "automation-matrix",
        "autonomous-invention-orchestrator",
        "autonomous-meta-orchestrator",
        "broken-image-scanner",
        "broken-image-scanner-runner",
        "canonical-auditor",
        "cloud_deep_research",
        "cloud_orchestrator",
        "code-smell-audit-runner",
        "component-coupling-graph-runner",
        "component-props-docs-runner",
        "component-size-report",
        "content-freshness-score-runner",
        "continuous-front-runner",
        "continuous-orchestrator",
        "dead-code-audit",
        "dead-code-report",
        "deps-auto-upgrade-runner",
        "docs-index-runner",
        "docs-search-index-runner",
        "duplicate-media-finder-runner",
        "external-link-check-runner",
        "fast-front-promoter",
        "fast-orchestrator",
        "feature-advertiser",
        "features-capabilities-benefits-advertiser",
        "front-ads-promoter",
        "front-enhancer",
        "front-index-futurizer",
        "front-index-orchestrator",
        "front-index-scheduler",
        "front-maximizer",
        "front-visionary-expander",
        "frontpage-enhancer",
        "frontpage-scheduler",
        "headers-enforcer",
        "home-visionary-expander",
        "homepage-advertiser-scheduler",
        "homepage-enhancer",
        "homepage-updater",
        "homepage-updater-scheduler",
        "homepage_advertiser",
        "hyper-front-index-accelerator",
        "image-optimizer-runner",
        "innovation-lab",
        "innovations-promoter",
        "intelligent-meta-orchestrator",
        "internal-link-graph-runner",
        "knowledge-pack-runner",
        "license-compliance-auditor",
        "link-and-health-scheduler",
        "link-crawler",
        "maintenance-scheduler",
        "marketing-and-features-promo",
        "marketing-scheduler",
        "media-og-and-optimize",
        "metadata-optimizer-runner",
        "netlify-auto-healer-runner",
        "newsroom-auto-publisher",
        "newsroom-runner",
        "og-image-update-runner",
        "orphan-pages-detector",
        "pagespeed-insights-runner",
        "readme-advertiser",
        "repo-knowledge-graph-runner",
        "repo-radar-and-graph",
        "repo-radar-runner",
        "revenue-ideas-lab",
        "roadmap-curator",
        "robots-auditor",
        "schedule-content-index",
        "schedule-homepage",
        "schedule-knowledge-graph",
        "schedule-site-health",
        "security-audit",
        "security-audit-runner",
        "seo-audit-runner",
        "site-404-map-runner",
        "site-crawler",
        "sitemap_runner",
        "stale-content-auditor-runner",
        "todo-scanner-runner",
        "todo-summary-runner",
        "topic-cluster-builder-runner",
        "topics-map-runner",
        "trigger-all-and-commit",
        "ui-enhancer",
        "ultrafast-front-orchestrator",
        "ultrafast-orchestrator",
        "unused-media-scanner"
      ],
      
      // Redundancy intervals (in minutes)
      intervals: {
        pm2: 5,
        github: 15,
        netlify: 10,
        health: 2,
        backup: 60
      }
    };
    
    this.status = {
      lastUpdate: new Date().toISOString(),
      pm2: { status: "unknown", processes: {}, lastCheck: null },
      github: { status: "unknown", workflows: {}, lastCheck: null },
      netlify: { status: "unknown", functions: {}, lastCheck: null },
      health: { status: "unknown", score: 0, lastCheck: null },
      redundancy: { status: "unknown", coverage: 0, lastCheck: null }
    };
    
    this.loadStatus();
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}\n`;
    
    fs.appendFileSync(this.logFile, logEntry);
    
    if (level === "ERROR") {
      console.error(`[${timestamp}] [${level}] ${message}`);
    } else if (level === "WARN") {
      console.warn(`[${timestamp}] [${level}] ${message}`);
    } else {
      console.log(`[${timestamp}] [${level}] ${message}`);
    }
  }

  loadStatus() {
    try {
      if (fs.existsSync(this.statusFile)) {
        this.status = { ...this.status, ...JSON.parse(fs.readFileSync(this.statusFile, 'utf8')) };
      }
    } catch (error) {
      this.log(`Failed to load status: ${error.message}`, "ERROR");
    }
  }

  saveStatus() {
    try {
      this.status.lastUpdate = new Date().toISOString();
      fs.writeFileSync(this.statusFile, JSON.stringify(this.status, null, 2));
    } catch (error) {
      this.log(`Failed to save status: ${error.message}`, "ERROR");
    }
  }

  async checkPM2Redundancy() {
    this.log("Checking PM2 redundancy coverage...");
    
    try {
      // Check PM2 status
      const pm2Status = execSync("pm2 status", { encoding: 'utf8' });
      const pm2Processes = [];
      
      // Parse PM2 status output manually since --json might not be available
      const lines = pm2Status.split('\n');
      for (const line of lines) {
        if (line.includes('│') && !line.includes('App name')) {
          const parts = line.split('│').map(p => p.trim()).filter(p => p);
          if (parts.length >= 4) {
            pm2Processes.push({
              name: parts[0],
              pm2_env: {
                status: parts[1] === 'online' ? 'online' : 'offline',
                pm_uptime: Date.now()
              },
              monit: {
                memory: 0,
                cpu: 0
              }
            });
          }
        }
      }
      
      let coverage = 0;
      let totalProcesses = 0;
      let runningProcesses = 0;
      
      // Check each ecosystem
      for (const ecosystem of this.config.pm2Ecosystems) {
        if (fs.existsSync(ecosystem)) {
          totalProcesses++;
          try {
            const ecosystemConfig = require(path.resolve(ecosystem));
            if (ecosystemConfig.apps) {
              for (const app of ecosystemConfig.apps) {
                const process = pm2Processes.find(p => p.name === app.name);
                if (process && process.pm2_env && process.pm2_env.status === "online") {
                  runningProcesses++;
                  this.status.pm2.processes[app.name] = {
                    status: "online",
                    ecosystem: ecosystem,
                    uptime: process.pm2_env.pm_uptime,
                    memory: process.monit.memory,
                    cpu: process.monit.cpu
                  };
                } else {
                  this.status.pm2.processes[app.name] = {
                    status: "offline",
                    ecosystem: ecosystem,
                    error: "Process not running"
                  };
                }
              }
            }
          } catch (error) {
            this.log(`Failed to load ecosystem ${ecosystem}: ${error.message}`, "ERROR");
          }
        }
      }
      
      coverage = totalProcesses > 0 ? (runningProcesses / totalProcesses) * 100 : 0;
      
      this.status.pm2.status = coverage >= 80 ? "healthy" : coverage >= 50 ? "degraded" : "critical";
      this.status.pm2.lastCheck = new Date().toISOString();
      
      this.log(`PM2 redundancy coverage: ${coverage.toFixed(1)}% (${runningProcesses}/${totalProcesses})`);
      
      return { coverage, status: this.status.pm2.status };
    } catch (error) {
      this.log(`PM2 redundancy check failed: ${error.message}`, "ERROR");
      this.status.pm2.status = "error";
      this.status.pm2.lastCheck = new Date().toISOString();
      return { coverage: 0, status: "error" };
    }
  }

  async checkGitHubActionsRedundancy() {
    this.log("Checking GitHub Actions redundancy coverage...");
    
    try {
      const workflowsDir = path.join(this.workspace, ".github/workflows");
      let coverage = 0;
      let totalWorkflows = 0;
      let activeWorkflows = 0;
      
      if (fs.existsSync(workflowsDir)) {
        const workflowFiles = fs.readdirSync(workflowsDir).filter(f => f.endsWith('.yml'));
        totalWorkflows = workflowFiles.length;
        
        for (const workflow of workflowFiles) {
          try {
            const workflowPath = path.join(workflowsDir, workflow);
            const workflowContent = fs.readFileSync(workflowPath, 'utf8');
            
            // Check if workflow has backup
            const hasBackup = workflowFiles.some(f => f.includes('backup') && f.includes(workflow.replace('.yml', '')));
            const isActive = !workflowContent.includes('disabled: true');
            
            if (isActive) {
              activeWorkflows++;
              this.status.github.workflows[workflow] = {
                status: "active",
                hasBackup: hasBackup,
                lastModified: fs.statSync(workflowPath).mtime.toISOString()
              };
            } else {
              this.status.github.workflows[workflow] = {
                status: "disabled",
                hasBackup: hasBackup,
                lastModified: fs.statSync(workflowPath).mtime.toISOString()
              };
            }
          } catch (error) {
            this.log(`Failed to check workflow ${workflow}: ${error.message}`, "ERROR");
          }
        }
      }
      
      coverage = totalWorkflows > 0 ? (activeWorkflows / totalWorkflows) * 100 : 0;
      
      this.status.github.status = coverage >= 80 ? "healthy" : coverage >= 50 ? "degraded" : "critical";
      this.status.github.lastCheck = new Date().toISOString();
      
      this.log(`GitHub Actions redundancy coverage: ${coverage.toFixed(1)}% (${activeWorkflows}/${totalWorkflows})`);
      
      return { coverage, status: this.status.github.status };
    } catch (error) {
      this.log(`GitHub Actions redundancy check failed: ${error.message}`, "ERROR");
      this.status.github.status = "error";
      this.status.github.lastCheck = new Date().toISOString();
      return { coverage: 0, status: "error" };
    }
  }

  async checkNetlifyFunctionsRedundancy() {
    this.log("Checking Netlify Functions redundancy coverage...");
    
    try {
      const functionsDir = path.join(this.workspace, "netlify/functions");
      const manifestPath = path.join(functionsDir, "functions-manifest.json");
      let coverage = 0;
      let totalFunctions = 0;
      let activeFunctions = 0;
      
      if (fs.existsSync(manifestPath)) {
        try {
          const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
          if (manifest.functions && Array.isArray(manifest.functions)) {
            totalFunctions = manifest.functions.length;
            
            for (const funcName of manifest.functions) {
              // Check if function file exists
              const funcPath = path.join(functionsDir, `${funcName}.js`);
              const funcPathCjs = path.join(functionsDir, `${funcName}.cjs`);
              
              let funcExists = false;
              let funcStatus = "missing";
              
              if (fs.existsSync(funcPath) || fs.existsSync(funcPathCjs)) {
                funcExists = true;
                const actualPath = fs.existsSync(funcPath) ? funcPath : funcPathCjs;
                
                try {
                  const funcContent = fs.readFileSync(actualPath, 'utf8');
                  
                  // Check if function is properly structured
                  const hasExports = funcContent.includes('exports.handler') || funcContent.includes('module.exports');
                  const hasErrorHandling = funcContent.includes('try') && funcContent.includes('catch');
                  const hasLogging = funcContent.includes('console.log') || funcContent.includes('console.error');
                  
                  if (hasExports && hasErrorHandling && hasLogging) {
                    activeFunctions++;
                    funcStatus = "active";
                  } else {
                    funcStatus = "incomplete";
                  }
                  
                  this.status.netlify.functions[funcName] = {
                    status: funcStatus,
                    hasExports,
                    hasErrorHandling,
                    hasLogging,
                    lastModified: fs.statSync(actualPath).mtime.toISOString()
                  };
                } catch (error) {
                  this.status.netlify.functions[funcName] = {
                    status: "error",
                    error: error.message,
                    lastModified: new Date().toISOString()
                  };
                }
              } else {
                this.status.netlify.functions[funcName] = {
                  status: "missing",
                  error: "Function file not found",
                  lastModified: new Date().toISOString()
                };
              }
            }
          }
        } catch (error) {
          this.log(`Failed to parse functions manifest: ${error.message}`, "ERROR");
        }
      }
      
      coverage = totalFunctions > 0 ? (activeFunctions / totalFunctions) * 100 : 0;
      
      this.status.netlify.status = coverage >= 80 ? "healthy" : coverage >= 50 ? "degraded" : "critical";
      this.status.netlify.lastCheck = new Date().toISOString();
      
      this.log(`Netlify Functions redundancy coverage: ${coverage.toFixed(1)}% (${activeFunctions}/${totalFunctions})`);
      
      return { coverage, status: this.status.netlify.status };
    } catch (error) {
      this.log(`Netlify Functions redundancy check failed: ${error.message}`, "ERROR");
      this.status.netlify.status = "error";
      this.status.netlify.lastCheck = new Date().toISOString();
      return { coverage: 0, status: "error" };
    }
  }

  async checkOverallHealth() {
    this.log("Checking overall system health...");
    
    try {
      const pm2Health = await this.checkPM2Redundancy();
      const githubHealth = await this.checkGitHubActionsRedundancy();
      const netlifyHealth = await this.checkNetlifyFunctionsRedundancy();
      
      // Calculate overall health score
      const totalCoverage = (pm2Health.coverage + githubHealth.coverage + netlifyHealth.coverage) / 3;
      
      let overallStatus = "unknown";
      if (totalCoverage >= 80) overallStatus = "healthy";
      else if (totalCoverage >= 60) overallStatus = "degraded";
      else if (totalCoverage >= 40) overallStatus = "critical";
      else overallStatus = "failed";
      
      this.status.health.status = overallStatus;
      this.status.health.score = totalCoverage;
      this.status.health.lastCheck = new Date().toISOString();
      
      this.status.redundancy.status = overallStatus;
      this.status.redundancy.coverage = totalCoverage;
      this.status.redundancy.lastCheck = new Date().toISOString();
      
      this.log(`Overall health score: ${totalCoverage.toFixed(1)}% - Status: ${overallStatus}`);
      
      this.saveStatus();
      
      return { score: totalCoverage, status: overallStatus };
    } catch (error) {
      this.log(`Overall health check failed: ${error.message}`, "ERROR");
      return { score: 0, status: "error" };
    }
  }

  async startRedundancyMonitoring() {
    this.log("Starting comprehensive redundancy monitoring...");
    
    // Start monitoring loops
    setInterval(async () => {
      await this.checkOverallHealth();
    }, this.config.intervals.health * 60 * 1000);
    
    setInterval(async () => {
      await this.checkPM2Redundancy();
    }, this.config.intervals.pm2 * 60 * 1000);
    
    setInterval(async () => {
      await this.checkGitHubActionsRedundancy();
    }, this.config.intervals.github * 60 * 1000);
    
    setInterval(async () => {
      await this.checkNetlifyFunctionsRedundancy();
    }, this.config.intervals.netlify * 60 * 1000);
    
    // Initial health check
    await this.checkOverallHealth();
    
    this.log("Comprehensive redundancy monitoring started successfully");
  }

  async createRedundancyBackups() {
    this.log("Creating redundancy backups...");
    
    try {
      const backupDir = path.join(this.workspace, "automation/backups/redundancy");
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      
      // Backup PM2 ecosystems
      for (const ecosystem of this.config.pm2Ecosystems) {
        if (fs.existsSync(ecosystem)) {
          const backupPath = path.join(backupDir, `${ecosystem}.${timestamp}.backup`);
          fs.copyFileSync(ecosystem, backupPath);
        }
      }
      
      // Backup GitHub workflows
      const workflowsDir = path.join(this.workspace, ".github/workflows");
      if (fs.existsSync(workflowsDir)) {
        const workflowsBackupDir = path.join(backupDir, `workflows.${timestamp}`);
        fs.mkdirSync(workflowsBackupDir, { recursive: true });
        
        const workflowFiles = fs.readdirSync(workflowsDir);
        for (const workflow of workflowFiles) {
          if (workflow.endsWith('.yml')) {
            fs.copyFileSync(
              path.join(workflowsDir, workflow),
              path.join(workflowsBackupDir, workflow)
            );
          }
        }
      }
      
      // Backup Netlify functions
      const functionsDir = path.join(this.workspace, "netlify/functions");
      if (fs.existsSync(functionsDir)) {
        const functionsBackupDir = path.join(backupDir, `functions.${timestamp}`);
        fs.mkdirSync(functionsBackupDir, { recursive: true });
        
        const functionFiles = fs.readdirSync(functionsDir);
        for (const func of functionFiles) {
          if (func.endsWith('.js') || func.endsWith('.cjs')) {
            fs.copyFileSync(
              path.join(functionsDir, func),
              path.join(functionsBackupDir, func)
            );
          }
        }
      }
      
      this.log("Redundancy backups created successfully");
      return true;
    } catch (error) {
      this.log(`Failed to create redundancy backups: ${error.message}`, "ERROR");
      return false;
    }
  }

  getStatus() {
    return this.status;
  }

  async runCommand(command, args = []) {
    return new Promise((resolve, reject) => {
      const child = spawn(command, args, {
        stdio: 'pipe',
        shell: true,
        cwd: this.workspace
      });
      
      let stdout = '';
      let stderr = '';
      
      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });
      
      child.on('close', (code) => {
        if (code === 0) {
          resolve({ success: true, stdout, stderr, code });
        } else {
          reject(new Error(`Command failed with code ${code}: ${stderr}`));
        }
      });
      
      child.on('error', (error) => {
        reject(error);
      });
    });
  }
=======

/**
 * 🚀 Comprehensive Redundancy Automation System
 * Provides redundancy for all PM2, GitHub Actions, and Netlify functions automations
 * 
 * Features:
 * - PM2 process monitoring and auto-restart
 * - GitHub Actions workflow health monitoring
 * - Netlify functions execution monitoring
 * - Automated health checks and recovery
 * - Comprehensive logging and reporting
 * - Multi-layer redundancy protection
 */

const fs = require('fs');
const path = require('path');
const { exec, execSync } = require('child_process');
const cron = require('node-cron');

class ComprehensiveRedundancyAutomationSystem {
    constructor() {
        this.config = {
            checkInterval: 30000, // 30 seconds
            healthCheckInterval: 60000, // 1 minute
            recoveryAttempts: 3,
            logFile: 'automation/logs/comprehensive-redundancy.log',
            statusFile: 'automation/logs/redundancy-status.json'
        };
        
        this.status = {
            pm2: { healthy: false, processes: [], lastCheck: null },
            githubActions: { healthy: false, workflows: [], lastCheck: null },
            netlifyFunctions: { healthy: false, functions: [], lastCheck: null },
            system: { healthy: false, lastCheck: null, uptime: null }
        };
        
        this.monitoring = false;
        this.healthCheckJob = null;
        this.monitoringJob = null;
    }

    log(message, level = 'INFO') {
        const timestamp = new Date().toISOString();
        const logEntry = `[${timestamp}] [${level}] ${message}`;
        
        console.log(logEntry);
        
        // Ensure log directory exists
        const logDir = path.dirname(this.config.logFile);
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
        
        // Append to log file
        fs.appendFileSync(this.config.logFile, logEntry + '\n');
    }

    async checkPM2Health() {
        try {
            this.log('Checking PM2 health...');
            
            // Get PM2 status
            const pm2Status = execSync('pm2 jlist', { encoding: 'utf8' });
            const processes = JSON.parse(pm2Status);
            
            const pm2Processes = processes.filter(p => 
                p.name && p.name.includes('zion') || 
                p.name && p.name.includes('automation') ||
                p.name && p.name.includes('redundancy')
            );
            
            this.status.pm2.processes = pm2Processes.map(p => ({
                name: p.name,
                status: p.pm2_env.status,
                restartCount: p.pm2_env.restart_time,
                uptime: p.pm2_env.pm_uptime,
                memory: p.monit.memory,
                cpu: p.monit.cpu
            }));
            
            // Check if all processes are healthy
            const healthyProcesses = pm2Processes.filter(p => 
                p.pm2_env.status === 'online' && 
                p.pm2_env.restart_time < 10
            );
            
            this.status.pm2.healthy = healthyProcesses.length === pm2Processes.length;
            this.status.pm2.lastCheck = new Date().toISOString();
            
            this.log(`PM2 Health Check: ${this.status.pm2.healthy ? 'HEALTHY' : 'UNHEALTHY'} - ${healthyProcesses.length}/${pm2Processes.length} processes healthy`);
            
            return this.status.pm2.healthy;
        } catch (error) {
            this.log(`PM2 Health Check Error: ${error.message}`, 'ERROR');
            this.status.pm2.healthy = false;
            this.status.pm2.lastCheck = new Date().toISOString();
            return false;
        }
    }

    async checkGitHubActionsHealth() {
        try {
            this.log('Checking GitHub Actions health...');
            
            // Check if workflows directory exists and has valid YAML files
            const workflowsDir = '.github/workflows';
            if (!fs.existsSync(workflowsDir)) {
                this.log('GitHub Actions workflows directory not found', 'WARN');
                this.status.githubActions.healthy = false;
                return false;
            }
            
            const workflowFiles = fs.readdirSync(workflowsDir)
                .filter(file => file.endsWith('.yml') || file.endsWith('.yaml'));
            
            this.status.githubActions.workflows = workflowFiles.map(file => ({
                name: file,
                path: path.join(workflowsDir, file),
                lastModified: fs.statSync(path.join(workflowsDir, file)).mtime
            }));
            
            // Check if workflows are properly formatted (basic check)
            let healthyWorkflows = 0;
            for (const workflow of this.status.githubActions.workflows) {
                try {
                    const content = fs.readFileSync(workflow.path, 'utf8');
                    // Basic validation - check for required fields
                    if (content.includes('name:') && content.includes('on:') && content.includes('jobs:')) {
                        healthyWorkflows++;
                    }
                } catch (error) {
                    this.log(`Workflow validation error for ${workflow.name}: ${error.message}`, 'WARN');
                }
            }
            
            this.status.githubActions.healthy = healthyWorkflows === this.status.githubActions.workflows.length;
            this.status.githubActions.lastCheck = new Date().toISOString();
            
            this.log(`GitHub Actions Health Check: ${this.status.githubActions.healthy ? 'HEALTHY' : 'UNHEALTHY'} - ${healthyWorkflows}/${this.status.githubActions.workflows.length} workflows healthy`);
            
            return this.status.githubActions.healthy;
        } catch (error) {
            this.log(`GitHub Actions Health Check Error: ${error.message}`, 'ERROR');
            this.status.githubActions.healthy = false;
            this.status.githubActions.lastCheck = new Date().toISOString();
            return false;
        }
    }

    async checkNetlifyFunctionsHealth() {
        try {
            this.log('Checking Netlify functions health...');
            
            // Check if Netlify functions directory exists
            const functionsDir = 'netlify/functions';
            if (!fs.existsSync(functionsDir)) {
                this.log('Netlify functions directory not found', 'WARN');
                this.status.netlifyFunctions.healthy = false;
                return false;
            }
            
            // Check functions manifest
            const manifestPath = 'netlify/functions/functions-manifest.json';
            if (!fs.existsSync(manifestPath)) {
                this.log('Netlify functions manifest not found', 'WARN');
                this.status.netlifyFunctions.healthy = false;
                return false;
            }
            
            const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
            this.status.netlifyFunctions.functions = manifest.functions || [];
            
            // Check if functions are accessible
            let healthyFunctions = 0;
            for (const funcName of this.status.netlifyFunctions.functions) {
                const funcPath = path.join(functionsDir, `${funcName}.js`);
                if (fs.existsSync(funcPath)) {
                    healthyFunctions++;
                }
            }
            
            this.status.netlifyFunctions.healthy = healthyFunctions > 0 && 
                healthyFunctions === this.status.netlifyFunctions.functions.length;
            this.status.netlifyFunctions.lastCheck = new Date().toISOString();
            
            this.log(`Netlify Functions Health Check: ${this.status.netlifyFunctions.healthy ? 'HEALTHY' : 'UNHEALTHY'} - ${healthyFunctions}/${this.status.netlifyFunctions.functions.length} functions healthy`);
            
            return this.status.netlifyFunctions.healthy;
        } catch (error) {
            this.log(`Netlify Functions Health Check Error: ${error.message}`, 'ERROR');
            this.status.netlifyFunctions.healthy = false;
            this.status.netlifyFunctions.lastCheck = new Date().toISOString();
            return false;
        }
    }

    async performSystemHealthCheck() {
        try {
            this.log('Performing comprehensive system health check...');
            
            const pm2Healthy = await this.checkPM2Health();
            const githubHealthy = await this.checkGitHubActionsHealth();
            const netlifyHealthy = await this.checkNetlifyFunctionsHealth();
            
            // Overall system health
            this.status.system.healthy = pm2Healthy && githubHealthy && netlifyHealthy;
            this.status.system.lastCheck = new Date().toISOString();
            this.status.system.uptime = process.uptime();
            
            this.log(`System Health Check Complete: ${this.status.system.healthy ? 'HEALTHY' : 'UNHEALTHY'}`);
            
            // Save status to file
            this.saveStatus();
            
            return this.status.system.healthy;
        } catch (error) {
            this.log(`System Health Check Error: ${error.message}`, 'ERROR');
            this.status.system.healthy = false;
            this.status.system.lastCheck = new Date().toISOString();
            return false;
        }
    }

    async attemptRecovery() {
        try {
            this.log('Attempting system recovery...');
            
            let recoveryActions = [];
            
            // PM2 Recovery
            if (!this.status.pm2.healthy) {
                this.log('Attempting PM2 recovery...');
                try {
                    execSync('pm2 restart all', { stdio: 'pipe' });
                    recoveryActions.push('PM2 processes restarted');
                } catch (error) {
                    this.log(`PM2 recovery failed: ${error.message}`, 'ERROR');
                }
            }
            
            // GitHub Actions Recovery
            if (!this.status.githubActions.healthy) {
                this.log('Attempting GitHub Actions recovery...');
                try {
                    // Trigger workflow generation if needed
                    if (fs.existsSync('scripts/generate-netlify-functions-manifest.cjs')) {
                        execSync('node scripts/generate-netlify-functions-manifest.cjs', { stdio: 'pipe' });
                        recoveryActions.push('Netlify functions manifest regenerated');
                    }
                } catch (error) {
                    this.log(`GitHub Actions recovery failed: ${error.message}`, 'ERROR');
                }
            }
            
            // Netlify Functions Recovery
            if (!this.status.netlifyFunctions.healthy) {
                this.log('Attempting Netlify functions recovery...');
                try {
                    if (fs.existsSync('scripts/generate-netlify-functions-manifest.cjs')) {
                        execSync('node scripts/generate-netlify-functions-manifest.cjs', { stdio: 'pipe' });
                        recoveryActions.push('Netlify functions manifest regenerated');
                    }
                } catch (error) {
                    this.log(`Netlify functions recovery failed: ${error.message}`, 'ERROR');
                }
            }
            
            if (recoveryActions.length > 0) {
                this.log(`Recovery actions completed: ${recoveryActions.join(', ')}`);
                
                // Wait a bit and recheck health
                setTimeout(async () => {
                    await this.performSystemHealthCheck();
                }, 10000);
            } else {
                this.log('No recovery actions were needed');
            }
            
        } catch (error) {
            this.log(`Recovery attempt failed: ${error.message}`, 'ERROR');
        }
    }

    saveStatus() {
        try {
            const statusDir = path.dirname(this.config.statusFile);
            if (!fs.existsSync(statusDir)) {
                fs.mkdirSync(statusDir, { recursive: true });
            }
            
            fs.writeFileSync(this.config.statusFile, JSON.stringify(this.status, null, 2));
        } catch (error) {
            this.log(`Failed to save status: ${error.message}`, 'ERROR');
        }
    }

    startMonitoring() {
        if (this.monitoring) {
            this.log('Monitoring is already running');
            return;
        }
        
        this.log('Starting comprehensive redundancy monitoring...');
        this.monitoring = true;
        
        // Start health check job
        this.healthCheckJob = cron.schedule('*/1 * * * *', async () => {
            await this.performSystemHealthCheck();
        });
        
        // Start monitoring job
        this.monitoringJob = setInterval(async () => {
            if (!this.status.system.healthy) {
                this.log('System unhealthy detected, attempting recovery...');
                await this.attemptRecovery();
            }
        }, this.config.checkInterval);
        
        this.log('Comprehensive redundancy monitoring started successfully');
    }

    stopMonitoring() {
        if (!this.monitoring) {
            this.log('Monitoring is not running');
            return;
        }
        
        this.log('Stopping comprehensive redundancy monitoring...');
        
        if (this.healthCheckJob) {
            this.healthCheckJob.stop();
            this.healthCheckJob = null;
        }
        
        if (this.monitoringJob) {
            clearInterval(this.monitoringJob);
            this.monitoringJob = null;
        }
        
        this.monitoring = false;
        this.log('Comprehensive redundancy monitoring stopped');
    }

    getStatus() {
        return this.status;
    }

    async generateReport() {
        try {
            await this.performSystemHealthCheck();
            
            const report = {
                timestamp: new Date().toISOString(),
                systemHealth: this.status.system.healthy,
                uptime: this.status.system.uptime,
                components: {
                    pm2: {
                        healthy: this.status.pm2.healthy,
                        processCount: this.status.pm2.processes.length,
                        processes: this.status.pm2.processes
                    },
                    githubActions: {
                        healthy: this.status.githubActions.healthy,
                        workflowCount: this.status.githubActions.workflows.length,
                        workflows: this.status.githubActions.workflows.map(w => w.name)
                    },
                    netlifyFunctions: {
                        healthy: this.status.netlifyFunctions.healthy,
                        functionCount: this.status.netlifyFunctions.functions.length,
                        functions: this.status.netlifyFunctions.functions
                    }
                },
                recommendations: []
            };
            
            // Generate recommendations
            if (!this.status.pm2.healthy) {
                report.recommendations.push('PM2 processes need attention - check logs and restart if necessary');
            }
            
            if (!this.status.githubActions.healthy) {
                report.recommendations.push('GitHub Actions workflows need validation - check YAML syntax and configuration');
            }
            
            if (!this.status.netlifyFunctions.healthy) {
                report.recommendations.push('Netlify functions need attention - regenerate manifest and check function files');
            }
            
            return report;
        } catch (error) {
            this.log(`Report generation failed: ${error.message}`, 'ERROR');
            return { error: error.message };
        }
    }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-28bc
}

// CLI interface
if (require.main === module) {
<<<<<<< HEAD
  const system = new ComprehensiveRedundancyAutomationSystem();
  const command = process.argv[2];
  
  switch (command) {
    case 'start':
      system.startRedundancyMonitoring();
      break;
    case 'status':
      console.log(JSON.stringify(system.getStatus(), null, 2));
      break;
    case 'health':
      system.checkOverallHealth().then(result => {
        console.log(JSON.stringify(result, null, 2));
      });
      break;
    case 'backup':
      system.createRedundancyBackups().then(result => {
        console.log(result ? 'Backups created successfully' : 'Backup failed');
      });
      break;
    case 'pm2':
      system.checkPM2Redundancy().then(result => {
        console.log(JSON.stringify(result, null, 2));
      });
      break;
    case 'github':
      system.checkGitHubActionsRedundancy().then(result => {
        console.log(JSON.stringify(result, null, 2));
      });
      break;
    case 'netlify':
      system.checkNetlifyFunctionsRedundancy().then(result => {
        console.log(JSON.stringify(result, null, 2));
      });
      break;
    default:
      console.log(`
Comprehensive Redundancy Automation System

Usage: node comprehensive-redundancy-automation-system.cjs <command>

Commands:
  start     - Start redundancy monitoring
  status    - Show system status
  health    - Check overall health
  backup    - Create redundancy backups
  pm2       - Check PM2 redundancy
  github    - Check GitHub Actions redundancy
  netlify   - Check Netlify Functions redundancy
=======
    const system = new ComprehensiveRedundancyAutomationSystem();
    const command = process.argv[2] || 'start';
    
    switch (command) {
        case 'start':
            system.startMonitoring();
            break;
        case 'stop':
            system.stopMonitoring();
            break;
        case 'status':
            console.log(JSON.stringify(system.getStatus(), null, 2));
            break;
        case 'health':
            system.performSystemHealthCheck().then(healthy => {
                console.log(`System Health: ${healthy ? 'HEALTHY' : 'UNHEALTHY'}`);
                process.exit(healthy ? 0 : 1);
            });
            break;
        case 'report':
            system.generateReport().then(report => {
                console.log(JSON.stringify(report, null, 2));
            });
            break;
        case 'recovery':
            system.attemptRecovery();
            break;
        default:
            console.log(`
Comprehensive Redundancy Automation System

Usage:
  node comprehensive-redundancy-automation-system.cjs [command]

Commands:
  start     - Start monitoring and health checks
  stop      - Stop monitoring
  status    - Show current system status
  health    - Perform health check
  report    - Generate comprehensive report
  recovery  - Attempt system recovery
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-28bc

Examples:
  node comprehensive-redundancy-automation-system.cjs start
  node comprehensive-redundancy-automation-system.cjs status
<<<<<<< HEAD
      `);
  }
=======
  node comprehensive-redundancy-automation-system.cjs health
            `);
    }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-28bc
}

module.exports = ComprehensiveRedundancyAutomationSystem;