#!/usr/bin/env node
"use strict";

<<<<<<< HEAD
const { spawnSync } = require("child_process");
=======
const { spawnSync, execSync } = require("child_process");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
const fs = require("fs");
const path = require("path");

class ComprehensiveNetlifyFunctionsRedundancy {
  constructor() {
    this.config = {
<<<<<<< HEAD
      functions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        functionsDir: "netlify/functions",
        backupDir: "automation/backup-functions",
        healthCheckInterval: 120000,
        autoHealing: true,
        functionTimeout: 30000,
        maxFailureThreshold: 2
      },
      monitoring: {
        systemHealthCheckInterval: 300000,
        functionValidationInterval: 600000,
        autoRecovery: true,
        backupFunctions: true
      },
      logging: {
        logDir: "automation/logs",
        logLevel: process.env.NETLIFY_FUNCTIONS_REDUNDANCY_LOG_LEVEL || "INFO"
      },
      build: {
        autoBuild: true,
        buildTimeout: 300000,
        buildRetries: 3
      }
    };
    
    this.ensureLogDirectory();
    this.ensureBackupDirectory();
    this.functionStatus = new Map();
    this.failureCounts = new Map();
    this.initializeMonitoring();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
    }
  }

  ensureBackupDirectory() {
    if (!fs.existsSync(this.config.functions.backupDir)) {
      fs.mkdirSync(this.config.functions.backupDir, { recursive: true });
=======
      functionsDir: "netlify/functions",
      manifestFile: "netlify/functions/functions-manifest.json",
      criticalFunctions: [
        "netlify-auto-healer-runner",
        "continuous-orchestrator",
        "site-maintenance-orchestrator",
        "marketing-scheduler",
        "homepage-updater",
        "content-freshness-score-runner"
      ],
      backupFunctions: [
        "netlify-auto-healer-runner-backup",
        "continuous-orchestrator-backup",
        "site-maintenance-orchestrator-backup"
      ],
      healthCheckInterval: 90000,
      maxFailureThreshold: 3,
      logDir: "automation/logs",
      functionTemplate: {
        handler: "exports.handler = async function(event, context) { return { statusCode: 200, body: 'Function is healthy' }; }",
        packageJson: {
          name: "function-name",
          version: "1.0.0",
          main: "index.js"
        }
      }
    };
    
    this.stats = {
      totalFailures: 0,
      functionFailures: {},
      lastHealthCheck: null,
      lastRecovery: null,
      systemHealth: "healthy"
    };
    
    this.ensureLogDirectory();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logDir)) {
      fs.mkdirSync(this.config.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logEntry = `[${timestamp}] [${level}] [NETLIFY-FUNCTIONS-REDUNDANCY] ${message}`;
    
    if (this.shouldLog(level)) {
      console.log(logEntry);
    }
    
    const logFile = path.join(this.config.logging.logDir, `netlify-functions-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
  }

  shouldLog(level) {
    const levels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
    const currentLevel = levels[this.config.logging.logLevel] || 1;
    return levels[level] >= currentLevel;
  }

=======
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logDir, `netlify-functions-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
  }

>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
<<<<<<< HEAD
        timeout: options.timeout || this.config.functions.functionTimeout,
=======
        timeout: 30000,
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
<<<<<<< HEAD
        error: result.error,
        timedOut: result.signal === 'SIGTERM'
=======
        error: result.error
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
      });
    });
  }

<<<<<<< HEAD
  async loadFunctionsManifest() {
    try {
      if (!fs.existsSync(this.config.functions.manifestFile)) {
        this.log("Functions manifest not found", "ERROR");
        return null;
      }

      const manifestContent = fs.readFileSync(this.config.functions.manifestFile, 'utf8');
      const manifest = JSON.parse(manifestContent);
      
      if (!manifest.functions || !Array.isArray(manifest.functions)) {
        this.log("Invalid functions manifest format", "ERROR");
        return null;
      }

      return manifest;
    } catch (error) {
      this.log(`Failed to load functions manifest: ${error.message}`, "ERROR");
      return null;
=======
  async checkManifestFile() {
    try {
      if (!fs.existsSync(this.config.manifestFile)) {
        return { exists: false, valid: false, error: "Manifest file not found" };
      }

      const content = fs.readFileSync(this.config.manifestFile, 'utf8');
      const manifest = JSON.parse(content);
      
      if (!manifest.functions || !Array.isArray(manifest.functions)) {
        return { exists: true, valid: false, error: "Invalid manifest structure" };
      }

      if (manifest.functions.length === 0) {
        return { exists: true, valid: false, error: "No functions in manifest" };
      }

      return { exists: true, valid: true, manifest, error: null };
    } catch (error) {
      return { exists: true, valid: false, error: error.message };
    }
  }

  async checkFunctionFile(functionName) {
    const functionPath = path.join(this.config.functionsDir, `${functionName}.js`);
    
    if (!fs.existsSync(functionPath)) {
      return { exists: false, valid: false, error: "Function file not found" };
    }

    try {
      const content = fs.readFileSync(functionPath, 'utf8');
      
      // Basic validation - check if it has a handler export
      if (!content.includes('exports.handler') && !content.includes('module.exports')) {
        return { exists: true, valid: false, error: "Missing handler export" };
      }

      return { exists: true, valid: true, error: null };
    } catch (error) {
      return { exists: true, valid: false, error: error.message };
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
    }
  }

  async validateFunction(functionName) {
<<<<<<< HEAD
    try {
      // Check if function file exists
      const functionFile = path.join(this.config.functions.functionsDir, `${functionName}.js`);
      const functionFileCjs = path.join(this.config.functions.functionsDir, `${functionName}.cjs`);
      
      if (!fs.existsSync(functionFile) && !fs.existsSync(functionFileCjs)) {
        this.log(`Function file for ${functionName} not found`, "WARN");
        return { valid: false, reason: "file_not_found" };
      }

      // Check if function is properly exported
      const actualFile = fs.existsSync(functionFile) ? functionFile : functionFileCjs;
      const functionContent = fs.readFileSync(actualFile, 'utf8');
      
      // Basic validation - check for exports
      const hasExports = functionContent.includes('exports.') || 
                        functionContent.includes('module.exports') ||
                        functionContent.includes('export default') ||
                        functionContent.includes('export function');
      
      if (!hasExports) {
        this.log(`Function ${functionName} missing exports`, "WARN");
        return { valid: false, reason: "missing_exports" };
      }

      // Check for basic function structure
      const hasFunction = functionContent.includes('function') || 
                         functionContent.includes('=>') ||
                         functionContent.includes('async');
      
      if (!hasFunction) {
        this.log(`Function ${functionName} missing function definition`, "WARN");
        return { valid: false, reason: "missing_function" };
      }

      this.log(`Function ${functionName} validation passed`);
      return { valid: true, reason: "valid" };
    } catch (error) {
      this.log(`Function validation failed for ${functionName}: ${error.message}`, "ERROR");
      return { valid: false, reason: "validation_error" };
    }
  }

  async checkFunctionHealth(functionName) {
    try {
      const validation = await this.validateFunction(functionName);
      
      if (!validation.valid) {
        this.functionStatus.set(functionName, { 
          status: "invalid", 
          healthy: false, 
          reason: validation.reason,
          lastCheck: Date.now() 
        });
        return { status: "invalid", healthy: false, reason: validation.reason };
      }

      // Check if function can be loaded without syntax errors
      try {
        const functionFile = path.join(this.config.functions.functionsDir, `${functionName}.js`);
        const functionFileCjs = path.join(this.config.functions.functionsDir, `${functionName}.cjs`);
        const actualFile = fs.existsSync(functionFile) ? functionFile : functionFileCjs;
        
        // Try to require the function to check for syntax errors
        require(actualFile);
        
        this.functionStatus.set(functionName, { 
          status: "healthy", 
          healthy: true, 
          lastCheck: Date.now() 
        });
        
        return { status: "healthy", healthy: true };
      } catch (requireError) {
        this.log(`Function ${functionName} has syntax errors: ${requireError.message}`, "WARN");
        
        this.functionStatus.set(functionName, { 
          status: "syntax_error", 
          healthy: false, 
          reason: "syntax_error",
          lastCheck: Date.now() 
        });
        
        return { status: "syntax_error", healthy: false, reason: "syntax_error" };
      }
    } catch (error) {
      this.log(`Health check failed for function ${functionName}: ${error.message}`, "ERROR");
      return { status: "error", healthy: false, reason: "check_error" };
    }
  }

  async backupFunction(functionName) {
    try {
      const functionFile = path.join(this.config.functions.functionsDir, `${functionName}.js`);
      const functionFileCjs = path.join(this.config.functions.functionsDir, `${functionName}.cjs`);
      const actualFile = fs.existsSync(functionFile) ? functionFile : functionFileCjs;
      
      if (!fs.existsSync(actualFile)) {
        this.log(`Cannot backup function ${functionName}: file not found`, "WARN");
        return false;
      }

      const backupFile = path.join(this.config.functions.backupDir, `${functionName}-backup.js`);
      const functionContent = fs.readFileSync(actualFile, 'utf8');
      
      // Add backup header
      const backupContent = `// Backup of ${functionName} created at ${new Date().toISOString()}\n// Original file: ${actualFile}\n\n${functionContent}`;
      
      fs.writeFileSync(backupFile, backupContent);
      this.log(`Function ${functionName} backed up to ${backupFile}`);
      
      return true;
    } catch (error) {
      this.log(`Failed to backup function ${functionName}: ${error.message}`, "ERROR");
=======
    this.log(`🔍 Validating function: ${functionName}`);
    
    const validation = await this.checkFunctionFile(functionName);
    
    if (!validation.exists) {
      this.log(`❌ Function file not found: ${functionName}`, "ERROR");
      return false;
    }

    if (!validation.valid) {
      this.log(`⚠️ Function validation failed: ${functionName} - ${validation.error}`, "WARN");
      return false;
    }

    this.log(`✅ Function validation passed: ${functionName}`);
    return true;
  }

  async createBackupFunction(functionName) {
    const sourcePath = path.join(this.config.functionsDir, `${functionName}.js`);
    const backupPath = path.join(this.config.functionsDir, `${functionName}-backup.js`);
    
    try {
      if (fs.existsSync(sourcePath)) {
        fs.copyFileSync(sourcePath, backupPath);
        this.log(`✅ Created backup function: ${backupPath}`);
        return true;
      } else {
        this.log(`⚠️ Source function not found for backup: ${sourcePath}`, "WARN");
        return false;
      }
    } catch (error) {
      this.log(`❌ Failed to create backup function: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
      return false;
    }
  }

  async restoreFunctionFromBackup(functionName) {
<<<<<<< HEAD
    try {
      const backupFile = path.join(this.config.functions.backupDir, `${functionName}-backup.js`);
      
      if (!fs.existsSync(backupFile)) {
        this.log(`Backup file for ${functionName} not found`, "WARN");
        return false;
      }

      const functionFile = path.join(this.config.functions.functionsDir, `${functionName}.js`);
      const backupContent = fs.readFileSync(backupFile, 'utf8');
      
      // Remove backup header and restore original content
      const originalContent = backupContent.replace(/^\/\/ Backup of .+\n\/\/ Original file: .+\n\n/, '');
      
      fs.writeFileSync(functionFile, originalContent);
      this.log(`Function ${functionName} restored from backup`);
      
      return true;
    } catch (error) {
      this.log(`Failed to restore function ${functionName} from backup: ${error.message}`, "ERROR");
      return false;
    }
  }

  async regenerateFunctionsManifest() {
    try {
      this.log("Regenerating functions manifest...");
      
      const manifestScript = "scripts/generate-netlify-functions-manifest.cjs";
      if (fs.existsSync(manifestScript)) {
        const result = await this.runCommand("node", [manifestScript]);
        if (result.status === 0) {
          this.log("Functions manifest regenerated successfully");
          return true;
        } else {
          this.log("Failed to regenerate functions manifest", "ERROR");
          return false;
        }
      } else {
        this.log("Functions manifest generation script not found", "WARN");
        return false;
      }
    } catch (error) {
      this.log(`Error regenerating functions manifest: ${error.message}`, "ERROR");
      return false;
    }
  }

  async triggerNetlifyBuild() {
    try {
      this.log("Triggering Netlify build...");
      
      // Try to trigger build via Netlify CLI if available
      try {
        const result = await this.runCommand("netlify", ["build"]);
        if (result.status === 0) {
          this.log("Netlify build completed successfully");
          return true;
        }
      } catch (error) {
        this.log("Netlify CLI not available, using alternative build method", "WARN");
      }
      
      // Alternative: run npm build script
      if (fs.existsSync("package.json")) {
        const result = await this.runCommand("npm", ["run", "build"]);
        if (result.status === 0) {
          this.log("Build completed via npm script");
          return true;
        }
      }
      
      this.log("Failed to trigger build", "ERROR");
      return false;
    } catch (error) {
      this.log(`Error triggering build: ${error.message}`, "ERROR");
      return false;
    }
  }

  async performFunctionRecovery(functionName) {
    const failures = this.failureCounts.get(functionName) || 0;
    
    if (failures >= this.config.functions.maxFailureThreshold) {
      this.log(`Max failure threshold reached for ${functionName}, attempting recovery`, "WARN");
      
      // Try to restore from backup first
      let recovered = await this.restoreFunctionFromBackup(functionName);
      
      if (!recovered) {
        // If no backup, try to regenerate the function
        this.log(`No backup available for ${functionName}, attempting regeneration`, "WARN");
        recovered = await this.regenerateFunctionsManifest();
      }
      
      if (recovered) {
        this.failureCounts.set(functionName, 0);
        this.log(`Function ${functionName} recovered successfully`);
        return true;
      } else {
        this.log(`Function ${functionName} recovery failed`, "ERROR");
        return false;
      }
    }
    
    return false;
  }

  async checkAllFunctions() {
    this.log("Checking all Netlify functions...");
    
    const manifest = await this.loadFunctionsManifest();
    if (!manifest) {
      this.log("Cannot check functions: manifest not available", "ERROR");
      return false;
    }

    let allHealthy = true;
    
    for (const functionName of manifest.functions) {
      const functionHealth = await this.checkFunctionHealth(functionName);
      
      if (!functionHealth.healthy) {
        allHealthy = false;
        this.log(`Function ${functionName} is unhealthy (${functionHealth.status})`, "WARN");
        
        // Increment failure count
        const currentFailures = this.failureCounts.get(functionName) || 0;
        this.failureCounts.set(functionName, currentFailures + 1);
        
        // Attempt recovery if enabled
        if (this.config.monitoring.autoRecovery) {
          await this.performFunctionRecovery(functionName);
        }
      } else {
        // Reset failure count for healthy functions
        this.failureCounts.set(functionName, 0);
        this.log(`Function ${functionName} is healthy`);
      }
    }
    
    if (allHealthy) {
      this.log("All Netlify functions are healthy");
    } else {
      this.log("Some Netlify functions need attention", "WARN");
    }
=======
    const backupPath = path.join(this.config.functionsDir, `${functionName}-backup.js`);
    const targetPath = path.join(this.config.functionsDir, `${functionName}.js`);
    
    try {
      if (fs.existsSync(backupPath)) {
        fs.copyFileSync(backupPath, targetPath);
        this.log(`✅ Restored function from backup: ${functionName}`);
        return true;
      } else {
        this.log(`⚠️ Backup function not found: ${backupPath}`, "WARN");
        return false;
      }
    } catch (error) {
      this.log(`❌ Failed to restore function from backup: ${error.message}`, "ERROR");
      return false;
    }
  }

  async createBasicFunction(functionName) {
    this.log(`🔄 Creating basic function: ${functionName}`);
    
    try {
      const functionPath = path.join(this.config.functionsDir, `${functionName}.js`);
      
      // Create basic function content
      const functionContent = `// Auto-generated function for ${functionName}
exports.handler = async function(event, context) {
  try {
    // Basic health check response
    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        message: 'Function ${functionName} is operational',
        timestamp: new Date().toISOString(),
        status: 'healthy'
      })
    };
  } catch (error) {
    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        message: 'Function ${functionName} encountered an error',
        error: error.message,
        timestamp: new Date().toISOString()
      })
    };
  }
};`;

      fs.writeFileSync(functionPath, functionContent);
      this.log(`✅ Created basic function: ${functionName}`);
      return true;
    } catch (error) {
      this.log(`❌ Failed to create basic function: ${error.message}`, "ERROR");
      return false;
    }
  }

  async regenerateFunction(functionName) {
    this.log(`🔄 Attempting to regenerate function: ${functionName}`);
    
    try {
      // Try to restore from backup first
      const restored = await this.restoreFunctionFromBackup(functionName);
      
      if (restored) {
        // Validate the restored function
        const valid = await this.validateFunction(functionName);
        if (valid) {
          this.log(`✅ Successfully regenerated function: ${functionName}`);
          return true;
        }
      }

      // If backup restoration failed, try to create a basic function
      return await this.createBasicFunction(functionName);
    } catch (error) {
      this.log(`❌ Error regenerating function: ${error.message}`, "ERROR");
      return false;
    }
  }

  async regenerateManifest() {
    this.log("🔄 Regenerating Netlify functions manifest...");
    
    try {
      const result = await this.runCommand("npm", ["run", "netlify:manifest"]);
      
      if (result.status === 0) {
        this.log("✅ Successfully regenerated functions manifest");
        return true;
      } else {
        this.log(`⚠️ Failed to regenerate manifest: ${result.stderr}`, "WARN");
        return false;
      }
    } catch (error) {
      this.log(`❌ Error regenerating manifest: ${error.message}`, "ERROR");
      return false;
    }
  }

  async performHealthCheck() {
    this.log("🔍 Performing comprehensive Netlify Functions health check...");
    
    let allHealthy = true;
    const failedFunctions = [];

    // Check if functions directory exists
    if (!fs.existsSync(this.config.functionsDir)) {
      this.log(`⚠️ Functions directory not found: ${this.config.functionsDir}`, "WARN");
      fs.mkdirSync(this.config.functionsDir, { recursive: true });
      this.log(`✅ Created functions directory: ${this.config.functionsDir}`);
    }

    // Check manifest file
    const manifestCheck = await this.checkManifestFile();
    if (!manifestCheck.valid) {
      this.log(`⚠️ Functions manifest is invalid: ${manifestCheck.error}`, "WARN");
      allHealthy = false;
      
      // Attempt to regenerate manifest
      const regenerated = await this.regenerateManifest();
      if (regenerated) {
        this.log("✅ Successfully regenerated functions manifest");
      }
    }

    // Validate all critical functions
    for (const functionName of this.config.criticalFunctions) {
      const valid = await this.validateFunction(functionName);
      
      if (!valid) {
        failedFunctions.push(functionName);
        allHealthy = false;
        
        // Track failures
        this.stats.functionFailures[functionName] = (this.stats.functionFailures[functionName] || 0) + 1;
        this.stats.totalFailures++;
      }
    }

    // Check backup functions
    for (const functionName of this.config.backupFunctions) {
      const valid = await this.validateFunction(functionName);
      
      if (!valid) {
        this.log(`⚠️ Backup function validation failed: ${functionName}`, "WARN");
        // Don't count backup function failures as critical
      }
    }

    if (failedFunctions.length > 0) {
      this.log(`🔄 Found ${failedFunctions.length} failed functions: ${failedFunctions.join(", ")}`, "WARN");
      
      // Attempt recovery for failed functions
      for (const functionName of failedFunctions) {
        const recovered = await this.regenerateFunction(functionName);
        if (recovered) {
          this.log(`✅ Successfully recovered function: ${functionName}`);
        } else {
          this.log(`❌ Failed to recover function: ${functionName}`, "ERROR");
        }
      }
    }

    this.stats.lastHealthCheck = new Date().toISOString();
    this.updateSystemHealth();
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
    
    return allHealthy;
  }

<<<<<<< HEAD
  async createBackupFunctions() {
    if (!this.config.monitoring.backupFunctions) {
      return;
    }
    
    this.log("Creating backup functions...");
    
    const manifest = await this.loadFunctionsManifest();
    if (!manifest) {
      return;
    }
    
    for (const functionName of manifest.functions) {
      await this.backupFunction(functionName);
    }
    
    this.log("Backup functions creation completed");
  }

  async performFullRecovery() {
    this.log("Performing full Netlify functions recovery...");
    
    try {
      // Regenerate functions manifest
      await this.regenerateFunctionsManifest();
      
      // Trigger build if enabled
      if (this.config.build.autoBuild) {
        await this.triggerNetlifyBuild();
      }
      
      // Reset failure counts
      this.failureCounts.clear();
      
      this.log("Full Netlify functions recovery completed");
      return true;
    } catch (error) {
      this.log(`Full recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  initializeMonitoring() {
    this.log("Initializing Netlify functions redundancy monitoring...");
    
    // Set up process monitoring
    process.on('SIGINT', () => {
      this.log("Received SIGINT, shutting down gracefully...");
      this.shutdown();
    });
    
    process.on('SIGTERM', () => {
      this.log("Received SIGTERM, shutting down gracefully...");
      this.shutdown();
    });
    
    // Start periodic health checks
    setInterval(() => {
      this.checkAllFunctions();
    }, this.config.functions.healthCheckInterval);
    
    // Start periodic function validation
    setInterval(() => {
      this.validateAllFunctions();
    }, this.config.monitoring.functionValidationInterval);
    
    // Initial setup
    setTimeout(async () => {
      await this.createBackupFunctions();
      await this.checkAllFunctions();
    }, 5000);
  }

  async validateAllFunctions() {
    this.log("Validating all functions...");
    
    const manifest = await this.loadFunctionsManifest();
    if (!manifest) {
      return false;
    }
    
    let allValid = true;
    
    for (const functionName of manifest.functions) {
      const validation = await this.validateFunction(functionName);
      if (!validation.valid) {
        allValid = false;
      }
    }
    
    if (allValid) {
      this.log("All functions validation passed");
    } else {
      this.log("Some functions have validation issues", "WARN");
    }
    
    return allValid;
  }

  async shutdown() {
    this.log("Shutting down Netlify functions redundancy system...");
    
    // Save final status
    const statusFile = path.join(this.config.logging.logDir, "netlify-functions-redundancy-status.json");
    const statusData = {
      functionStatus: Object.fromEntries(this.functionStatus),
      failureCounts: Object.fromEntries(this.failureCounts),
      timestamp: new Date().toISOString()
    };
    
    fs.writeFileSync(statusFile, JSON.stringify(statusData, null, 2));
    
    this.log("Netlify functions redundancy system shutdown complete");
    process.exit(0);
  }

  getStatus() {
    return {
      status: "running",
      uptime: process.uptime(),
      functionStatus: Object.fromEntries(this.functionStatus),
      failureCounts: Object.fromEntries(this.failureCounts),
      config: this.config,
      timestamp: new Date().toISOString()
    };
  }

  async runRecovery() {
    this.log("Running Netlify functions recovery...");
    return await this.performFullRecovery();
  }
}

// Start the system if this file is run directly
if (require.main === module) {
  const system = new ComprehensiveNetlifyFunctionsRedundancy();
  
  // Keep the process alive
  process.stdin.resume();
  
  // Handle graceful shutdown
  process.on('SIGINT', () => {
    system.shutdown();
  });
=======
  async performRecovery() {
    this.log("🚨 Performing Netlify Functions recovery actions...");
    
    try {
      // Ensure all backup functions exist
      for (const functionName of this.config.criticalFunctions) {
        await this.createBackupFunction(functionName);
      }

      // Attempt to restore all failed functions
      let recoveryCount = 0;

      for (const functionName of this.config.criticalFunctions) {
        const validation = await this.checkFunctionFile(functionName);
        
        if (!validation.valid) {
          const recovered = await this.regenerateFunction(functionName);
          if (recovered) recoveryCount++;
        }
      }

      // Regenerate manifest after recovery
      await this.regenerateManifest();

      this.stats.lastRecovery = new Date().toISOString();
      this.log(`✅ Recovery completed. Recovered ${recoveryCount} functions.`);
      
      return recoveryCount;
    } catch (error) {
      this.log(`❌ Recovery failed: ${error.message}`, "ERROR");
      return 0;
    }
  }

  async createAllBackupFunctions() {
    this.log("🔄 Creating backup functions for all critical functions...");
    
    let successCount = 0;
    
    for (const functionName of this.config.criticalFunctions) {
      const success = await this.createBackupFunction(functionName);
      if (success) successCount++;
    }
    
    this.log(`✅ Created ${successCount}/${this.config.criticalFunctions.length} backup functions`);
    return successCount;
  }

  async listAllFunctions() {
    try {
      const manifestCheck = await this.checkManifestFile();
      
      if (manifestCheck.valid && manifestCheck.manifest) {
        return manifestCheck.manifest.functions || [];
      }
      
      // Fallback: scan functions directory
      if (fs.existsSync(this.config.functionsDir)) {
        const files = fs.readdirSync(this.config.functionsDir);
        return files
          .filter(file => file.endsWith('.js'))
          .map(file => file.replace('.js', ''));
      }
      
      return [];
    } catch (error) {
      this.log(`❌ Error listing functions: ${error.message}`, "ERROR");
      return [];
    }
  }

  updateSystemHealth() {
    if (this.stats.totalFailures === 0) {
      this.stats.systemHealth = "healthy";
    } else if (this.stats.totalFailures <= this.config.maxFailureThreshold) {
      this.stats.systemHealth = "warning";
    } else {
      this.stats.systemHealth = "critical";
    }
  }

  async generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      systemHealth: this.stats.systemHealth,
      stats: this.stats,
      config: {
        functionsDir: this.config.functionsDir,
        criticalFunctions: this.config.criticalFunctions.length,
        backupFunctions: this.config.backupFunctions.length
      },
      functions: await this.listAllFunctions()
    };

    const reportFile = path.join(this.config.logDir, `netlify-functions-redundancy-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    return report;
  }

  async startMonitoring() {
    this.log("🚀 Starting comprehensive Netlify Functions redundancy monitoring...");
    
    // Initial health check
    await this.performHealthCheck();
    
    // Start monitoring loop
    setInterval(async () => {
      await this.performHealthCheck();
      await this.generateReport();
    }, this.config.healthCheckInterval);
    
    this.log("✅ Netlify Functions redundancy monitoring started");
  }

  async getStatus() {
    const status = {
      functionsDir: this.config.functionsDir,
      manifestFile: this.config.manifestFile,
      criticalFunctions: this.config.criticalFunctions,
      backupFunctions: this.config.backupFunctions,
      stats: this.stats,
      functions: await this.listAllFunctions()
    };
    
    return status;
  }
}

// CLI interface
if (require.main === module) {
  const manager = new ComprehensiveNetlifyFunctionsRedundancy();
  
  const command = process.argv[2];
  
  switch (command) {
    case 'start':
      manager.startMonitoring();
      break;
    case 'health':
      manager.performHealthCheck().then(healthy => {
        console.log(`System health: ${healthy ? '✅ Healthy' : '❌ Unhealthy'}`);
        process.exit(healthy ? 0 : 1);
      });
      break;
    case 'recovery':
      manager.performRecovery().then(count => {
        console.log(`Recovery completed. Recovered ${count} functions.`);
        process.exit(0);
      });
      break;
    case 'backup':
      manager.createAllBackupFunctions().then(count => {
        console.log(`Backup completed. Created ${count} backup functions.`);
        process.exit(0);
      });
      break;
    case 'manifest':
      manager.regenerateManifest().then(() => {
        console.log('Manifest regeneration completed');
        process.exit(0);
      });
      break;
    case 'list':
      manager.listAllFunctions().then(functions => {
        console.log('Available functions:', functions);
        process.exit(0);
      });
      break;
    case 'status':
      manager.getStatus().then(status => {
        console.log(JSON.stringify(status, null, 2));
        process.exit(0);
      });
      break;
    default:
      console.log('Usage: node comprehensive-netlify-functions-redundancy.cjs [start|health|recovery|backup|manifest|list|status]');
      process.exit(1);
  }
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-ea74
}

module.exports = ComprehensiveNetlifyFunctionsRedundancy;