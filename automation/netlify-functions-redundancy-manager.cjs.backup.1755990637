#!/usr/bin/env node
"use strict";

<<<<<<< HEAD
const { spawnSync } = require("child_process");
=======
const { spawnSync, execSync } = require("child_process");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
const fs = require("fs");
const path = require("path");

class NetlifyFunctionsRedundancyManager {
  constructor() {
<<<<<<< HEAD
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "netlify-functions-redundancy.log");
    this.ensureLogDir();
    
    this.config = {
      // Netlify functions directory
      functionsDir: path.join(this.workspace, "netlify/functions"),
      
      // Expected functions from manifest
      expectedFunctions: [
        "a11y-alt-text-runner",
        "adaptive-orchestrator",
        "ai-changelog-runner",
        "ai-trends-radar-runner",
        "anchor-links-auto-fixer",
        "auto-discovery-runner",
        "auto-scheduler",
        "automation-matrix",
        "autonomous-invention-orchestrator",
        "autonomous-meta-orchestrator",
        "broken-image-scanner",
        "broken-image-scanner-runner",
        "canonical-auditor",
        "cloud_deep_research",
        "cloud_orchestrator",
        "code-smell-audit-runner",
        "component-coupling-graph-runner",
        "component-props-docs-runner",
        "component-size-report",
        "content-freshness-score-runner",
        "continuous-front-runner",
        "continuous-orchestrator",
        "dead-code-audit",
        "dead-code-report",
        "deps-auto-upgrade-runner",
        "docs-index-runner",
        "docs-search-index-runner",
        "duplicate-media-finder-runner",
        "external-link-check-runner",
        "fast-front-promoter",
        "fast-orchestrator",
        "feature-advertiser",
        "features-capabilities-benefits-advertiser",
        "front-ads-promoter",
        "front-enhancer",
        "front-index-futurizer",
        "front-index-orchestrator",
        "front-index-scheduler",
        "front-maximizer",
        "front-visionary-expander",
        "frontpage-enhancer",
        "frontpage-scheduler",
        "headers-enforcer",
        "home-visionary-expander",
        "homepage-advertiser-scheduler",
        "homepage-enhancer",
        "homepage-updater",
        "homepage-updater-scheduler",
        "homepage_advertiser",
        "hyper-front-index-accelerator",
        "image-optimizer-runner",
        "innovation-lab",
        "innovations-promoter",
        "intelligent-meta-orchestrator",
        "internal-link-graph-runner",
        "knowledge-pack-runner",
        "license-compliance-auditor",
        "link-and-health-scheduler",
        "link-crawler",
        "maintenance-scheduler",
        "marketing-and-features-promo",
        "marketing-scheduler",
        "media-og-and-optimize",
        "metadata-optimizer-runner",
        "netlify-auto-healer-runner",
        "newsroom-auto-publisher",
        "newsroom-runner",
        "og-image-update-runner",
        "orphan-pages-detector",
        "pagespeed-insights-runner",
        "readme-advertiser",
        "repo-knowledge-graph-runner",
        "repo-radar-and-graph",
        "repo-radar-runner",
        "revenue-ideas-lab",
        "roadmap-curator",
        "robots-auditor",
        "schedule-content-index",
        "schedule-homepage",
        "schedule-knowledge-graph",
        "schedule-site-health",
        "security-audit",
        "security-audit-runner",
        "seo-audit-runner",
        "site-404-map-runner",
        "site-crawler",
        "sitemap_runner",
        "stale-content-auditor-runner",
        "todo-scanner-runner",
        "todo-summary-runner",
        "topic-cluster-builder-runner",
        "topics-map-runner",
        "trigger-all-and-commit",
        "ui-enhancer",
        "ultrafast-front-orchestrator",
        "ultrafast-orchestrator",
        "unused-media-scanner"
      ],
      
      // Function validation rules
      validationRules: {
        requiredExports: ["handler", "exports.handler"],
        requiredImports: ["require", "import"],
        minFileSize: 100, // Minimum file size in bytes
        maxFileSize: 1024 * 1024, // Maximum file size in bytes (1MB)
        requiredStructure: ["function", "module.exports", "exports"]
      },
      
      // Health check intervals
      healthCheckInterval: 120000, // 2 minutes
      manifestRegenerationInterval: 600000, // 10 minutes
      
      // Error thresholds
      maxValidationErrors: 5,
      maxFunctionFailures: 3
    };
    
    this.monitoring = false;
    this.checkInterval = null;
    this.manifestInterval = null;
    this.healthHistory = new Map();
    this.errorCounts = new Map();
    this.lastManifestRegeneration = new Date();
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
=======
    this.config = {
      // Netlify functions configuration
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        functionsDir: "netlify/functions",
        criticalFunctions: [
          "netlify-auto-healer-runner",
          "continuous-orchestrator",
          "automation-matrix",
          "maintenance-scheduler",
          "netlify-auto-healer-runner",
          "continuous-front-runner",
          "front-index-orchestrator",
          "homepage-updater",
          "marketing-scheduler",
          "link-and-health-scheduler"
        ],
        healthCheckInterval: 120000, // 2 minutes
        maxFailureThreshold: 2
      },
      
      // Backup npm scripts for Netlify operations
      backupScripts: {
        trigger: [
          "netlify:trigger",
          "netlify:manifest"
        ],
        build: [
          "build",
          "build:smart",
          "build:orchestrator"
        ],
        deploy: [
          "export",
          "start"
        ]
      },
      
      // Function execution scripts
      functionScripts: {
        "netlify-auto-healer-runner": "automation/enhanced-netlify-healer.cjs",
        "continuous-orchestrator": "automation/continuous-orchestrator.cjs",
        "automation-matrix": "automation/automation-matrix.cjs",
        "maintenance-scheduler": "automation/maintenance-scheduler.cjs",
        "continuous-front-runner": "automation/continuous-front-runner.cjs",
        "front-index-orchestrator": "automation/front-index-orchestrator.cjs",
        "homepage-updater": "automation/homepage-updater.cjs",
        "marketing-scheduler": "automation/marketing-scheduler.cjs",
        "link-and-health-scheduler": "automation/link-and-health-scheduler.cjs"
      },
      
      // Health check configuration
      healthCheck: {
        interval: 120000, // 2 minutes
        maxFailureThreshold: 2,
        functionValidation: true,
        manifestValidation: true
      },
      
      // Logging configuration
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024, // 10MB
        maxLogFiles: 30
      }
    };
    
    this.ensureLogDirectory();
    this.functionStatus = new Map();
    this.failureCounts = new Map();
    this.lastRunTimes = new Map();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
=======
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `netlify-functions-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
<<<<<<< HEAD
        cwd: this.workspace,
=======
        cwd: process.cwd(),
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
<<<<<<< HEAD
        timeout: options.timeout || 30000,
=======
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  // Check if functions directory exists
  checkFunctionsDirectory() {
    if (!fs.existsSync(this.config.functionsDir)) {
      this.log("Netlify functions directory not found", "ERROR");
      return false;
    }
    
    this.log("Netlify functions directory found", "INFO");
    return true;
  }

  // List all function files
  listFunctionFiles() {
    try {
      if (!fs.existsSync(this.config.functionsDir)) {
        return [];
      }
      
      const files = fs.readdirSync(this.config.functionsDir);
      return files.filter(file => file.endsWith('.js') || file.endsWith('.mjs'));
    } catch (error) {
      this.log(`Failed to list function files: ${error.message}`, "ERROR");
      return [];
    }
  }

  // Get functions manifest
  getFunctionsManifest() {
    try {
      const manifestPath = path.join(this.config.functionsDir, "functions-manifest.json");
      
      if (!fs.existsSync(manifestPath)) {
        this.log("Functions manifest not found", "WARN");
        return null;
      }
      
      const manifestContent = fs.readFileSync(manifestPath, 'utf8');
      const manifest = JSON.parse(manifestContent);
      
      this.log(`Functions manifest loaded with ${manifest.functions?.length || 0} functions`, "INFO");
      return manifest;
    } catch (error) {
      this.log(`Failed to load functions manifest: ${error.message}`, "ERROR");
      return null;
    }
  }

  // Validate individual function
  async validateFunction(filename) {
    try {
      const filepath = path.join(this.config.functionsDir, filename);
      
      if (!fs.existsSync(filepath)) {
        return {
          valid: false,
          error: "File not found",
          filename: filename
        };
      }
      
      const stats = fs.statSync(filepath);
      const content = fs.readFileSync(filepath, 'utf8');
      
      const validation = {
        valid: true,
        filename: filename,
        size: stats.size,
        lastModified: stats.mtime,
        errors: []
      };
      
      // Check file size
      if (stats.size < this.config.validationRules.minFileSize) {
        validation.errors.push(`File too small: ${stats.size} bytes`);
        validation.valid = false;
      }
      
      if (stats.size > this.config.validationRules.maxFileSize) {
        validation.errors.push(`File too large: ${stats.size} bytes`);
        validation.valid = false;
      }
      
      // Check for required exports
      const hasHandlerExport = this.config.validationRules.requiredExports.some(exportPattern => {
        if (exportPattern.includes('.')) {
          return content.includes(exportPattern);
        } else {
          return content.includes(`exports.${exportPattern}`) || content.includes(`module.exports.${exportPattern}`);
        }
      });
      
      if (!hasHandlerExport) {
        validation.errors.push("Missing handler export");
        validation.valid = false;
      }
      
      // Check for required structure
      const hasRequiredStructure = this.config.validationRules.requiredStructure.some(pattern => 
        content.includes(pattern)
      );
      
      if (!hasRequiredStructure) {
        validation.errors.push("Missing required structure patterns");
        validation.valid = false;
      }
      
      // Check for basic syntax (try to parse as JavaScript)
      try {
        // Basic syntax check - look for common syntax errors
        if (content.includes('function') && !content.includes('{')) {
          validation.errors.push("Potential syntax error: function without body");
          validation.valid = false;
        }
        
        if (content.includes('exports.') && !content.includes('=')) {
          validation.errors.push("Potential syntax error: incomplete export");
          validation.valid = false;
        }
        
      } catch (syntaxError) {
        validation.errors.push(`Syntax error: ${syntaxError.message}`);
        validation.valid = false;
      }
      
      return validation;
      
    } catch (error) {
      return {
        valid: false,
        error: error.message,
        filename: filename
      };
    }
  }

  // Validate all functions
  async validateAllFunctions() {
    try {
      this.log("Validating all Netlify functions", "INFO");
      
      const functionFiles = this.listFunctionFiles();
      if (functionFiles.length === 0) {
        this.log("No function files found", "WARN");
        return { valid: false, functions: [] };
      }
      
      const validationResults = [];
      let overallValid = true;
      
      for (const filename of functionFiles) {
        const result = await this.validateFunction(filename);
        validationResults.push(result);
        
        if (!result.valid) {
          overallValid = false;
          this.log(`Function ${filename} validation failed: ${result.errors?.join(', ') || result.error}`, "ERROR");
          
          // Increment error count
          const currentCount = this.errorCounts.get(filename) || 0;
          this.errorCounts.set(filename, currentCount + 1);
        } else {
          this.log(`Function ${filename} validation passed`, "INFO");
          // Reset error count on success
          this.errorCounts.set(filename, 0);
        }
      }
      
      return {
        valid: overallValid,
        functions: validationResults,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      this.log(`Function validation failed: ${error.message}`, "ERROR");
      return { valid: false, error: error.message };
    }
  }

  // Check function dependencies
  async checkFunctionDependencies() {
    try {
      this.log("Checking function dependencies", "INFO");
      
      const functionFiles = this.listFunctionFiles();
      const dependencyResults = {};
      
      for (const filename of functionFiles) {
        const filepath = path.join(this.config.functionsDir, filename);
        const content = fs.readFileSync(filepath, 'utf8');
        
        // Extract require statements
        const requireMatches = content.match(/require\(['"`]([^'"`]+)['"`]\)/g) || [];
        const importMatches = content.match(/import\s+.*from\s+['"`]([^'"`]+)['"`]/g) || [];
        
        const dependencies = [
          ...requireMatches.map(match => match.replace(/require\(['"`]([^'"`]+)['"`]\)/, '$1')),
          ...importMatches.map(match => match.replace(/import\s+.*from\s+['"`]([^'"`]+)['"`]/, '$1'))
        ];
        
        dependencyResults[filename] = {
          dependencies: dependencies,
          count: dependencies.length
        };
      }
      
      return dependencyResults;
      
    } catch (error) {
      this.log(`Function dependency check failed: ${error.message}`, "ERROR");
      return {};
    }
  }

  // Regenerate functions manifest
  async regenerateFunctionsManifest() {
    try {
      this.log("Regenerating functions manifest", "INFO");
      
      const manifestScript = path.join(this.workspace, "scripts/generate-netlify-functions-manifest.cjs");
      
      if (!fs.existsSync(manifestScript)) {
        this.log("Manifest generation script not found", "ERROR");
        return false;
      }
      
      const result = await this.runCommand("node", [manifestScript]);
      
      if (result.status === 0) {
        this.lastManifestRegeneration = new Date();
        this.log("Functions manifest regenerated successfully", "INFO");
        return true;
      } else {
        this.log(`Failed to regenerate manifest: ${result.stderr}`, "ERROR");
        return false;
      }
      
    } catch (error) {
      this.log(`Manifest regeneration failed: ${error.message}`, "ERROR");
=======
  validateManifestFile() {
    try {
      if (!fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        return { valid: false, error: "Manifest file not found" };
      }
      
      const content = fs.readFileSync(this.config.netlifyFunctions.manifestFile, 'utf8');
      
      try {
        const manifest = JSON.parse(content);
        
        if (!manifest.functions || !Array.isArray(manifest.functions)) {
          return { valid: false, error: "Invalid functions array in manifest" };
        }
        
        if (!manifest.generatedAt) {
          return { valid: false, error: "Missing generation timestamp" };
        }
        
        return { valid: true, manifest };
      } catch (jsonError) {
        return { valid: false, error: `JSON parsing error: ${jsonError.message}` };
      }
    } catch (error) {
      return { valid: false, error: `File read error: ${error.message}` };
    }
  }

  async checkFunctionHealth(functionName) {
    this.log(`Checking function health: ${functionName}`);
    
    try {
      // Check if function exists in manifest
      const manifestValidation = this.validateManifestFile();
      if (!manifestValidation.valid) {
        this.log(`Manifest validation failed: ${manifestValidation.error}`, "ERROR");
        return false;
      }
      
      const manifest = manifestValidation.manifest;
      const functionExists = manifest.functions.includes(functionName);
      
      if (!functionExists) {
        this.log(`Function ${functionName} not found in manifest`, "WARN");
        return false;
      }
      
      // Check if function file exists
      const functionFile = path.join(this.config.netlifyFunctions.functionsDir, `${functionName}.js`);
      if (!fs.existsSync(functionFile)) {
        this.log(`Function file not found: ${functionFile}`, "ERROR");
        return false;
      }
      
      // Check if function has a backup script
      const backupScript = this.config.functionScripts[functionName];
      if (backupScript && fs.existsSync(backupScript)) {
        this.log(`Function ${functionName} has backup script: ${backupScript}`);
      }
      
      this.log(`Function ${functionName} is healthy`);
      return true;
    } catch (error) {
      this.log(`Error checking function ${functionName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkAllFunctions() {
    this.log("Checking health of all Netlify functions...");
    
    const results = {};
    let allHealthy = true;
    
    for (const functionName of this.config.netlifyFunctions.criticalFunctions) {
      const isHealthy = await this.checkFunctionHealth(functionName);
      results[functionName] = isHealthy;
      
      if (!isHealthy) {
        allHealthy = false;
        this.failureCounts.set(functionName, (this.failureCounts.get(functionName) || 0) + 1);
      } else {
        this.failureCounts.set(functionName, 0);
      }
      
      this.functionStatus.set(functionName, {
        healthy: isHealthy,
        lastCheck: new Date().toISOString(),
        failureCount: this.failureCounts.get(functionName) || 0
      });
    }
    
    if (allHealthy) {
      this.log("All Netlify functions are healthy");
    } else {
      this.log("Some Netlify functions are unhealthy, check logs for details", "WARN");
    }
    
    return results;
  }

  async executeFunction(functionName) {
    this.log(`Executing function: ${functionName}`);
    
    try {
      // Try to execute the function directly if it exists
      const functionFile = path.join(this.config.netlifyFunctions.functionsDir, `${functionName}.js`);
      if (fs.existsSync(functionFile)) {
        const result = await this.runCommand("node", [functionFile]);
        if (result.status === 0) {
          this.log(`Successfully executed function ${functionName}`);
          this.lastRunTimes.set(functionName, new Date().toISOString());
          return true;
        }
      }
      
      // Try backup script
      const backupScript = this.config.functionScripts[functionName];
      if (backupScript && fs.existsSync(backupScript)) {
        const result = await this.runCommand("node", [backupScript]);
        if (result.status === 0) {
          this.log(`Successfully executed backup script for ${functionName}: ${backupScript}`);
          this.lastRunTimes.set(functionName, new Date().toISOString());
          return true;
        }
      }
      
      // Try npm scripts as backup
      for (const script of this.config.backupScripts.trigger) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Successfully executed backup script: ${script}`);
            return true;
          }
        } catch (error) {
          this.log(`Error running backup script ${script}: ${error.message}`, "WARN");
        }
      }
      
      this.log(`Failed to execute function ${functionName} with all methods`, "ERROR");
      return false;
    } catch (error) {
      this.log(`Error executing function ${functionName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async executeAllFunctions() {
    this.log("Executing all Netlify functions...");
    
    const results = {};
    
    for (const functionName of this.config.netlifyFunctions.criticalFunctions) {
      const success = await this.executeFunction(functionName);
      results[functionName] = success;
      
      if (success) {
        this.log(`Successfully executed function: ${functionName}`);
      } else {
        this.log(`Failed to execute function: ${functionName}`, "ERROR");
      }
      
      // Add delay between executions
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
    
    return results;
  }

  async testBackupScripts() {
    this.log("Testing backup scripts...");
    
    const results = {};
    
    for (const category in this.config.backupScripts) {
      results[category] = {};
      
      for (const script of this.config.backupScripts[category]) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          results[category][script] = {
            success: result.status === 0,
            status: result.status,
            output: result.stdout
          };
          
          if (result.status === 0) {
            this.log(`Backup script ${script} is working`);
          } else {
            this.log(`Backup script ${script} failed`, "WARN");
          }
        } catch (error) {
          results[category][script] = {
            success: false,
            error: error.message
          };
          this.log(`Error testing backup script ${script}: ${error.message}`, "ERROR");
        }
      }
    }
    
    return results;
  }

  async regenerateManifest() {
    this.log("Regenerating Netlify functions manifest...");
    
    try {
      // Try npm script first
      let result = await this.runCommand("npm", ["run", "netlify:manifest"]);
      
      if (result.status === 0) {
        this.log("Successfully regenerated manifest via npm script");
        return true;
      }
      
      // Try direct script execution
      const manifestScript = "scripts/generate-netlify-functions-manifest.cjs";
      if (fs.existsSync(manifestScript)) {
        result = await this.runCommand("node", [manifestScript]);
        if (result.status === 0) {
          this.log("Successfully regenerated manifest via direct script");
          return true;
        }
      }
      
      // Try to manually create a basic manifest
      this.log("Attempting to create basic manifest manually", "WARN");
      
      const functionsDir = this.config.netlifyFunctions.functionsDir;
      if (fs.existsSync(functionsDir)) {
        const functions = fs.readdirSync(functionsDir)
          .filter(file => file.endsWith('.js'))
          .map(file => file.replace('.js', ''));
        
        const manifest = {
          generatedAt: new Date().toISOString(),
          functions: functions
        };
        
        const manifestContent = JSON.stringify(manifest, null, 2);
        fs.writeFileSync(this.config.netlifyFunctions.manifestFile, manifestContent);
        
        this.log("Successfully created basic manifest manually");
        return true;
      }
      
      this.log("Failed to regenerate manifest with all methods", "ERROR");
      return false;
    } catch (error) {
      this.log(`Error regenerating manifest: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
      return false;
    }
  }

<<<<<<< HEAD
  // Check function performance (basic metrics)
  async checkFunctionPerformance() {
    try {
      this.log("Checking function performance metrics", "INFO");
      
      const functionFiles = this.listFunctionFiles();
      const performanceResults = {};
      
      for (const filename of functionFiles) {
        const filepath = path.join(this.config.functionsDir, filename);
        const stats = fs.statSync(filepath);
        const content = fs.readFileSync(filepath, 'utf8');
        
        // Basic performance metrics
        const lines = content.split('\n').length;
        const complexity = this.calculateComplexity(content);
        
        performanceResults[filename] = {
          size: stats.size,
          lines: lines,
          complexity: complexity,
          lastModified: stats.mtime
        };
      }
      
      return performanceResults;
      
    } catch (error) {
      this.log(`Function performance check failed: ${error.message}`, "ERROR");
      return {};
    }
  }

  // Calculate basic complexity metric
  calculateComplexity(content) {
    let complexity = 0;
    
    // Count control structures
    const controlStructures = ['if', 'else', 'for', 'while', 'switch', 'case', 'catch', 'finally'];
    for (const structure of controlStructures) {
      const regex = new RegExp(`\\b${structure}\\b`, 'g');
      const matches = content.match(regex);
      if (matches) {
        complexity += matches.length;
      }
    }
    
    // Count function definitions
    const functionMatches = content.match(/function\s+\w+|=>|function\s*\(/g);
    if (functionMatches) {
      complexity += functionMatches.length;
    }
    
    return complexity;
  }

  // Check for missing functions
  async checkMissingFunctions() {
    try {
      this.log("Checking for missing functions", "INFO");
      
      const manifest = this.getFunctionsManifest();
      const existingFunctions = this.listFunctionFiles().map(f => f.replace('.js', '').replace('.mjs', ''));
      
      const missingFunctions = this.config.expectedFunctions.filter(expected => 
        !existingFunctions.includes(expected)
      );
      
      const extraFunctions = existingFunctions.filter(existing => 
        !this.config.expectedFunctions.includes(existing)
      );
      
      return {
        missing: missingFunctions,
        extra: extraFunctions,
        expected: this.config.expectedFunctions.length,
        existing: existingFunctions.length,
        coverage: ((existingFunctions.length / this.config.expectedFunctions.length) * 100).toFixed(2)
      };
      
    } catch (error) {
      this.log(`Missing functions check failed: ${error.message}`, "ERROR");
      return { missing: [], extra: [], coverage: 0 };
    }
  }

  // Perform comprehensive health check
  async performHealthCheck() {
    try {
      this.log("Performing Netlify functions health check", "INFO");
      
      // Check functions directory
      if (!this.checkFunctionsDirectory()) {
        return { valid: false, error: "Functions directory not found" };
      }
      
      // Validate all functions
      const validationResult = await this.validateAllFunctions();
      
      // Check dependencies
      const dependencyResult = await this.checkFunctionDependencies();
      
      // Check performance
      const performanceResult = await this.checkFunctionPerformance();
      
      // Check for missing functions
      const missingResult = await this.checkMissingFunctions();
      
      // Check manifest
      const manifest = this.getFunctionsManifest();
      
      // Determine overall health
      const overallHealth = validationResult.valid && manifest !== null;
      
      const healthResult = {
        timestamp: new Date().toISOString(),
        valid: overallHealth,
        validation: validationResult,
        dependencies: dependencyResult,
        performance: performanceResult,
        missing: missingResult,
        manifest: manifest ? { functions: manifest.functions?.length || 0 } : null,
        errorCounts: Object.fromEntries(this.errorCounts)
      };
      
      this.healthHistory.set("netlify-functions", healthResult);
      
      if (overallHealth) {
        this.log("All Netlify functions healthy", "INFO");
      } else {
        this.log("Some Netlify functions unhealthy", "WARN");
      }
      
      return healthResult;
      
    } catch (error) {
      this.log(`Netlify functions health check failed: ${error.message}`, "ERROR");
      return { valid: false, error: error.message };
    }
  }

  // Start monitoring
  start() {
    if (this.monitoring) {
      this.log("Netlify functions redundancy monitoring already started", "WARN");
      return;
    }
    
    this.monitoring = true;
    this.log("Starting Netlify functions redundancy monitoring", "INFO");
    
    // Start health check monitoring
    this.checkInterval = setInterval(async () => {
      await this.performHealthCheck();
    }, this.config.healthCheckInterval);
    
    // Start manifest regeneration monitoring
    this.manifestInterval = setInterval(async () => {
      await this.regenerateFunctionsManifest();
    }, this.config.manifestRegenerationInterval);
    
    this.log("Netlify functions redundancy monitoring started", "INFO");
  }

  // Stop monitoring
  stop() {
    if (!this.monitoring) {
      this.log("Netlify functions redundancy monitoring not running", "WARN");
      return;
    }
    
    this.monitoring = false;
    
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    
    if (this.manifestInterval) {
      clearInterval(this.manifestInterval);
      this.manifestInterval = null;
    }
    
    this.log("Netlify functions redundancy monitoring stopped", "INFO");
  }

  // Get status
  getStatus() {
    return {
      monitoring: this.monitoring,
      health: this.healthHistory.get("netlify-functions") || null,
      errorCounts: Object.fromEntries(this.errorCounts),
      lastManifestRegeneration: this.lastManifestRegeneration,
      config: this.config
    };
  }

  // Run health check once
  async runOnce() {
    this.log("Running Netlify functions health check once", "INFO");
    return await this.performHealthCheck();
  }

  // Force manifest regeneration
  async forceManifestRegeneration() {
    this.log("Forcing functions manifest regeneration", "INFO");
    return await this.regenerateFunctionsManifest();
=======
  async triggerNetlifyDeploy() {
    this.log("Triggering Netlify deployment...");
    
    try {
      // Try npm scripts first
      for (const script of this.config.backupScripts.trigger) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Successfully triggered deployment via script: ${script}`);
            return true;
          }
        } catch (error) {
          this.log(`Error running trigger script ${script}: ${error.message}`, "WARN");
        }
      }
      
      // Try build commands
      for (const script of this.config.backupScripts.build) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Successfully triggered build via script: ${script}`);
            return true;
          }
        } catch (error) {
          this.log(`Error running build script ${script}: ${error.message}`, "WARN");
        }
      }
      
      this.log("Failed to trigger Netlify deployment with all methods", "ERROR");
      return false;
    } catch (error) {
      this.log(`Error triggering Netlify deployment: ${error.message}`, "ERROR");
      return false;
    }
  }

  async generateHealthReport() {
    const report = {
      timestamp: new Date().toISOString(),
      functions: {},
      backupScripts: {},
      manifest: this.validateManifestFile(),
      summary: {
        totalFunctions: this.config.netlifyFunctions.criticalFunctions.length,
        healthyFunctions: 0,
        unhealthyFunctions: 0,
        lastRunTimes: Object.fromEntries(this.lastRunTimes)
      }
    };
    
    // Function status
    for (const [functionName, status] of this.functionStatus) {
      report.functions[functionName] = status;
      
      if (status.healthy) {
        report.summary.healthyFunctions++;
      } else {
        report.summary.unhealthyFunctions++;
      }
    }
    
    // Test backup scripts
    report.backupScripts = await this.testBackupScripts();
    
    const reportFile = path.join(this.config.logging.logDir, `netlify-functions-health-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    this.log(`Health report generated: ${reportFile}`);
    return report;
  }

  async startMonitoring() {
    this.log("Starting Netlify functions redundancy monitoring...");
    
    // Initial health check
    await this.checkAllFunctions();
    
    // Set up periodic health checks
    setInterval(async () => {
      await this.checkAllFunctions();
    }, this.config.healthCheck.interval);
    
    // Set up periodic function execution
    setInterval(async () => {
      await this.executeAllFunctions();
    }, 600000); // 10 minutes
    
    // Set up periodic manifest regeneration
    setInterval(async () => {
      await this.regenerateManifest();
    }, 1800000); // 30 minutes
    
    // Set up periodic report generation
    setInterval(async () => {
      await this.generateHealthReport();
    }, 600000); // 10 minutes
    
    this.log("Netlify functions redundancy monitoring started");
  }

  async start() {
    this.log("Starting Netlify Functions Redundancy Manager...");
    
    try {
      // Check all functions
      await this.checkAllFunctions();
      
      // Regenerate manifest if needed
      const manifestValidation = this.validateManifestFile();
      if (!manifestValidation.valid) {
        this.log("Manifest is invalid, attempting to regenerate", "WARN");
        await this.regenerateManifest();
      }
      
      // Test backup scripts
      await this.testBackupScripts();
      
      // Start monitoring
      await this.startMonitoring();
      
      this.log("Netlify Functions Redundancy Manager started successfully");
      
      // Keep the process running
      setInterval(() => {
        this.log("Netlify Functions Redundancy Manager heartbeat");
      }, 300000); // 5 minutes
      
    } catch (error) {
      this.log(`Error starting Netlify Functions Redundancy Manager: ${error.message}`, "ERROR");
      process.exit(1);
    }
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
  }
}

// CLI interface
if (require.main === module) {
  const manager = new NetlifyFunctionsRedundancyManager();
<<<<<<< HEAD
  const command = process.argv[2] || "start";
  
  switch (command) {
    case "start":
      manager.start();
      break;
    case "stop":
      manager.stop();
      break;
    case "status":
      console.log(JSON.stringify(manager.getStatus(), null, 2));
      break;
    case "once":
      manager.runOnce().then(result => {
        console.log(JSON.stringify(result, null, 2));
        process.exit(0);
      });
      break;
    case "health":
      manager.performHealthCheck().then(result => {
        console.log(JSON.stringify(result, null, 2));
        process.exit(0);
      });
      break;
    case "manifest":
      manager.forceManifestRegeneration().then(result => {
        console.log(JSON.stringify({ regenerated: result }, null, 2));
        process.exit(0);
      });
      break;
    case "validate":
      manager.validateAllFunctions().then(result => {
        console.log(JSON.stringify(result, null, 2));
        process.exit(0);
      });
      break;
    default:
      console.log("Usage: node netlify-functions-redundancy-manager.cjs [start|stop|status|once|health|manifest|validate]");
      process.exit(1);
=======
  
  const command = process.argv[2] || 'start';
  
  switch (command) {
    case 'start':
      manager.start();
      break;
    case 'monitor':
      manager.startMonitoring();
      break;
    case 'health':
      manager.checkAllFunctions();
      break;
    case 'execute':
      manager.executeAllFunctions();
      break;
    case 'execute-function':
      const functionName = process.argv[3];
      if (functionName) {
        manager.executeFunction(functionName);
      } else {
        console.log("Please specify a function name to execute");
      }
      break;
    case 'regenerate-manifest':
      manager.regenerateManifest();
      break;
    case 'trigger-deploy':
      manager.triggerNetlifyDeploy();
      break;
    case 'test-backups':
      manager.testBackupScripts();
      break;
    case 'report':
      manager.generateHealthReport();
      break;
    default:
      console.log(`
Netlify Functions Redundancy Manager

Usage: node netlify-functions-redundancy-manager.cjs [command]

Commands:
  start               Start the manager and monitoring (default)
  monitor             Start monitoring only
  health              Check health of all functions
  execute             Execute all functions
  execute-function <name> Execute a specific function
  regenerate-manifest Regenerate functions manifest
  trigger-deploy      Trigger Netlify deployment
  test-backups        Test all backup scripts
  report              Generate health report
      `);
      process.exit(0);
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
  }
}

module.exports = NetlifyFunctionsRedundancyManager;