#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
<<<<<<< HEAD
const url = require('url');

const BASE_URL = process.env.APP_MARKETING_URL || process.env.BASE_URL || 'https://ziontechgroup.com';
const REPORT_DIR = path.join(process.cwd(), 'data', 'reports', 'links');
const LOG_DIR = path.join(__dirname, 'logs');
const LOG_FILE = path.join(LOG_DIR, 'site-link-fixer.log');

function ensureDir(p) { if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true }); }
ensureDir(LOG_DIR);
ensureDir(REPORT_DIR);

function log(message) {
  const line = `[${new Date().toISOString()}] ${message}`;
  console.log(line);
  fs.appendFileSync(LOG_FILE, `${line}\n`);
}

function loadLatestCrawl() {
  const latest = path.join(REPORT_DIR, 'crawl-latest.json');
  if (fs.existsSync(latest)) {
    try {
      return JSON.parse(fs.readFileSync(latest, 'utf8'));
    } catch (e) {
      log(`❌ Failed to parse latest crawl: ${e.message}`);
    }
  }
  // fallback to most recent by timestamp
  const files = fs.readdirSync(REPORT_DIR).filter(f => f.startsWith('crawl-') && f.endsWith('.json')).sort().reverse();
  for (const f of files) {
    try {
      return JSON.parse(fs.readFileSync(path.join(REPORT_DIR, f), 'utf8'));
    } catch (e) {}
  }
  return null;
}

function groupBroken(results) {
  const broken = results.filter(r => !r.ok || (r.status && r.status >= 400));
  const byHost = broken.reduce((acc, r) => {
    try {
      const u = new URL(r.url);
      const b = new URL(BASE_URL);
      const key = u.hostname === b.hostname ? 'internal' : 'external';
      acc[key] = acc[key] || [];
      acc[key].push(r);
    } catch (e) {
      acc.misc = acc.misc || [];
      acc.misc.push(r);
    }
    return acc;
  }, {});
  return byHost;
}

function findCandidateFix(url) {
  // Simple redirect-based fix: if the finalUrl is ok and differs from url, propose replacing url with finalUrl
  // Otherwise attempt to strip trailing slashes or add them and check if a corresponding page exists under pages/ as a heuristic
  try {
    const u = new URL(url);
    const withoutSlash = u.pathname.endsWith('/') ? u.pathname.slice(0, -1) : `${u.pathname}/`;
    return [
      `${u.origin}${withoutSlash}`
    ];
  } catch {
    return [];
  }
}

function collectFiles(rootDir) {
  const exts = ['.md', '.mdx', '.tsx', '.jsx', '.ts', '.js'];
  const ignored = new Set(['node_modules', '.git', '.next', 'data/reports']);
  const files = [];
  function walk(dir) {
    for (const entry of fs.readdirSync(dir)) {
      const full = path.join(dir, entry);
      const rel = path.relative(rootDir, full);
      const stat = fs.statSync(full);
      if (stat.isDirectory()) {
        if ([...ignored].some(i => rel.startsWith(i))) continue;
        walk(full);
      } else if (exts.includes(path.extname(entry))) {
        files.push(full);
      }
    }
  }
  walk(rootDir);
  return files;
}

function applyFixes(brokenInternal, allResults) {
  const repoRoot = process.cwd();
  const files = collectFiles(repoRoot);
  const fixes = [];

  // Map for quick lookup of successful final URLs
  const okFinals = new Map();
  for (const r of allResults) {
    if (r.ok && r.finalUrl) okFinals.set(r.url, r.finalUrl);
  }

  for (const issue of brokenInternal) {
    const target = issue.url;
    const replacement = okFinals.get(target) || findCandidateFix(target).find(Boolean);
    if (!replacement || replacement === target) continue;

    for (const file of files) {
      try {
        const original = fs.readFileSync(file, 'utf8');
        if (!original.includes(target)) continue;
        const updated = original.split(target).join(replacement);
        if (updated !== original) {
          fs.writeFileSync(file, updated);
          fixes.push({ file, from: target, to: replacement });
          log(`🛠️ Replaced in ${file}: ${target} -> ${replacement}`);
        }
      } catch (e) {
        log(`⚠️ Could not process ${file}: ${e.message}`);
      }
    }
  }

  return fixes;
}

function saveFixReport(summary) {
  const out = path.join(REPORT_DIR, `fix-${new Date().toISOString().replace(/[-:TZ.]/g, '').slice(0,12)}.json`);
  fs.writeFileSync(out, JSON.stringify(summary, null, 2));
  fs.writeFileSync(path.join(REPORT_DIR, 'fix-latest.json'), JSON.stringify(summary, null, 2));
  log(`📄 Saved fix report: ${out}`);
}

async function main() {
  const crawl = loadLatestCrawl();
  if (!crawl) {
    log('ℹ️ No crawl report found; skipping fixes');
    return;
  }
  const grouped = groupBroken(crawl.results || []);
  const internalBroken = grouped.internal || [];
  log(`🔎 Internal broken links: ${internalBroken.length}`);

  const fixes = applyFixes(internalBroken, crawl.results || []);
  const report = {
    timestamp: new Date().toISOString(),
    baseUrl: BASE_URL,
    attempted: internalBroken.length,
    applied: fixes.length,
    fixes
  };
  saveFixReport(report);
}

if (require.main === module) {
  main().catch(e => { log(`❌ Fix run failed: ${e.message}`); process.exitCode = 1; });
}

module.exports = {};


=======

const REPORT_DIR = path.join(process.cwd(), 'data', 'reports', 'site-links');
const HUMAN_REPORT_DIR = path.join(process.cwd(), 'public', 'reports', 'links');
const NEXT_CONFIG_FILE = path.join(process.cwd(), 'next.config.js');

function ensureDir(dir) { fs.mkdirSync(dir, { recursive: true }); }

function loadLatestReport() {
  const latestPath = path.join(REPORT_DIR, 'latest.json');
  if (!fs.existsSync(latestPath)) return null;
  try { return JSON.parse(fs.readFileSync(latestPath, 'utf8')); } catch { return null; }
}

function generateRedirects(missingPaths) {
  // Conservative: redirect missing internal paths to the homepage
  // Avoid duplicates and avoid existing '/'
  const unique = Array.from(new Set(missingPaths.map((m) => m.path))).filter((p) => p && p !== '/');
  return unique.map((p) => ({ source: p, destination: '/', permanent: true }));
}

function mergeRedirectsIntoNextConfig(redirectsToAdd) {
  let source = fs.readFileSync(NEXT_CONFIG_FILE, 'utf8');

  // Try to locate existing redirects() array and merge into it.
  const redirectsFuncRegex = /async\s+redirects\s*\(\)\s*{[\s\S]*?return\s*\[([\s\S]*?)\];[\s\S]*?}/m;
  const match = source.match(redirectsFuncRegex);

  if (match) {
    const existingArrayBody = match[1].trim();
    // Parse existing entries by a simple heuristic; we will append new JSON
    const existingEntriesText = existingArrayBody.length ? existingArrayBody + ',\n' : '';
    const appended = existingEntriesText + redirectsToAdd.map((r) => `      { source: '${r.source}', destination: '${r.destination}', permanent: ${r.permanent} }`).join(',\n');
    const newFunc = match[0].replace(existingArrayBody, appended);
    source = source.replace(redirectsFuncRegex, newFunc);
  } else {
    // No redirects() defined; add one to nextConfig
    const nextConfigRegex = /const\s+nextConfig\s*=\s*{([\s\S]*?)};\s*\n/m;
    const m2 = source.match(nextConfigRegex);
    const redirectsText = `  async redirects() {\n    return [\n${redirectsToAdd.map((r) => `      { source: '${r.source}', destination: '${r.destination}', permanent: ${r.permanent} }`).join(',\n')}\n    ];\n  },\n`;
    if (m2) {
      const body = m2[1];
      const bodyWithRedirects = (body.trim().length ? body.replace(/\n$/, '') + '\n' : '') + redirectsText;
      const replaced = m2[0].replace(m2[1], bodyWithRedirects);
      source = source.replace(nextConfigRegex, replaced);
    } else {
      // Fallback: recreate minimal next.config.js
      source = `/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  async redirects() {\n    return [\n${redirectsToAdd.map((r) => `      { source: '${r.source}', destination: '${r.destination}', permanent: ${r.permanent} }`).join(',\n')}\n    ];\n  },\n};\n\nmodule.exports = nextConfig;\n`;
    }
  }

  fs.writeFileSync(NEXT_CONFIG_FILE, source);
}

function writeHumanReport(report, addedRedirects) {
  ensureDir(HUMAN_REPORT_DIR);
  const html = `<!doctype html><html><head><meta charset="utf-8"/><title>Link Integrity Report</title><style>body{font-family:system-ui;margin:24px;}table{border-collapse:collapse;width:100%;}th,td{border:1px solid #ddd;padding:6px;font-size:14px;}th{background:#f7f7f7;text-align:left}</style></head><body><h1>Link Integrity Report</h1><p>Generated: ${new Date().toLocaleString()}</p><h2>Stats</h2><ul><li>Pages crawled: ${report?.stats?.pagesCrawled || 0}</li><li>Discovered internal: ${report?.stats?.discoveredInternal || 0}</li><li>Missing internal: ${report?.stats?.missing || 0}</li><li>Redirects added: ${addedRedirects.length}</li></ul><h2>Missing Internal Paths</h2><table><thead><tr><th>Path</th><th>Status</th></tr></thead><tbody>${(report?.missingInternalPaths || []).map(m => `<tr><td>${m.path}</td><td>${m.status}</td></tr>`).join('')}</tbody></table><h2>New Redirects</h2><table><thead><tr><th>Source</th><th>Destination</th><th>Permanent</th></tr></thead><tbody>${addedRedirects.map(r => `<tr><td>${r.source}</td><td>${r.destination}</td><td>${r.permanent}</td></tr>`).join('')}</tbody></table></body></html>`;
  fs.writeFileSync(path.join(HUMAN_REPORT_DIR, 'index.html'), html);
}

function main() {
  const report = loadLatestReport();
  if (!report) {
    console.log('No crawl report found. Run site-link-crawler first.');
    process.exit(0);
  }
  const redirects = generateRedirects(report.missingInternalPaths || []);
  if (!redirects.length) {
    console.log('No missing internal paths detected.');
    writeHumanReport(report, []);
    return;
  }
  mergeRedirectsIntoNextConfig(redirects);
  writeHumanReport(report, redirects);
  console.log(`Added ${redirects.length} redirects to next.config.js`);
}

main();
>>>>>>> origin/cursor/crawl-and-fix-site-links-and-pages-1131
