#!/usr/bin/env node
"use strict";

const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");

class NetlifyFunctionsUltimateRedundancy {
  constructor() {
    this.config = {
<<<<<<< HEAD
      functionsDir: "netlify/functions",
      backupDir: "netlify/functions/backups",
      manifestFile: "netlify/functions/functions-manifest.json",
      healthCheckInterval: 120000, // 2 minutes
      backupInterval: 600000, // 10 minutes
      maxBackups: 10,
      autoRepair: true,
      autoRegenerate: true,
      logLevel: "INFO"
    };
    
    this.ensureDirectories();
    this.initializeMonitoring();
  }

  ensureDirectories() {
    if (!fs.existsSync(this.config.functionsDir)) {
      fs.mkdirSync(this.config.functionsDir, { recursive: true });
    }
    if (!fs.existsSync(this.config.backupDir)) {
      fs.mkdirSync(this.config.backupDir, { recursive: true });
=======
      manifestFile: "netlify/functions/functions-manifest.json",
      functionsDir: "netlify/functions",
      healthCheckInterval: 30000,
      maxFailureThreshold: 5,
      autoRegenerate: true,
      deploymentCheck: true,
      logRotation: true,
      functionMonitoring: true,
      autoHealing: true,
      performanceOptimization: true,
      backupStrategy: true,
      conflictResolution: true
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
    this.startUltimateNetlifyFunctionsMonitoring();
  }

  ensureLogDirectory() {
    const logDir = "automation/logs";
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
<<<<<<< HEAD
    const logDir = "automation/logs";
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    const logFile = path.join(logDir, `netlify-functions-redundancy-${new Date().toISOString().split('T')[0]}.log`);
=======
    const logFile = path.join("automation/logs", `netlify-functions-ultimate-redundancy-${new Date().toISOString().split('T')[0]}.log`);
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
    fs.appendFileSync(logFile, logEntry + "\n");
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
<<<<<<< HEAD
        maxBuffer: 1024 * 1024 * 10,
=======
        maxBuffer: 1024 * 1024 * 50,
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  async validateFunctionFile(functionPath) {
    try {
      if (!fs.existsSync(functionPath)) {
        return { valid: false, error: "File does not exist" };
      }

      const content = fs.readFileSync(functionPath, 'utf8');
      
      // Basic validation for different file types
      const ext = path.extname(functionPath);
      
      if (ext === '.js' || ext === '.cjs') {
        // Validate JavaScript/CommonJS
        if (!content.includes('exports.handler') && !content.includes('module.exports')) {
          return { valid: false, error: "Missing handler export" };
        }
      } else if (ext === '.mjs') {
        // Validate ES modules
        if (!content.includes('export const handler')) {
          return { valid: false, error: "Missing handler export" };
        }
      } else if (ext === '.ts') {
        // Validate TypeScript
        if (!content.includes('export const handler') && !content.includes('exports.handler')) {
          return { valid: false, error: "Missing handler export" };
        }
      }

      // Check for basic syntax
      if (content.includes('function(') && !content.includes(')')) {
        return { valid: false, error: "Unclosed function parentheses" };
      }

      if (content.includes('{') && !content.includes('}')) {
        return { valid: false, error: "Unclosed braces" };
      }

      return { valid: true, content };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  async validateManifest() {
    try {
      if (!fs.existsSync(this.config.manifestFile)) {
        return { valid: false, error: "Manifest file does not exist" };
      }

      const manifestContent = fs.readFileSync(this.config.manifestFile, 'utf8');
      const manifest = JSON.parse(manifestContent);
      
      if (!manifest.functions || !Array.isArray(manifest.functions)) {
        return { valid: false, error: "Invalid manifest structure" };
      }

      if (manifest.functions.length === 0) {
        return { valid: false, error: "No functions listed in manifest" };
      }

      // Validate each function in manifest
      const validationResults = {};
      let allValid = true;

      for (const functionName of manifest.functions) {
        const functionPath = path.join(this.config.functionsDir, `${functionName}.js`);
        const validation = await this.validateFunctionFile(functionPath);
        validationResults[functionName] = validation;
        
        if (!validation.valid) {
          allValid = false;
        }
      }

      return { 
        valid: allValid, 
        manifest, 
        validationResults,
        totalFunctions: manifest.functions.length
      };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  async createFunctionBackup(functionPath) {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.basename(functionPath);
      const backupPath = path.join(this.config.backupDir, `${filename}.backup.${timestamp}`);
      
      fs.copyFileSync(functionPath, backupPath);
      this.log(`✅ Created backup: ${backupPath}`);
      
      // Clean up old backups
      await this.cleanupOldBackups(filename);
      
      return backupPath;
    } catch (error) {
      this.log(`❌ Failed to create backup: ${error.message}`, "ERROR");
      return null;
    }
  }

  async cleanupOldBackups(functionName) {
    try {
      const files = fs.readdirSync(this.config.backupDir);
      const backups = files
        .filter(file => file.startsWith(functionName) && file.includes('.backup.'))
        .map(file => ({
          name: file,
          path: path.join(this.config.backupDir, file),
          time: fs.statSync(path.join(this.config.backupDir, file)).mtime.getTime()
        }))
        .sort((a, b) => b.time - a.time);

      if (backups.length > this.config.maxBackups) {
        const toDelete = backups.slice(this.config.maxBackups);
        for (const backup of toDelete) {
          fs.unlinkSync(backup.path);
          this.log(`🗑️ Removed old backup: ${backup.name}`);
        }
      }
    } catch (error) {
      this.log(`❌ Failed to cleanup backups: ${error.message}`, "ERROR");
    }
  }

  async restoreFunctionFromBackup(functionPath) {
    try {
      const filename = path.basename(functionPath);
      const files = fs.readdirSync(this.config.backupDir);
      const backups = files
        .filter(file => file.startsWith(filename) && file.includes('.backup.'))
        .map(file => ({
          name: file,
          path: path.join(this.config.backupDir, file),
          time: fs.statSync(path.join(this.config.backupDir, file)).mtime.getTime()
        }))
        .sort((a, b) => b.time - a.time);

      if (backups.length > 0) {
        const latestBackup = backups[0];
        fs.copyFileSync(latestBackup.path, functionPath);
        this.log(`✅ Restored function from backup: ${latestBackup.name}`);
        return true;
      } else {
        this.log(`⚠️ No backup found for: ${filename}`, "WARN");
        return false;
      }
    } catch (error) {
      this.log(`❌ Failed to restore function: ${error.message}`, "ERROR");
=======
  async checkNetlifyDirectory() {
    try {
      if (!fs.existsSync(this.config.functionsDir)) {
        this.log("❌ Netlify functions directory not found", "ERROR");
        return false;
      }
      
      const stats = fs.statSync(this.config.functionsDir);
      if (!stats.isDirectory()) {
        this.log("❌ Netlify functions path is not a directory", "ERROR");
        return false;
      }
      
      this.log("✅ Netlify functions directory accessible");
      return true;
    } catch (error) {
      this.log(`❌ Netlify directory check failed: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
      return false;
    }
  }

<<<<<<< HEAD
  async repairFunction(functionPath) {
    try {
      this.log(`🔧 Attempting to repair function: ${functionPath}`);
      
      // Try to restore from backup first
      if (await this.restoreFunctionFromBackup(functionPath)) {
        return true;
      }

      // If no backup, try to recreate basic function
      const filename = path.basename(functionPath, path.extname(functionPath));
      const ext = path.extname(functionPath);
      const basicFunction = this.generateBasicFunction(filename, ext);
      
      fs.writeFileSync(functionPath, basicFunction);
      this.log(`✅ Recreated basic function: ${functionPath}`);
      
      return true;
    } catch (error) {
      this.log(`❌ Failed to repair function: ${error.message}`, "ERROR");
=======
  async checkFunctionsManifest() {
    try {
      if (!fs.existsSync(this.config.manifestFile)) {
        this.log("⚠️ Functions manifest not found, will regenerate", "WARN");
        return { exists: false, valid: false, functions: [] };
      }
      
      const content = fs.readFileSync(this.config.manifestFile, 'utf8');
      const manifest = JSON.parse(content);
      
      // Validate manifest structure
      const isValid = this.validateManifestStructure(manifest);
      
      if (isValid) {
        this.log(`✅ Functions manifest valid: ${manifest.functions?.length || 0} functions`);
        return {
          exists: true,
          valid: true,
          functions: manifest.functions || [],
          generatedAt: manifest.generatedAt,
          manifest
        };
      } else {
        this.log("⚠️ Functions manifest has invalid structure", "WARN");
        return {
          exists: true,
          valid: false,
          functions: [],
          manifest
        };
      }
    } catch (error) {
      this.log(`❌ Functions manifest check failed: ${error.message}`, "ERROR");
      return { exists: false, valid: false, functions: [], error: error.message };
    }
  }

  validateManifestStructure(manifest) {
    try {
      // Check required fields
      if (!manifest.functions || !Array.isArray(manifest.functions)) {
        return false;
      }
      
      // Check generatedAt timestamp
      if (!manifest.generatedAt || isNaN(new Date(manifest.generatedAt).getTime())) {
        return false;
      }
      
      // Check function names are strings
      if (!manifest.functions.every(f => typeof f === 'string')) {
        return false;
      }
      
      return true;
    } catch (error) {
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
      return false;
    }
  }

<<<<<<< HEAD
  generateBasicFunction(functionName, extension) {
    const templates = {
      '.js': `// Basic Netlify Function: ${functionName}
exports.handler = async (event, context) => {
  try {
    return {
      statusCode: 200,
      body: JSON.stringify({
        message: "Function ${functionName} is running",
        timestamp: new Date().toISOString(),
        event: event
      })
    };
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({
        error: error.message
      })
    };
  }
};`,

      '.cjs': `// Basic Netlify Function: ${functionName}
module.exports = {
  handler: async (event, context) => {
    try {
      return {
        statusCode: 200,
        body: JSON.stringify({
          message: "Function ${functionName} is running",
          timestamp: new Date().toISOString(),
          event: event
        })
      };
    } catch (error) {
      return {
        statusCode: 500,
        body: JSON.stringify({
          error: error.message
        })
      };
    }
  }
};`,

      '.mjs': `// Basic Netlify Function: ${functionName}
export const handler = async (event, context) => {
  try {
    return {
      statusCode: 200,
      body: JSON.stringify({
        message: "Function ${functionName} is running",
        timestamp: new Date().toISOString(),
        event: event
      })
    };
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({
        error: error.message
      })
    };
  }
};`,

      '.ts': `// Basic Netlify Function: ${functionName}
import { Handler } from '@netlify/functions';

export const handler: Handler = async (event, context) => {
  try {
    return {
      statusCode: 200,
      body: JSON.stringify({
        message: "Function ${functionName} is running",
        timestamp: new Date().toISOString(),
        event: event
      })
    };
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    };
  }
};`
    };

    return templates[extension] || templates['.js'];
  }

  async regenerateManifest() {
=======
  async scanFunctionFiles() {
    try {
      if (!fs.existsSync(this.config.functionsDir)) {
        return { functions: [], totalFiles: 0, validFiles: 0 };
      }
      
      const files = fs.readdirSync(this.config.functionsDir);
      const functionFiles = [];
      let validFiles = 0;
      
      for (const file of files) {
        if (file.endsWith('.js') || file.endsWith('.cjs') || file.endsWith('.ts')) {
          const filePath = path.join(this.config.functionsDir, file);
          const stats = fs.statSync(filePath);
          
          if (stats.isFile()) {
            const functionName = path.basename(file, path.extname(file));
            const content = fs.readFileSync(filePath, 'utf8');
            
            // Basic validation
            const isValid = this.validateFunctionFile(content, functionName);
            
            functionFiles.push({
              name: functionName,
              file: file,
              path: filePath,
              size: stats.size,
              lastModified: stats.mtime,
              valid: isValid
            });
            
            if (isValid) validFiles++;
          }
        }
      }
      
      this.log(`📁 Found ${functionFiles.length} function files (${validFiles} valid)`);
      return { functions: functionFiles, totalFiles: files.length, validFiles };
    } catch (error) {
      this.log(`❌ Function file scan failed: ${error.message}`, "ERROR");
      return { functions: [], totalFiles: 0, validFiles: 0, error: error.message };
    }
  }

  validateFunctionFile(content, functionName) {
    try {
      // Basic validation checks
      if (!content || content.trim().length === 0) {
        return false;
      }
      
      // Check for common function patterns
      const hasExport = content.includes('exports.') || 
                       content.includes('module.exports') ||
                       content.includes('export default') ||
                       content.includes('export function') ||
                       content.includes('export const');
      
      if (!hasExport) {
        return false;
      }
      
      // Check for basic syntax (no obvious syntax errors)
      const lines = content.split('\n');
      let bracketCount = 0;
      let braceCount = 0;
      let parenCount = 0;
      
      for (const line of lines) {
        for (const char of line) {
          if (char === '[') bracketCount++;
          if (char === ']') bracketCount--;
          if (char === '{') braceCount++;
          if (char === '}') braceCount--;
          if (char === '(') parenCount++;
          if (char === ')') parenCount--;
        }
      }
      
      // Basic bracket balance check
      if (bracketCount !== 0 || braceCount !== 0 || parenCount !== 0) {
        return false;
      }
      
      return true;
    } catch (error) {
      return false;
    }
  }

  async regenerateFunctionsManifest() {
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
    try {
      this.log("🔄 Regenerating Netlify functions manifest...");
      
      if (fs.existsSync("scripts/generate-netlify-functions-manifest.cjs")) {
        const result = await this.runCommand("node", ["scripts/generate-netlify-functions-manifest.cjs"]);
        if (result.status === 0) {
<<<<<<< HEAD
          this.log("✅ Manifest regenerated successfully");
=======
          this.log("✅ Functions manifest regenerated successfully");
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
          return true;
        } else {
          this.log(`❌ Failed to regenerate manifest: ${result.stderr}`, "ERROR");
          return false;
        }
      } else {
<<<<<<< HEAD
        // Create basic manifest if script doesn't exist
        const functions = this.scanFunctionsDirectory();
        const manifest = {
          generatedAt: new Date().toISOString(),
          functions: functions,
          totalFunctions: functions.length
        };
        
        fs.writeFileSync(this.config.manifestFile, JSON.stringify(manifest, null, 2));
        this.log("✅ Created basic manifest");
        return true;
      }
    } catch (error) {
      this.log(`❌ Failed to regenerate manifest: ${error.message}`, "ERROR");
=======
        // Manual manifest generation
        return await this.generateManualManifest();
      }
    } catch (error) {
      this.log(`❌ Manifest regeneration failed: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
      return false;
    }
  }

<<<<<<< HEAD
  scanFunctionsDirectory() {
    try {
      if (!fs.existsSync(this.config.functionsDir)) {
        return [];
      }

      const files = fs.readdirSync(this.config.functionsDir);
      const functions = files
        .filter(file => {
          const ext = path.extname(file);
          return ['.js', '.cjs', '.mjs', '.ts'].includes(ext);
        })
        .map(file => path.basename(file, path.extname(file)));

      return functions;
    } catch (error) {
      this.log(`❌ Failed to scan functions directory: ${error.message}`, "ERROR");
      return [];
    }
  }

  async checkAllFunctions() {
    this.log("🔍 Checking all Netlify Functions...");
    
    // First validate manifest
    const manifestValidation = await this.validateManifest();
    
    if (!manifestValidation.valid) {
      this.log(`❌ Manifest validation failed: ${manifestValidation.error}`, "ERROR");
      
      if (this.config.autoRepair) {
        this.log("🔧 Attempting to repair manifest...");
        await this.regenerateManifest();
      }
      
      return { allHealthy: false, manifest: manifestValidation };
    }

    // Validate individual functions
    const functionValidations = {};
    let allFunctionsHealthy = true;

    for (const functionName of manifestValidation.manifest.functions) {
      const functionPath = path.join(this.config.functionsDir, `${functionName}.js`);
      const validation = await this.validateFunctionFile(functionPath);
      
      functionValidations[functionName] = validation;
      
      if (!validation.valid) {
        allFunctionsHealthy = false;
        this.log(`❌ Function ${functionName} is invalid: ${validation.error}`, "ERROR");
        
        if (this.config.autoRepair) {
          this.log(`🔧 Attempting to repair function ${functionName}...`);
          await this.repairFunction(functionPath);
        }
      } else {
        this.log(`✅ Function ${functionName} is valid`);
      }
    }

    const overallHealth = manifestValidation.valid && allFunctionsHealthy;
    
    return {
      allHealthy: overallHealth,
      manifest: manifestValidation,
      functions: functionValidations
    };
  }

  async createAllBackups() {
    this.log("💾 Creating backups for all functions...");
    
    const backupResults = {};
    
    // Get all function files
    const functions = this.scanFunctionsDirectory();
    
    for (const functionName of functions) {
      const functionPath = path.join(this.config.functionsDir, `${functionName}.js`);
      if (fs.existsSync(functionPath)) {
        const backupPath = await this.createFunctionBackup(functionPath);
        backupResults[functionName] = backupPath;
      } else {
        this.log(`⚠️ Function file not found: ${functionName}`, "WARN");
        backupResults[functionName] = null;
      }
    }

    // Also backup manifest
    if (fs.existsSync(this.config.manifestFile)) {
      const manifestBackup = await this.createFunctionBackup(this.config.manifestFile);
      backupResults['manifest'] = manifestBackup;
    }

    return backupResults;
  }

  async generateHealthReport() {
    try {
      const functionCheck = await this.checkAllFunctions();
      const backupResults = await this.createAllBackups();
      
      const report = {
        timestamp: new Date().toISOString(),
        functions: {
          status: functionCheck.allHealthy,
          manifest: functionCheck.manifest,
          individual: functionCheck.functions
        },
        backups: backupResults,
        system: {
          functionsDir: this.config.functionsDir,
          backupDir: this.config.backupDir,
          manifestFile: this.config.manifestFile,
          autoRepair: this.config.autoRepair,
          autoRegenerate: this.config.autoRegenerate
        }
      };

      const logDir = "automation/logs";
      if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
      }
      
      const reportFile = path.join(logDir, `netlify-functions-health-report-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
      
      this.log("📊 Netlify Functions health report generated");
      return report;
    } catch (error) {
      this.log(`❌ Failed to generate health report: ${error.message}`, "ERROR");
      return null;
    }
  }

  async initializeMonitoring() {
    this.log("🚀 Starting Netlify Functions Ultimate Redundancy System...");
    
    // Initial health check
    await this.checkAllFunctions();
    
    // Create initial backups
    await this.createAllBackups();
    
    // Set up monitoring intervals
    setInterval(async () => {
      try {
        await this.checkAllFunctions();
      } catch (error) {
        this.log(`❌ Function health check failed: ${error.message}`, "ERROR");
      }
    }, this.config.healthCheckInterval);

    setInterval(async () => {
      try {
        await this.createAllBackups();
      } catch (error) {
        this.log(`❌ Backup creation failed: ${error.message}`, "ERROR");
      }
    }, this.config.backupInterval);

    this.log("✅ Netlify Functions Ultimate Redundancy System started successfully");
  }

  async stop() {
    this.log("🛑 Stopping Netlify Functions Ultimate Redundancy System...");
    process.exit(0);
  }
}

// Handle process signals
process.on('SIGINT', () => {
  console.log('\n🛑 Received SIGINT, shutting down gracefully...');
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\n🛑 Received SIGTERM, shutting down gracefully...');
  process.exit(0);
});

// Start the system if this file is run directly
if (require.main === module) {
  const system = new NetlifyFunctionsUltimateRedundancy();
  
  // Keep the process alive
  setInterval(() => {
    // Heartbeat
  }, 60000);
=======
  async generateManualManifest() {
    try {
      this.log("🔧 Generating manual functions manifest...");
      
      const { functions } = await this.scanFunctionFiles();
      const validFunctions = functions.filter(f => f.valid).map(f => f.name);
      
      const manifest = {
        generatedAt: new Date().toISOString(),
        functions: validFunctions,
        totalFunctions: validFunctions.length,
        generatedBy: "netlify-functions-ultimate-redundancy"
      };
      
      // Ensure directory exists
      const manifestDir = path.dirname(this.config.manifestFile);
      if (!fs.existsSync(manifestDir)) {
        fs.mkdirSync(manifestDir, { recursive: true });
      }
      
      fs.writeFileSync(this.config.manifestFile, JSON.stringify(manifest, null, 2));
      this.log(`✅ Manual manifest generated: ${validFunctions.length} functions`);
      return true;
    } catch (error) {
      this.log(`❌ Manual manifest generation failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkFunctionDeployment() {
    try {
      this.log("🔍 Checking Netlify function deployment status...");
      
      // Check if netlify.toml exists
      const netlifyConfig = "netlify.toml";
      if (fs.existsSync(netlifyConfig)) {
        this.log("✅ Netlify configuration file found");
      } else {
        this.log("⚠️ Netlify configuration file not found", "WARN");
      }
      
      // Check for .netlify directory
      const netlifyDir = ".netlify";
      if (fs.existsSync(netlifyDir)) {
        this.log("✅ Netlify deployment directory found");
      } else {
        this.log("⚠️ Netlify deployment directory not found", "WARN");
      }
      
      // Check for build artifacts
      const buildDirs = ['.next', 'out', 'dist'];
      let buildArtifacts = false;
      
      for (const dir of buildDirs) {
        if (fs.existsSync(dir)) {
          const stats = fs.statSync(dir);
          if (stats.isDirectory() && fs.readdirSync(dir).length > 0) {
            buildArtifacts = true;
            this.log(`✅ Build artifacts found in ${dir}`);
            break;
          }
        }
      }
      
      if (!buildArtifacts) {
        this.log("⚠️ No build artifacts found", "WARN");
      }
      
      return { configured: true, deployed: true, buildArtifacts };
    } catch (error) {
      this.log(`❌ Deployment check failed: ${error.message}`, "ERROR");
      return { configured: false, deployed: false, buildArtifacts: false, error: error.message };
    }
  }

  async performFunctionHealthCheck() {
    try {
      this.log("🔍 Performing comprehensive Netlify Functions health check...");
      
      const results = {
        timestamp: new Date().toISOString(),
        netlifyDirectory: false,
        manifest: {},
        functionFiles: {},
        deployment: {},
        overall: false
      };
      
      // Check Netlify directory
      results.netlifyDirectory = await this.checkNetlifyDirectory();
      
      // Check functions manifest
      results.manifest = await this.checkFunctionsManifest();
      
      // Scan function files
      results.functionFiles = await this.scanFunctionFiles();
      
      // Check deployment status
      results.deployment = await this.checkFunctionDeployment();
      
      // Determine overall health
      results.overall = results.netlifyDirectory && 
                       results.manifest.valid && 
                       results.functionFiles.validFiles > 0 &&
                       results.deployment.configured;
      
      this.log(`📊 Netlify Functions Health: ${results.overall ? 'Healthy' : 'Issues detected'}`);
      
      // Perform auto-healing if enabled
      if (this.config.autoHealing && !results.overall) {
        this.log("🔄 Performing auto-healing...");
        
        if (!results.manifest.valid) {
          await this.regenerateFunctionsManifest();
        }
        
        if (results.functionFiles.validFiles === 0) {
          this.log("⚠️ No valid function files found, attempting to fix...", "WARN");
          // Could implement function file repair here
        }
      }
      
      return results;
    } catch (error) {
      this.log(`❌ Function health check failed: ${error.message}`, "ERROR");
      return {
        timestamp: new Date().toISOString(),
        netlifyDirectory: false,
        manifest: {},
        functionFiles: {},
        deployment: {},
        overall: false,
        error: error.message
      };
    }
  }

  async createFunctionBackups() {
    try {
      this.log("💾 Creating function file backups...");
      
      if (!fs.existsSync(this.config.functionsDir)) {
        this.log("❌ Functions directory not found", "ERROR");
        return 0;
      }
      
      const backupDir = path.join(this.config.functionsDir, "backups");
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }
      
      const { functions } = await this.scanFunctionFiles();
      let backupCount = 0;
      
      for (const func of functions) {
        if (func.valid) {
          const backupPath = path.join(backupDir, `${func.file}.backup`);
          try {
            fs.copyFileSync(func.path, backupPath);
            backupCount++;
          } catch (error) {
            this.log(`⚠️ Failed to backup ${func.file}: ${error.message}`, "WARN");
          }
        }
      }
      
      this.log(`✅ Function backups created: ${backupCount} files backed up`);
      return backupCount;
    } catch (error) {
      this.log(`❌ Function backup creation failed: ${error.message}`, "ERROR");
      return 0;
    }
  }

  async optimizeFunctionPerformance() {
    if (!this.config.performanceOptimization) return;
    
    try {
      this.log("⚡ Performing function performance optimization...");
      
      const { functions } = await this.scanFunctionFiles();
      let optimizedCount = 0;
      
      for (const func of functions) {
        if (func.valid && func.size > 1024) { // Only optimize files larger than 1KB
          try {
            const content = fs.readFileSync(func.path, 'utf8');
            
            // Basic optimizations
            let optimizedContent = content;
            
            // Remove console.log statements in production
            if (process.env.NODE_ENV === 'production') {
              optimizedContent = optimizedContent.replace(/console\.log\([^)]*\);?\s*/g, '');
            }
            
            // Remove empty lines
            optimizedContent = optimizedContent.replace(/\n\s*\n/g, '\n');
            
            // Remove trailing whitespace
            optimizedContent = optimizedContent.replace(/[ \t]+$/gm, '');
            
            if (optimizedContent !== content) {
              fs.writeFileSync(func.path, optimizedContent);
              optimizedCount++;
            }
          } catch (error) {
            this.log(`⚠️ Failed to optimize ${func.file}: ${error.message}`, "WARN");
          }
        }
      }
      
      if (optimizedCount > 0) {
        this.log(`✅ Function optimization completed: ${optimizedCount} functions optimized`);
      } else {
        this.log("✅ No functions needed optimization");
      }
    } catch (error) {
      this.log(`⚠️ Function optimization failed: ${error.message}`, "WARN");
    }
  }

  async generateHealthReport(results) {
    try {
      const reportFile = path.join("automation/logs", `netlify-functions-health-report-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(reportFile, JSON.stringify(results, null, 2));
      this.log(`📄 Health report saved to: ${reportFile}`);
    } catch (error) {
      this.log(`❌ Failed to save health report: ${error.message}`, "ERROR");
    }
  }

  initializeMonitoring() {
    this.log("🔧 Initializing Netlify Functions ultimate monitoring system...");
    
    // Set up log rotation
    if (this.config.logRotation) {
      this.setupLogRotation();
    }
  }

  setupLogRotation() {
    setInterval(() => {
      this.rotateLogs();
    }, 24 * 60 * 60 * 1000); // Daily
  }

  rotateLogs() {
    try {
      const logFiles = fs.readdirSync("automation/logs")
        .filter(f => f.startsWith('netlify-functions-ultimate-redundancy-') && f.endsWith('.log'))
        .sort()
        .reverse();

      // Keep only the latest 30 log files
      if (logFiles.length > 30) {
        const filesToDelete = logFiles.slice(30);
        filesToDelete.forEach(file => {
          fs.unlinkSync(path.join("automation/logs", file));
        });
        this.log(`🗑️ Rotated ${filesToDelete.length} old log files`);
      }
    } catch (error) {
      this.log(`❌ Log rotation failed: ${error.message}`, "ERROR");
    }
  }

  startUltimateNetlifyFunctionsMonitoring() {
    this.log("🚀 Starting ultimate Netlify Functions monitoring system...");
    
    // Initial health check
    this.performFunctionHealthCheck();
    
    // Continuous monitoring
    setInterval(async () => {
      const results = await this.performFunctionHealthCheck();
      
      // Save health report
      this.generateHealthReport(results);
      
      // Perform optimizations if system is healthy
      if (results.overall) {
        await this.optimizeFunctionPerformance();
      }
      
      // Create backups periodically
      if (this.config.backupStrategy && Math.random() < 0.1) { // 10% chance each check
        await this.createFunctionBackups();
      }
      
      // Log summary
      if (!results.overall) {
        this.log("⚠️ Netlify Functions system has issues, check logs for details", "WARN");
      }
    }, this.config.healthCheckInterval);
    
    this.log("✅ Ultimate Netlify Functions monitoring system started");
  }

  async getStatus() {
    return {
      status: "running",
      uptime: process.uptime(),
      config: this.config,
      lastCheck: new Date().toISOString()
    };
  }
}

// CLI interface
if (require.main === module) {
  const args = process.argv.slice(2);
  const system = new NetlifyFunctionsUltimateRedundancy();
  
  switch (args[0]) {
    case 'start':
      console.log("🚀 Netlify Functions ultimate redundancy system started");
      break;
    case 'status':
      console.log(JSON.stringify(system.getStatus(), null, 2));
      break;
    case 'health':
      system.performFunctionHealthCheck();
      break;
    case 'regenerate':
      system.regenerateFunctionsManifest();
      break;
    case 'backup':
      system.createFunctionBackups();
      break;
    case 'optimize':
      system.optimizeFunctionPerformance();
      break;
    default:
      console.log("Usage: node netlify-functions-ultimate-redundancy.cjs [start|status|health|regenerate|backup|optimize]");
  }
>>>>>>> origin/cursor/automate-all-existing-automations-and-clean-up-494d
}

module.exports = NetlifyFunctionsUltimateRedundancy;