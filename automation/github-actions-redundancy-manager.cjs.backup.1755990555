#!/usr/bin/env node
"use strict";

<<<<<<< HEAD
const { spawnSync } = require("child_process");
=======
const { spawnSync, execSync } = require("child_process");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
const fs = require("fs");
const path = require("path");
const yaml = require("js-yaml");

class GitHubActionsRedundancyManager {
  constructor() {
<<<<<<< HEAD
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "github-actions-redundancy.log");
    this.ensureLogDir();
    
    this.config = {
      // GitHub Actions workflows directory
      workflowsDir: path.join(this.workspace, ".github/workflows"),
      
      // Primary workflows and their backup counterparts
      workflowPairs: {
        "marketing-sync.yml": "marketing-sync-backup.yml",
        "sync-health.yml": "sync-health-backup.yml"
      },
      
      // Workflow validation rules
      validationRules: {
        requiredSections: ["on", "jobs"],
        requiredPermissions: ["contents"],
        requiredSteps: ["checkout", "setup-node"],
        cronSchedulePattern: /^(\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|\*\/([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|\*\/([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\*|([1-9]|1[0-9]|2[0-9]|3[0-1])|\*\/([1-9]|1[0-9]|2[0-9]|3[0-1])) (\*|([1-9]|1[0-2])|\*\/([1-9]|1[0-2])) (\*|([0-6])|\*\/([0-6]))$/
      },
      
      // Health check intervals
      healthCheckInterval: 60000, // 1 minute
      backupSyncInterval: 300000, // 5 minutes
      
      // Error thresholds
      maxValidationErrors: 3,
      maxWorkflowFailures: 2
    };
    
    this.monitoring = false;
    this.checkInterval = null;
    this.backupInterval = null;
    this.healthHistory = new Map();
    this.errorCounts = new Map();
    this.lastBackupSync = new Date();
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
=======
    this.config = {
      // GitHub Actions workflows to monitor
      workflows: [
        ".github/workflows/marketing-sync.yml",
        ".github/workflows/sync-health.yml"
      ],
      
      // Backup npm scripts for GitHub Actions operations
      backupScripts: {
        trigger: [
          "gh:trigger",
          "gh:auto-heal"
        ],
        manual: [
          "marketing:sync:start",
          "sync:health:start"
        ],
        status: [
          "automation:status",
          "redundancy:github"
        ]
      },
      
      // Scheduled tasks that should run
      scheduledTasks: [
        {
          name: "marketing-sync",
          cron: "0 */12 * * *", // Every 12 hours
          script: "automation/marketing-sync.js",
          backupScripts: ["marketing:sync:start", "front:advertise"]
        },
        {
          name: "sync-health",
          cron: "*/15 * * * *", // Every 15 minutes
          script: "automation/pm2-auto-sync.js",
          backupScripts: ["sync:health:start", "git:sync"]
        }
      ],
      
      // Health check configuration
      healthCheck: {
        interval: 60000, // 1 minute
        maxFailureThreshold: 3,
        workflowValidation: true,
        cronValidation: true
      },
      
      // Logging configuration
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024, // 10MB
        maxLogFiles: 30
      }
    };
    
    this.ensureLogDirectory();
    this.workflowStatus = new Map();
    this.failureCounts = new Map();
    this.lastRunTimes = new Map();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
=======
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `github-actions-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
<<<<<<< HEAD
        cwd: this.workspace,
=======
        cwd: process.cwd(),
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
<<<<<<< HEAD
        timeout: options.timeout || 30000,
=======
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  // Check if workflows directory exists
  checkWorkflowsDirectory() {
    if (!fs.existsSync(this.config.workflowsDir)) {
      this.log("GitHub workflows directory not found", "ERROR");
      return false;
    }
    
    this.log("GitHub workflows directory found", "INFO");
    return true;
  }

  // List all workflow files
  listWorkflowFiles() {
    try {
      if (!fs.existsSync(this.config.workflowsDir)) {
        return [];
      }
      
      const files = fs.readdirSync(this.config.workflowsDir);
      return files.filter(file => file.endsWith('.yml') || file.endsWith('.yaml'));
    } catch (error) {
      this.log(`Failed to list workflow files: ${error.message}`, "ERROR");
      return [];
    }
  }

  // Validate YAML syntax
  validateYAMLSyntax(content, filename) {
    try {
      yaml.load(content);
      return { valid: true, error: null };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  // Validate workflow structure
  validateWorkflowStructure(content, filename) {
    const errors = [];
    
    try {
      const workflow = yaml.load(content);
      
      // Check required sections
      for (const section of this.config.validationRules.requiredSections) {
        if (!workflow[section]) {
          errors.push(`Missing required section: ${section}`);
        }
      }
      
      // Check permissions
      if (workflow.permissions) {
        const hasContentsPermission = workflow.permissions.contents === "write" || 
                                   workflow.permissions.contents === "read";
        if (!hasContentsPermission) {
          errors.push("Missing or insufficient contents permission");
        }
      } else {
        errors.push("Missing permissions section");
      }
      
      // Check jobs structure
      if (workflow.jobs) {
        for (const [jobName, job] of Object.entries(workflow.jobs)) {
          if (!job.steps || !Array.isArray(job.steps)) {
            errors.push(`Job ${jobName} missing or invalid steps`);
            continue;
          }
          
          // Check for required steps
          const stepNames = job.steps.map(step => step.name || step.uses || '');
          const hasCheckout = stepNames.some(name => name.includes('checkout'));
          const hasSetupNode = stepNames.some(name => name.includes('setup-node'));
          
          if (!hasCheckout) {
            errors.push(`Job ${jobName} missing checkout step`);
          }
          if (!hasSetupNode) {
            errors.push(`Job ${jobName} missing setup-node step`);
          }
        }
      }
      
      // Check cron schedule if present
      if (workflow.on && workflow.on.schedule) {
        for (const schedule of workflow.on.schedule) {
          if (schedule.cron && !this.config.validationRules.cronSchedulePattern.test(schedule.cron)) {
            errors.push(`Invalid cron schedule: ${schedule.cron}`);
          }
        }
      }
      
    } catch (error) {
      errors.push(`YAML parsing error: ${error.message}`);
    }
    
    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  // Validate individual workflow
  async validateWorkflow(filename) {
    try {
      const filepath = path.join(this.config.workflowsDir, filename);
      
      if (!fs.existsSync(filepath)) {
        return {
          valid: false,
          error: "File not found",
          filename: filename
        };
      }
      
      const content = fs.readFileSync(filepath, 'utf8');
      
      // Check YAML syntax
      const yamlValidation = this.validateYAMLSyntax(content, filename);
      if (!yamlValidation.valid) {
        return {
          valid: false,
          error: `YAML syntax error: ${yamlValidation.error}`,
          filename: filename
        };
      }
      
      // Check workflow structure
      const structureValidation = this.validateWorkflowStructure(content, filename);
      if (!structureValidation.valid) {
        return {
          valid: false,
          error: `Structure validation failed: ${structureValidation.errors.join(', ')}`,
          filename: filename,
          details: structureValidation.errors
        };
      }
      
      return {
        valid: true,
        filename: filename
      };
      
    } catch (error) {
      return {
        valid: false,
        error: error.message,
        filename: filename
      };
    }
  }

  // Validate all workflows
  async validateAllWorkflows() {
    try {
      this.log("Validating all GitHub Actions workflows", "INFO");
      
      const workflowFiles = this.listWorkflowFiles();
      if (workflowFiles.length === 0) {
        this.log("No workflow files found", "WARN");
        return { valid: false, workflows: [] };
      }
      
      const validationResults = [];
      let overallValid = true;
      
      for (const filename of workflowFiles) {
        const result = await this.validateWorkflow(filename);
        validationResults.push(result);
        
        if (!result.valid) {
          overallValid = false;
          this.log(`Workflow ${filename} validation failed: ${result.error}`, "ERROR");
          
          // Increment error count
          const currentCount = this.errorCounts.get(filename) || 0;
          this.errorCounts.set(filename, currentCount + 1);
        } else {
          this.log(`Workflow ${filename} validation passed`, "INFO");
          // Reset error count on success
          this.errorCounts.set(filename, 0);
        }
      }
      
      return {
        valid: overallValid,
        workflows: validationResults,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      this.log(`Workflow validation failed: ${error.message}`, "ERROR");
      return { valid: false, error: error.message };
    }
  }

  // Check backup workflow pairs
  async checkBackupWorkflows() {
    try {
      this.log("Checking backup workflow pairs", "INFO");
      
      const results = {};
      let allBackupsValid = true;
      
      for (const [primary, backup] of Object.entries(this.config.workflowPairs)) {
        const primaryPath = path.join(this.config.workflowsDir, primary);
        const backupPath = path.join(this.config.workflowsDir, backup);
        
        const primaryExists = fs.existsSync(primaryPath);
        const backupExists = fs.existsSync(backupPath);
        
        if (!primaryExists) {
          this.log(`Primary workflow not found: ${primary}`, "ERROR");
          allBackupsValid = false;
          results[primary] = { status: "missing", backup: backupExists };
          continue;
        }
        
        if (!backupExists) {
          this.log(`Backup workflow missing: ${backup}`, "WARN");
          results[primary] = { status: "no_backup", backup: false };
          continue;
        }
        
        // Validate both workflows
        const primaryValidation = await this.validateWorkflow(primary);
        const backupValidation = await this.validateWorkflow(backup);
        
        if (primaryValidation.valid && backupValidation.valid) {
          this.log(`Backup pair valid: ${primary} ↔ ${backup}`, "INFO");
          results[primary] = { 
            status: "valid", 
            backup: true,
            primary: primaryValidation,
            backup: backupValidation
          };
        } else {
          this.log(`Backup pair validation failed: ${primary} ↔ ${backup}`, "ERROR");
          allBackupsValid = false;
          results[primary] = {
            status: "validation_failed",
            backup: true,
            primary: primaryValidation,
            backup: backupValidation
          };
        }
      }
      
      return {
        valid: allBackupsValid,
        results: results,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      this.log(`Backup workflow check failed: ${error.message}`, "ERROR");
      return { valid: false, error: error.message };
    }
  }

  // Create backup workflow if missing
  async createBackupWorkflow(primaryWorkflow, backupWorkflow) {
    try {
      const primaryPath = path.join(this.config.workflowsDir, primaryWorkflow);
      const backupPath = path.join(this.config.workflowsDir, backupWorkflow);
      
      if (!fs.existsSync(primaryPath)) {
        this.log(`Cannot create backup: primary workflow ${primaryWorkflow} not found`, "ERROR");
        return false;
      }
      
      if (fs.existsSync(backupPath)) {
        this.log(`Backup workflow ${backupWorkflow} already exists`, "INFO");
        return true;
      }
      
      // Read primary workflow content
      const primaryContent = fs.readFileSync(primaryPath, 'utf8');
      
      // Create backup content with modified triggers
      let backupContent = primaryContent;
      
      // Modify the backup workflow to have different triggers
      if (primaryContent.includes("schedule:")) {
        // Add a delay to the cron schedule for backup workflows
        backupContent = backupContent.replace(
          /cron:\s*'([^']+)'/g,
          (match, cron) => {
            // Add 5 minutes to the cron schedule
            const parts = cron.split(' ');
            if (parts.length >= 2) {
              const minute = parseInt(parts[1]);
              const newMinute = (minute + 5) % 60;
              parts[1] = newMinute.toString();
            }
            return `cron: '${parts.join(' ')}'`;
          }
        );
      }
      
      // Add backup indicator to workflow name
      backupContent = backupContent.replace(
        /name:\s*([^\n]+)/,
        "name: $1 (Backup)"
      );
      
      // Write backup workflow
      fs.writeFileSync(backupPath, backupContent);
      this.log(`Backup workflow created: ${backupWorkflow}`, "INFO");
      
      return true;
      
    } catch (error) {
      this.log(`Failed to create backup workflow: ${error.message}`, "ERROR");
      return false;
    }
  }

  // Sync backup workflows
  async syncBackupWorkflows() {
    try {
      this.log("Syncing backup workflows", "INFO");
      
      const now = new Date();
      const timeSinceLastSync = now - this.lastBackupSync;
      
      if (timeSinceLastSync < this.config.backupSyncInterval) {
        this.log("Backup sync not due yet", "INFO");
        return true;
      }
      
      for (const [primary, backup] of Object.entries(this.config.workflowPairs)) {
        await this.createBackupWorkflow(primary, backup);
      }
      
      this.lastBackupSync = now;
      this.log("Backup workflow sync completed", "INFO");
      
      return true;
      
    } catch (error) {
      this.log(`Backup workflow sync failed: ${error.message}`, "ERROR");
=======
  validateWorkflowFile(workflowPath) {
    try {
      if (!fs.existsSync(workflowPath)) {
        return { valid: false, error: "File not found" };
      }
      
      const content = fs.readFileSync(workflowPath, 'utf8');
      
      // Basic YAML validation
      try {
        const parsed = yaml.load(content);
        
        if (!parsed.name) {
          return { valid: false, error: "Missing workflow name" };
        }
        
        if (!parsed.on) {
          return { valid: false, error: "Missing trigger configuration" };
        }
        
        if (!parsed.jobs) {
          return { valid: false, error: "Missing jobs configuration" };
        }
        
        return { valid: true, parsed };
      } catch (yamlError) {
        return { valid: false, error: `YAML parsing error: ${yamlError.message}` };
      }
    } catch (error) {
      return { valid: false, error: `File read error: ${error.message}` };
    }
  }

  async checkWorkflowHealth(workflowPath) {
    this.log(`Checking workflow health: ${workflowPath}`);
    
    const validation = this.validateWorkflowFile(workflowPath);
    
    if (!validation.valid) {
      this.log(`Workflow ${workflowPath} is invalid: ${validation.error}`, "ERROR");
      return false;
    }
    
    const workflow = validation.parsed;
    const workflowName = path.basename(workflowPath, '.yml');
    
    // Check if workflow has proper triggers
    const hasTriggers = workflow.on && (
      workflow.on.schedule || 
      workflow.on.workflow_dispatch || 
      workflow.on.push || 
      workflow.on.pull_request
    );
    
    if (!hasTriggers) {
      this.log(`Workflow ${workflowName} has no valid triggers`, "WARN");
    }
    
    // Check if workflow has proper permissions
    const hasPermissions = workflow.permissions && (
      workflow.permissions.contents || 
      workflow.permissions.actions
    );
    
    if (!hasPermissions) {
      this.log(`Workflow ${workflowName} has no proper permissions`, "WARN");
    }
    
    // Check if workflow has proper jobs
    const hasJobs = workflow.jobs && Object.keys(workflow.jobs).length > 0;
    
    if (!hasJobs) {
      this.log(`Workflow ${workflowName} has no jobs`, "ERROR");
      return false;
    }
    
    // Check if workflow has proper steps
    let hasValidSteps = false;
    for (const jobName in workflow.jobs) {
      const job = workflow.jobs[jobName];
      if (job.steps && Array.isArray(job.steps) && job.steps.length > 0) {
        hasValidSteps = true;
        break;
      }
    }
    
    if (!hasValidSteps) {
      this.log(`Workflow ${workflowName} has no valid steps`, "ERROR");
      return false;
    }
    
    this.log(`Workflow ${workflowName} is healthy`);
    return true;
  }

  async checkAllWorkflows() {
    this.log("Checking health of all GitHub Actions workflows...");
    
    const results = {};
    let allHealthy = true;
    
    for (const workflow of this.config.workflows) {
      const isHealthy = await this.checkWorkflowHealth(workflow);
      results[workflow] = isHealthy;
      
      if (!isHealthy) {
        allHealthy = false;
        this.failureCounts.set(workflow, (this.failureCounts.get(workflow) || 0) + 1);
      } else {
        this.failureCounts.set(workflow, 0);
      }
      
      this.workflowStatus.set(workflow, {
        healthy: isHealthy,
        lastCheck: new Date().toISOString(),
        failureCount: this.failureCounts.get(workflow) || 0
      });
    }
    
    if (allHealthy) {
      this.log("All GitHub Actions workflows are healthy");
    } else {
      this.log("Some GitHub Actions workflows are unhealthy, check logs for details", "WARN");
    }
    
    return results;
  }

  async triggerWorkflow(workflowName) {
    this.log(`Triggering workflow: ${workflowName}`);
    
    try {
      // Try to trigger via GitHub CLI if available
      let result = await this.runCommand("gh", ["workflow", "run", workflowName]);
      
      if (result.status === 0) {
        this.log(`Successfully triggered workflow ${workflowName} via GitHub CLI`);
        return true;
      }
      
      // Try npm scripts as backup
      for (const script of this.config.backupScripts.trigger) {
        try {
          result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Successfully triggered workflow via npm script: ${script}`);
            return true;
          }
        } catch (error) {
          this.log(`Error running trigger script ${script}: ${error.message}`, "WARN");
        }
      }
      
      // Try manual execution of workflow scripts
      const scheduledTask = this.config.scheduledTasks.find(task => task.name === workflowName);
      if (scheduledTask) {
        try {
          result = await this.runCommand("node", [scheduledTask.script]);
          if (result.status === 0) {
            this.log(`Successfully executed workflow script: ${scheduledTask.script}`);
            return true;
          }
        } catch (error) {
          this.log(`Error executing workflow script ${scheduledTask.script}: ${error.message}`, "WARN");
        }
        
        // Try backup scripts
        for (const backupScript of scheduledTask.backupScripts) {
          try {
            result = await this.runCommand("npm", ["run", backupScript]);
            if (result.status === 0) {
              this.log(`Successfully executed backup script: ${backupScript}`);
              return true;
            }
          } catch (error) {
            this.log(`Error executing backup script ${backupScript}: ${error.message}`, "WARN");
          }
        }
      }
      
      this.log(`Failed to trigger workflow ${workflowName} with all methods`, "ERROR");
      return false;
    } catch (error) {
      this.log(`Error triggering workflow ${workflowName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  async runScheduledTask(taskName) {
    this.log(`Running scheduled task: ${taskName}`);
    
    const scheduledTask = this.config.scheduledTasks.find(task => task.name === taskName);
    if (!scheduledTask) {
      this.log(`Scheduled task ${taskName} not found`, "ERROR");
      return false;
    }
    
    try {
      // Check if it's time to run the task based on cron
      const shouldRun = this.shouldRunBasedOnCron(scheduledTask.cron);
      if (!shouldRun) {
        this.log(`Scheduled task ${taskName} is not due to run yet`);
        return true;
      }
      
      // Try to run the main script
      let result = await this.runCommand("node", [scheduledTask.script]);
      
      if (result.status === 0) {
        this.log(`Successfully executed scheduled task ${taskName}`);
        this.lastRunTimes.set(taskName, new Date().toISOString());
        return true;
      } else {
        this.log(`Failed to execute scheduled task ${taskName}, trying backup scripts`, "WARN");
        
        // Try backup scripts
        for (const backupScript of scheduledTask.backupScripts) {
          try {
            result = await this.runCommand("npm", ["run", backupScript]);
            if (result.status === 0) {
              this.log(`Successfully executed backup script for ${taskName}: ${backupScript}`);
              this.lastRunTimes.set(taskName, new Date().toISOString());
              return true;
            }
          } catch (error) {
            this.log(`Error executing backup script ${backupScript}: ${error.message}`, "WARN");
          }
        }
        
        this.log(`Failed to execute scheduled task ${taskName} with all methods`, "ERROR");
        return false;
      }
    } catch (error) {
      this.log(`Error running scheduled task ${taskName}: ${error.message}`, "ERROR");
      return false;
    }
  }

  shouldRunBasedOnCron(cronExpression) {
    try {
      // Simple cron validation - this is a basic implementation
      // In production, you might want to use a proper cron parser
      const parts = cronExpression.split(' ');
      if (parts.length !== 5) {
        return false;
      }
      
      const now = new Date();
      const minute = now.getMinutes();
      const hour = now.getHours();
      const dayOfMonth = now.getDate();
      const month = now.getMonth() + 1;
      const dayOfWeek = now.getDay();
      
      // Basic cron matching (simplified)
      const matchMinute = this.matchesCronPart(parts[0], minute);
      const matchHour = this.matchesCronPart(parts[1], hour);
      const matchDayOfMonth = this.matchesCronPart(parts[2], dayOfMonth);
      const matchMonth = this.matchesCronPart(parts[3], month);
      const matchDayOfWeek = this.matchesCronPart(parts[4], dayOfWeek);
      
      return matchMinute && matchHour && matchDayOfMonth && matchMonth && matchDayOfWeek;
    } catch (error) {
      this.log(`Error parsing cron expression ${cronExpression}: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
      return false;
    }
  }

<<<<<<< HEAD
  // Check workflow execution status (if possible)
  async checkWorkflowExecutionStatus() {
    try {
      // This would typically involve GitHub API calls
      // For now, we'll check if the workflow files are recent
      const results = {};
      
      for (const [primary, backup] of Object.entries(this.config.workflowPairs)) {
        const primaryPath = path.join(this.config.workflowsDir, primary);
        const backupPath = path.join(this.config.workflowsDir, backup);
        
        if (fs.existsSync(primaryPath)) {
          const stats = fs.statSync(primaryPath);
          results[primary] = {
            lastModified: stats.mtime,
            size: stats.size
          };
        }
        
        if (fs.existsSync(backupPath)) {
          const stats = fs.statSync(backupPath);
          results[backup] = {
            lastModified: stats.mtime,
            size: stats.size
          };
        }
      }
      
      return results;
      
    } catch (error) {
      this.log(`Workflow execution status check failed: ${error.message}`, "ERROR");
      return {};
    }
  }

  // Perform comprehensive health check
  async performHealthCheck() {
    try {
      this.log("Performing GitHub Actions health check", "INFO");
      
      // Check workflows directory
      if (!this.checkWorkflowsDirectory()) {
        return { valid: false, error: "Workflows directory not found" };
      }
      
      // Validate all workflows
      const validationResult = await this.validateAllWorkflows();
      
      // Check backup workflows
      const backupResult = await this.checkBackupWorkflows();
      
      // Check execution status
      const executionStatus = await this.checkWorkflowExecutionStatus();
      
      // Determine overall health
      const overallHealth = validationResult.valid && backupResult.valid;
      
      const healthResult = {
        timestamp: new Date().toISOString(),
        valid: overallHealth,
        validation: validationResult,
        backup: backupResult,
        execution: executionStatus,
        errorCounts: Object.fromEntries(this.errorCounts)
      };
      
      this.healthHistory.set("github-actions", healthResult);
      
      if (overallHealth) {
        this.log("All GitHub Actions workflows healthy", "INFO");
      } else {
        this.log("Some GitHub Actions workflows unhealthy", "WARN");
      }
      
      return healthResult;
      
    } catch (error) {
      this.log(`GitHub Actions health check failed: ${error.message}`, "ERROR");
      return { valid: false, error: error.message };
    }
  }

  // Start monitoring
  start() {
    if (this.monitoring) {
      this.log("GitHub Actions redundancy monitoring already started", "WARN");
      return;
    }
    
    this.monitoring = true;
    this.log("Starting GitHub Actions redundancy monitoring", "INFO");
    
    // Start health check monitoring
    this.checkInterval = setInterval(async () => {
      await this.performHealthCheck();
    }, this.config.healthCheckInterval);
    
    // Start backup sync monitoring
    this.backupInterval = setInterval(async () => {
      await this.syncBackupWorkflows();
    }, this.config.backupSyncInterval);
    
    this.log("GitHub Actions redundancy monitoring started", "INFO");
  }

  // Stop monitoring
  stop() {
    if (!this.monitoring) {
      this.log("GitHub Actions redundancy monitoring not running", "WARN");
      return;
    }
    
    this.monitoring = false;
    
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    
    if (this.backupInterval) {
      clearInterval(this.backupInterval);
      this.backupInterval = null;
    }
    
    this.log("GitHub Actions redundancy monitoring stopped", "INFO");
  }

  // Get status
  getStatus() {
    return {
      monitoring: this.monitoring,
      health: this.healthHistory.get("github-actions") || null,
      errorCounts: Object.fromEntries(this.errorCounts),
      lastBackupSync: this.lastBackupSync,
      config: this.config
    };
  }

  // Run health check once
  async runOnce() {
    this.log("Running GitHub Actions health check once", "INFO");
    return await this.performHealthCheck();
  }

  // Force backup sync
  async forceBackupSync() {
    this.log("Forcing backup workflow sync", "INFO");
    this.lastBackupSync = new Date(0); // Reset to force sync
    return await this.syncBackupWorkflows();
  }
=======
  matchesCronPart(cronPart, value) {
    if (cronPart === '*') return true;
    if (cronPart === value.toString()) return true;
    
    // Handle ranges like "0-59"
    if (cronPart.includes('-')) {
      const [min, max] = cronPart.split('-').map(Number);
      return value >= min && value <= max;
    }
    
    // Handle steps like "*/15"
    if (cronPart.includes('/')) {
      const [range, step] = cronPart.split('/');
      if (range === '*') {
        return value % step === 0;
      }
    }
    
    return false;
  }

  async runAllScheduledTasks() {
    this.log("Running all scheduled tasks...");
    
    const results = {};
    
    for (const task of this.config.scheduledTasks) {
      const success = await this.runScheduledTask(task.name);
      results[task.name] = success;
      
      if (success) {
        this.log(`Successfully executed scheduled task: ${task.name}`);
      } else {
        this.log(`Failed to execute scheduled task: ${task.name}`, "ERROR");
      }
      
      // Add delay between tasks
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
    
    return results;
  }

  async testBackupScripts() {
    this.log("Testing backup scripts...");
    
    const results = {};
    
    for (const category in this.config.backupScripts) {
      results[category] = {};
      
      for (const script of this.config.backupScripts[category]) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          results[category][script] = {
            success: result.status === 0,
            status: result.status,
            output: result.stdout
          };
          
          if (result.status === 0) {
            this.log(`Backup script ${script} is working`);
          } else {
            this.log(`Backup script ${script} failed`, "WARN");
          }
        } catch (error) {
          results[category][script] = {
            success: false,
            error: error.message
          };
          this.log(`Error testing backup script ${script}: ${error.message}`, "ERROR");
        }
      }
    }
    
    return results;
  }

  async generateHealthReport() {
    const report = {
      timestamp: new Date().toISOString(),
      workflows: {},
      scheduledTasks: {},
      backupScripts: {},
      summary: {
        totalWorkflows: this.config.workflows.length,
        healthyWorkflows: 0,
        unhealthyWorkflows: 0,
        totalScheduledTasks: this.config.scheduledTasks.length,
        lastRunTimes: Object.fromEntries(this.lastRunTimes)
      }
    };
    
    // Workflow status
    for (const [workflow, status] of this.workflowStatus) {
      report.workflows[workflow] = status;
      
      if (status.healthy) {
        report.summary.healthyWorkflows++;
      } else {
        report.summary.unhealthyWorkflows++;
      }
    }
    
    // Scheduled task status
    for (const task of this.config.scheduledTasks) {
      report.scheduledTasks[task.name] = {
        cron: task.cron,
        script: task.script,
        backupScripts: task.backupScripts,
        lastRun: this.lastRunTimes.get(task.name) || "never"
      };
    }
    
    // Test backup scripts
    report.backupScripts = await this.testBackupScripts();
    
    const reportFile = path.join(this.config.logging.logDir, `github-actions-health-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    this.log(`Health report generated: ${reportFile}`);
    return report;
  }

  async startMonitoring() {
    this.log("Starting GitHub Actions redundancy monitoring...");
    
    // Initial health check
    await this.checkAllWorkflows();
    
    // Set up periodic health checks
    setInterval(async () => {
      await this.checkAllWorkflows();
    }, this.config.healthCheck.interval);
    
    // Set up periodic scheduled task execution
    setInterval(async () => {
      await this.runAllScheduledTasks();
    }, 300000); // 5 minutes
    
    // Set up periodic report generation
    setInterval(async () => {
      await this.generateHealthReport();
    }, 600000); // 10 minutes
    
    this.log("GitHub Actions redundancy monitoring started");
  }

  async start() {
    this.log("Starting GitHub Actions Redundancy Manager...");
    
    try {
      // Check all workflows
      await this.checkAllWorkflows();
      
      // Test backup scripts
      await this.testBackupScripts();
      
      // Start monitoring
      await this.startMonitoring();
      
      this.log("GitHub Actions Redundancy Manager started successfully");
      
      // Keep the process running
      setInterval(() => {
        this.log("GitHub Actions Redundancy Manager heartbeat");
      }, 300000); // 5 minutes
      
    } catch (error) {
      this.log(`Error starting GitHub Actions Redundancy Manager: ${error.message}`, "ERROR");
      process.exit(1);
    }
  }
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
}

// CLI interface
if (require.main === module) {
  const manager = new GitHubActionsRedundancyManager();
<<<<<<< HEAD
  const command = process.argv[2] || "start";
  
  switch (command) {
    case "start":
      manager.start();
      break;
    case "stop":
      manager.stop();
      break;
    case "status":
      console.log(JSON.stringify(manager.getStatus(), null, 2));
      break;
    case "once":
      manager.runOnce().then(result => {
        console.log(JSON.stringify(result, null, 2));
        process.exit(0);
      });
      break;
    case "health":
      manager.performHealthCheck().then(result => {
        console.log(JSON.stringify(result, null, 2));
        process.exit(0);
      });
      break;
    case "sync":
      manager.forceBackupSync().then(result => {
        console.log(JSON.stringify({ synced: result }, null, 2));
        process.exit(0);
      });
      break;
    case "validate":
      manager.validateAllWorkflows().then(result => {
        console.log(JSON.stringify(result, null, 2));
        process.exit(0);
      });
      break;
    default:
      console.log("Usage: node github-actions-redundancy-manager.cjs [start|stop|status|once|health|sync|validate]");
      process.exit(1);
=======
  
  const command = process.argv[2] || 'start';
  
  switch (command) {
    case 'start':
      manager.start();
      break;
    case 'monitor':
      manager.startMonitoring();
      break;
    case 'health':
      manager.checkAllWorkflows();
      break;
    case 'scheduled':
      manager.runAllScheduledTasks();
      break;
    case 'test-backups':
      manager.testBackupScripts();
      break;
    case 'report':
      manager.generateHealthReport();
      break;
    case 'trigger':
      const workflowName = process.argv[3];
      if (workflowName) {
        manager.triggerWorkflow(workflowName);
      } else {
        console.log("Please specify a workflow name to trigger");
      }
      break;
    default:
      console.log(`
GitHub Actions Redundancy Manager

Usage: node github-actions-redundancy-manager.cjs [command]

Commands:
  start           Start the manager and monitoring (default)
  monitor         Start monitoring only
  health          Check health of all workflows
  scheduled       Run all scheduled tasks
  test-backups    Test all backup scripts
  report          Generate health report
  trigger <name>  Trigger a specific workflow
      `);
      process.exit(0);
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
  }
}

module.exports = GitHubActionsRedundancyManager;