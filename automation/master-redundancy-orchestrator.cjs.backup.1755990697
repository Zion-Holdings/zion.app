#!/usr/bin/env node
"use strict";

const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");
<<<<<<< HEAD
=======
const crypto = require("crypto");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-60e4

class MasterRedundancyOrchestrator {
  constructor() {
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "master-redundancy-orchestrator.log");
    this.ensureLogDir();
<<<<<<< HEAD
    
    this.config = {
      systems: {
        pm2: {
          enabled: true,
          script: "automation/enhanced-pm2-redundancy.cjs",
          healthCheckInterval: 30000,
          autoRecovery: true
        },
        githubActions: {
          enabled: true,
          script: "automation/enhanced-github-actions-redundancy.cjs",
          healthCheckInterval: 60000,
          autoRecovery: true
        },
        netlifyFunctions: {
          enabled: true,
          script: "automation/enhanced-netlify-functions-redundancy.cjs",
          healthCheckInterval: 120000,
          autoRecovery: true
        }
      },
      orchestration: {
        masterCheckInterval: 60000,
        systemStartupDelay: 10000,
        maxConcurrentRecoveries: 2,
        emergencyMode: false
      },
      logging: {
        logLevel: "INFO",
        maxLogSize: 10 * 1024 * 1024,
        maxLogFiles: 30
      }
    };
    
    this.systems = new Map();
    this.monitoring = false;
    this.checkInterval = null;
    this.recoveryInProgress = false;
    this.systemStatus = new Map();
=======
    this.config = this.loadConfig();
    this.monitoring = false;
    this.checkInterval = null;
    this.redundancySystems = new Map();
    this.systemStatus = new Map();
    this.overallHealth = "UNKNOWN";
    this.lastCheckTime = null;
    this.alertThreshold = 3;
    this.alertCount = 0;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-60e4
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

<<<<<<< HEAD
=======
  loadConfig() {
    const configPath = path.join(this.workspace, "automation/redundancy-config.json");
    if (fs.existsSync(configPath)) {
      try {
        const config = JSON.parse(fs.readFileSync(configPath, "utf8"));
        return config.master || {};
      } catch (error) {
        this.log(`Error loading master config: ${error.message}`);
      }
    }
    
    return {
      enabled: true,
      checkInterval: 60000, // 1 minute
      maxFailures: 3,
      alertThreshold: 3,
      autoRecovery: true,
      systems: {
        pm2: {
          enabled: true,
          priority: "HIGH",
          checkInterval: 30000,
          maxRestartAttempts: 5
        },
        githubActions: {
          enabled: true,
          priority: "MEDIUM",
          checkInterval: 60000,
          maxRetries: 3
        },
        netlifyFunctions: {
          enabled: true,
          priority: "MEDIUM",
          checkInterval: 120000,
          maxRetries: 3
        }
      },
      monitoring: {
        healthChecks: true,
        resourceMonitoring: true,
        alerting: true,
        reporting: true,
        autoEscalation: true
      },
      escalation: {
        levels: ["WARN", "ERROR", "CRITICAL"],
        timeouts: [300000, 600000, 1800000], // 5min, 10min, 30min
        actions: ["restart", "redeploy", "emergency"]
      }
    };
  }

>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-60e4
  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: this.workspace,
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 10,
        timeout: options.timeout || 30000,
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  async checkSystemHealth(systemName) {
    try {
      let health = 0;
      let details = {};

      switch (systemName) {
        case 'pm2':
          if (this.config.systems.pm2.enabled) {
            const report = await this.pm2Redundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;

        case 'githubActions':
          if (this.config.systems.githubActions.enabled) {
            const report = await this.githubActionsRedundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;

        case 'netlifyFunctions':
          if (this.config.systems.netlifyFunctions.enabled) {
            const report = await this.netlifyFunctionsRedundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;
      }

      return { health, details };
    } catch (error) {
      this.log(`Error checking ${systemName} health: ${error.message}`, "ERROR");
      return { health: 0, details: { error: error.message } };
    }
  }

  async backupAllSystems() {
    try {
      const backupDir = path.join(this.workspace, "automation/backups/master");
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(backupDir, `master-backup-${timestamp}`);
      fs.mkdirSync(backupPath, { recursive: true });

      // Backup PM2 ecosystem files
      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.backupEcosystemFiles();
      }

      // Backup GitHub Actions workflows
      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.backupWorkflows();
      }

      // Backup Netlify functions
      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.backupFunctions();
      }

      // Backup configuration files
      const configFiles = [
        "ecosystem.pm2.cjs",
        "ecosystem.redundancy.cjs",
        ".github/workflows/",
        "netlify/",
        "automation/redundancy-config.json"
      ];

      for (const configFile of configFiles) {
        const sourcePath = path.join(this.workspace, configFile);
        if (fs.existsSync(sourcePath)) {
          const targetPath = path.join(backupPath, configFile);
          if (fs.lstatSync(sourcePath).isDirectory()) {
            await this.runCommand("cp", ["-r", sourcePath, targetPath]);
          } else {
            fs.copyFileSync(sourcePath, targetPath);
          }
        }
      }

      this.log(`Master backup completed: ${backupPath}`, "INFO");
      this.lastBackup = Date.now();
      return true;
    } catch (error) {
      this.log(`Failed to backup all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async restoreAllSystems(backupTimestamp = null) {
    try {
      this.log("Starting system-wide restoration", "WARN");
      
      // Stop all monitoring
      await this.stopAllMonitoring();

      // Restore each system
      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.restoreFromBackup();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.restoreWorkflowsFromBackup();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.restoreFunctionsFromBackup();
      }

      // Restart monitoring
      await this.startAllMonitoring();

      this.log("System-wide restoration completed", "INFO");
      return true;
    } catch (error) {
      this.log(`System-wide restoration failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async startAllMonitoring() {
    try {
      this.log("Starting all redundancy systems", "INFO");

      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.startMonitoring();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.startMonitoring();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.startMonitoring();
      }

      this.log("All redundancy systems started", "INFO");
      return true;
    } catch (error) {
      this.log(`Failed to start all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async stopAllMonitoring() {
    try {
      this.log("Stopping all redundancy systems", "INFO");

      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.stopMonitoring();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.stopMonitoring();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.stopMonitoring();
      }

      this.log("All redundancy systems stopped", "INFO");
      return true;
    } catch (error) {
      this.log(`Failed to stop all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async monitorAllSystems() {
    this.log("Starting master system monitoring...", "INFO");
    
    const systemNames = Object.keys(this.config.systems);
    let totalHealth = 0;
    let healthySystems = 0;

    for (const systemName of systemNames) {
      if (this.config.systems[systemName].enabled) {
        try {
          const { health, details } = await this.checkSystemHealth(systemName);
          
          this.systemStates.set(systemName, { health, details, lastCheck: Date.now() });
          
          if (health >= this.config.systems[systemName].healthThreshold) {
            healthySystems++;
            this.log(`System ${systemName} healthy (${(health * 100).toFixed(1)}%)`, "INFO");
          } else {
            this.log(`System ${systemName} unhealthy (${(health * 100).toFixed(1)}%)`, "WARN");
            
            // Attempt auto-recovery if enabled
            if (this.config.systems[systemName].autoRecovery) {
              await this.attemptSystemRecovery(systemName);
            }
          }
          
          totalHealth += health;
          
        } catch (error) {
          this.log(`Error monitoring system ${systemName}: ${error.message}`, "ERROR");
          this.systemStates.set(systemName, { health: 0, details: { error: error.message }, lastCheck: Date.now() });
        }
      }
    }

    // Calculate overall health
    this.overallHealth = totalHealth / systemNames.length;
    
    // Check if emergency mode is needed
    if (this.overallHealth < 0.5 && !this.config.emergencyMode) {
      await this.enterEmergencyMode();
    } else if (this.overallHealth >= 0.8 && this.config.emergencyMode) {
      await this.exitEmergencyMode();
    }

    this.log(`Overall system health: ${(this.overallHealth * 100).toFixed(1)}% (${healthySystems}/${systemNames.length} healthy)`, "INFO");
  }

  async attemptSystemRecovery(systemName) {
    try {
      this.log(`Attempting recovery for system: ${systemName}`, "WARN");
      
      let recoverySuccess = false;
      
      switch (systemName) {
        case 'pm2':
          recoverySuccess = await this.pm2Redundancy.emergencyRecovery();
          break;
        case 'githubActions':
          recoverySuccess = await this.githubActionsRedundancy.emergencyRecovery();
          break;
        case 'netlifyFunctions':
          recoverySuccess = await this.netlifyFunctionsRedundancy.emergencyRecovery();
          break;
      }

      if (recoverySuccess) {
        this.log(`Successfully recovered system: ${systemName}`, "INFO");
        this.recoveryAttempts = 0;
      } else {
        this.recoveryAttempts++;
        this.log(`Failed to recover system: ${systemName} (attempt ${this.recoveryAttempts})`, "ERROR");
      }

      return recoverySuccess;
    } catch (error) {
      this.log(`Error during system recovery: ${error.message}`, "ERROR");
      return false;
    }
  }

  async enterEmergencyMode() {
    this.config.emergencyMode = true;
    this.log("🚨 ENTERING EMERGENCY MODE - System health critically low", "ERROR");
    
    try {
      // Stop all monitoring to prevent interference
      await this.stopAllMonitoring();
      
      // Perform emergency backup
      await this.backupAllSystems();
      
      // Attempt full system recovery
      if (this.recoveryAttempts < this.maxRecoveryAttempts) {
        await this.attemptFullSystemRecovery();
      } else {
        this.log("Maximum recovery attempts reached, manual intervention required", "ERROR");
      }
      
      // Restart monitoring
      await this.startAllMonitoring();
      
    } catch (error) {
      this.log(`Emergency mode error: ${error.message}`, "ERROR");
    }
  }

  async exitEmergencyMode() {
    this.config.emergencyMode = false;
    this.log("✅ EXITING EMERGENCY MODE - System health restored", "INFO");
    this.recoveryAttempts = 0;
  }

  async attemptFullSystemRecovery() {
    try {
      this.log("Attempting full system recovery", "WARN");
      
      // Restore from latest backup
      if (await this.restoreAllSystems()) {
        this.log("Full system recovery successful", "INFO");
        return true;
      }
      
      // If backup restoration fails, try individual system recovery
      const systemNames = Object.keys(this.config.systems);
      let recoveryCount = 0;
      
      for (const systemName of systemNames) {
        if (this.config.systems[systemName].enabled) {
          if (await this.attemptSystemRecovery(systemName)) {
            recoveryCount++;
          }
        }
      }
      
      this.log(`Recovered ${recoveryCount}/${systemNames.length} systems`, "INFO");
      return recoveryCount > 0;
      
    } catch (error) {
      this.log(`Full system recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async generateMasterReport() {
    try {
      const report = {
        timestamp: new Date().toISOString(),
        overallHealth: this.overallHealth,
        emergencyMode: this.config.emergencyMode,
        recoveryAttempts: this.recoveryAttempts,
        systems: {},
        summary: {
          total: Object.keys(this.config.systems).length,
          healthy: 0,
          unhealthy: 0,
          disabled: 0
        }
      };

      for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
        const state = this.systemStates.get(systemName);
        
        if (systemConfig.enabled) {
          if (state && state.health >= systemConfig.healthThreshold) {
            report.summary.healthy++;
          } else {
            report.summary.unhealthy++;
          }
          
          report.systems[systemName] = {
            enabled: true,
            health: state ? state.health : 0,
            priority: systemConfig.priority,
            autoRecovery: systemConfig.autoRecovery,
            lastCheck: state ? state.lastCheck : null,
            details: state ? state.details : {}
          };
        } else {
          report.summary.disabled++;
          report.systems[systemName] = {
            enabled: false,
            health: 0,
            priority: systemConfig.priority,
            autoRecovery: systemConfig.autoRecovery
          };
        }
      }

      // Save report
      const reportPath = path.join(this.logDir, "master-redundancy-report.json");
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      
      this.log(`Master report generated: ${reportPath}`, "INFO");
      return report;
    } catch (error) {
      this.log(`Failed to generate master report: ${error.message}`, "ERROR");
      return null;
    }
=======
  async startSystem(systemName, systemConfig) {
    try {
      this.log(`🚀 Starting ${systemName} redundancy system...`);
      
      if (!fs.existsSync(systemConfig.script)) {
        this.log(`❌ Script not found for ${systemName}: ${systemConfig.script}`, "ERROR");
        return false;
      }

      // Start the system process
      const result = await this.runCommand("node", [systemConfig.script], {
        timeout: 60000
      });

      if (result.status === 0) {
        this.log(`✅ ${systemName} redundancy system started successfully`);
        this.systemStatus.set(systemName, { status: "running", lastStart: new Date().toISOString() });
        return true;
      } else {
        this.log(`❌ Failed to start ${systemName} redundancy system: ${result.stderr}`, "ERROR");
        this.systemStatus.set(systemName, { status: "failed", lastStart: new Date().toISOString(), error: result.stderr });
        return false;
      }
    } catch (error) {
      this.log(`❌ Error starting ${systemName} redundancy system: ${error.message}`, "ERROR");
      this.systemStatus.set(systemName, { status: "error", lastStart: new Date().toISOString(), error: error.message });
      return false;
    }
  }

  async stopSystem(systemName) {
    try {
      this.log(`🛑 Stopping ${systemName} redundancy system...`);
      
      // Find and kill the process
      const result = await this.runCommand("pkill", ["-f", systemName]);
      
      if (result.status === 0 || result.status === 1) { // 1 means no processes found
        this.log(`✅ ${systemName} redundancy system stopped`);
        this.systemStatus.set(systemName, { status: "stopped", lastStop: new Date().toISOString() });
        return true;
      } else {
        this.log(`⚠️ Could not stop ${systemName} redundancy system cleanly`, "WARN");
        return false;
      }
    } catch (error) {
      this.log(`❌ Error stopping ${systemName} redundancy system: ${error.message}`, "ERROR");
      return false;
    }
  }

  async restartSystem(systemName, systemConfig) {
    try {
      this.log(`🔄 Restarting ${systemName} redundancy system...`);
      
      await this.stopSystem(systemName);
      await this.sleep(5000); // Wait for cleanup
      const success = await this.startSystem(systemName, systemConfig);
      
      if (success) {
        this.log(`✅ ${systemName} redundancy system restarted successfully`);
      } else {
        this.log(`❌ Failed to restart ${systemName} redundancy system`, "ERROR");
      }
      
      return success;
    } catch (error) {
      this.log(`❌ Error restarting ${systemName} redundancy system: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkSystemHealth(systemName, systemConfig) {
    try {
      this.log(`🔍 Checking health of ${systemName} redundancy system...`);
      
      // Check if the system process is running
      const result = await this.runCommand("pgrep", ["-f", systemName]);
      const isRunning = result.status === 0;
      
      if (isRunning) {
        this.log(`✅ ${systemName} redundancy system is running`);
        this.systemStatus.set(systemName, { 
          status: "healthy", 
          lastCheck: new Date().toISOString(),
          uptime: await this.getSystemUptime(systemName)
        });
        return true;
      } else {
        this.log(`⚠️ ${systemName} redundancy system is not running`, "WARN");
        this.systemStatus.set(systemName, { 
          status: "down", 
          lastCheck: new Date().toISOString()
        });
        return false;
      }
    } catch (error) {
      this.log(`❌ Error checking health of ${systemName} redundancy system: ${error.message}`, "ERROR");
      return false;
    }
  }

  async getSystemUptime(systemName) {
    try {
      const result = await this.runCommand("pgrep", ["-o", "-f", systemName]);
      if (result.status === 0) {
        const pid = result.stdout.trim();
        const psResult = await this.runCommand("ps", ["-o", "etime=", "-p", pid]);
        if (psResult.status === 0) {
          return psResult.stdout.trim();
        }
      }
      return "unknown";
    } catch (error) {
      return "unknown";
    }
  }

  async performSystemRecovery(systemName, systemConfig) {
    if (this.recoveryInProgress) {
      this.log(`⚠️ Recovery already in progress, skipping ${systemName}`, "WARN");
      return false;
    }

    try {
      this.recoveryInProgress = true;
      this.log(`🚨 Starting recovery for ${systemName} redundancy system...`);
      
      const recoverySuccess = await this.restartSystem(systemName, systemConfig);
      
      if (recoverySuccess) {
        this.log(`✅ Recovery completed successfully for ${systemName}`);
        this.systemStatus.set(systemName, { 
          status: "recovered", 
          lastRecovery: new Date().toISOString()
        });
      } else {
        this.log(`❌ Recovery failed for ${systemName}`, "ERROR");
        this.systemStatus.set(systemName, { 
          status: "recovery_failed", 
          lastRecovery: new Date().toISOString()
        });
      }
      
      return recoverySuccess;
    } catch (error) {
      this.log(`❌ Error during recovery of ${systemName}: ${error.message}`, "ERROR");
      return false;
    } finally {
      this.recoveryInProgress = false;
    }
  }

  async performMasterHealthCheck() {
    this.log("🚀 Starting master redundancy orchestrator health check...");
    
    const results = {
      systems: {},
      overall: {
        healthy: 0,
        unhealthy: 0,
        total: 0
      },
      timestamp: new Date().toISOString()
    };

    // Check each system
    for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
      if (!systemConfig.enabled) {
        this.log(`⏭️ Skipping disabled system: ${systemName}`);
        continue;
      }

      const isHealthy = await this.checkSystemHealth(systemName, systemConfig);
      results.systems[systemName] = {
        enabled: systemConfig.enabled,
        healthy: isHealthy,
        status: this.systemStatus.get(systemName) || { status: "unknown" }
      };

      if (isHealthy) {
        results.overall.healthy++;
      } else {
        results.overall.unhealthy++;
        
        // Attempt recovery if enabled
        if (systemConfig.autoRecovery && !this.recoveryInProgress) {
          this.log(`🔄 Initiating auto-recovery for ${systemName}...`);
          setTimeout(() => this.performSystemRecovery(systemName, systemConfig), 1000);
        }
      }
      
      results.overall.total++;
    }

    // Log results
    this.log(`📊 Master Health Check Results:
    - Total Systems: ${results.overall.total}
    - Healthy: ${results.overall.healthy} ✅
    - Unhealthy: ${results.overall.unhealthy} ❌
    - Health Rate: ${results.overall.total > 0 ? Math.round((results.overall.healthy / results.overall.total) * 100) : 0}%`);

    // Save health check results
    const healthCheckFile = path.join(this.logDir, `master-health-check-${new Date().toISOString().split('T')[0]}.json`);
    try {
      fs.writeFileSync(healthCheckFile, JSON.stringify(results, null, 2));
    } catch (error) {
      this.log(`❌ Failed to save master health check results: ${error.message}`, "ERROR");
    }

    return results;
  }

  async emergencyMode() {
    this.log("🚨 Entering emergency mode - attempting full system recovery...");
    
    try {
      this.config.orchestration.emergencyMode = true;
      
      // Stop all systems
      for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
        if (systemConfig.enabled) {
          await this.stopSystem(systemName);
        }
      }
      
      await this.sleep(10000); // Wait for cleanup
      
      // Start all systems in sequence
      for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
        if (systemConfig.enabled) {
          await this.startSystem(systemName, systemConfig);
          await this.sleep(this.config.orchestration.systemStartupDelay);
        }
      }
      
      // Perform health check
      await this.performMasterHealthCheck();
      
      this.config.orchestration.emergencyMode = false;
      this.log("✅ Emergency mode recovery completed");
      return true;
    } catch (error) {
      this.log(`❌ Emergency mode recovery failed: ${error.message}`, "ERROR");
      this.config.orchestration.emergencyMode = false;
      return false;
    }
  }

  async startAllSystems() {
    this.log("🚀 Starting all redundancy systems...");
    
    const startupResults = {};
    
    for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
      if (systemConfig.enabled) {
        this.log(`📝 Starting ${systemName}...`);
        const success = await this.startSystem(systemName, systemConfig);
        startupResults[systemName] = success;
        
        if (success) {
          await this.sleep(this.config.orchestration.systemStartupDelay);
        }
      } else {
        this.log(`⏭️ Skipping disabled system: ${systemName}`);
        startupResults[systemName] = "disabled";
      }
    }
    
    // Log startup results
    const successful = Object.values(startupResults).filter(r => r === true).length;
    const total = Object.keys(startupResults).length;
    
    this.log(`📊 System Startup Results: ${successful}/${total} systems started successfully`);
    
    return startupResults;
  }

  async stopAllSystems() {
    this.log("🛑 Stopping all redundancy systems...");
    
    const stopResults = {};
    
    for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
      if (systemConfig.enabled) {
        this.log(`📝 Stopping ${systemName}...`);
        const success = await this.stopSystem(systemName);
        stopResults[systemName] = success;
      } else {
        this.log(`⏭️ Skipping disabled system: ${systemName}`);
        stopResults[systemName] = "disabled";
      }
    }
    
    this.log("✅ All redundancy systems stopped");
    return stopResults;
=======
  async initializeRedundancySystems() {
    this.log("Initializing redundancy systems...", "INFO");
    
    try {
      // Initialize PM2 redundancy
      if (this.config.systems.pm2.enabled) {
        const { EnhancedPM2Redundancy } = require("./enhanced-pm2-redundancy.cjs");
        const pm2Redundancy = new EnhancedPM2Redundancy();
        this.redundancySystems.set("pm2", pm2Redundancy);
        this.log("PM2 redundancy system initialized", "INFO");
      }

      // Initialize GitHub Actions redundancy
      if (this.config.systems.githubActions.enabled) {
        const { EnhancedGitHubActionsRedundancy } = require("./enhanced-github-actions-redundancy.cjs");
        const githubRedundancy = new EnhancedGitHubActionsRedundancy();
        this.redundancySystems.set("githubActions", githubRedundancy);
        this.log("GitHub Actions redundancy system initialized", "INFO");
      }

      // Initialize Netlify Functions redundancy
      if (this.config.systems.netlifyFunctions.enabled) {
        const { EnhancedNetlifyFunctionsRedundancy } = require("./enhanced-netlify-functions-redundancy.cjs");
        const netlifyRedundancy = new EnhancedNetlifyFunctionsRedundancy();
        this.redundancySystems.set("netlifyFunctions", netlifyRedundancy);
        this.log("Netlify Functions redundancy system initialized", "INFO");
      }

      this.log(`Initialized ${this.redundancySystems.size} redundancy systems`, "INFO");
      return true;
    } catch (error) {
      this.log(`Error initializing redundancy systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkSystemHealth(systemName) {
    try {
      const system = this.redundancySystems.get(systemName);
      if (!system) {
        return { healthy: false, reason: "System not initialized" };
      }

      let healthResult;
      switch (systemName) {
        case "pm2":
          healthResult = await system.checkAllProcesses();
          break;
        case "githubActions":
          healthResult = await system.checkAllWorkflows();
          break;
        case "netlifyFunctions":
          healthResult = await system.checkAllFunctions();
          break;
        default:
          return { healthy: false, reason: "Unknown system" };
      }

      const healthy = healthResult === 0;
      this.systemStatus.set(systemName, {
        healthy,
        lastCheck: new Date().toISOString(),
        issues: healthy ? 0 : healthResult,
        status: healthy ? "HEALTHY" : "ISSUES"
      });

      return { healthy, issues: healthResult };
    } catch (error) {
      this.log(`Error checking ${systemName} health: ${error.message}`, "ERROR");
      this.systemStatus.set(systemName, {
        healthy: false,
        lastCheck: new Date().toISOString(),
        issues: 1,
        status: "ERROR"
      });
      return { healthy: false, reason: error.message };
    }
  }

  async checkAllSystems() {
    this.log("Starting comprehensive system health check...", "INFO");
    
    const results = new Map();
    let totalIssues = 0;
    let criticalIssues = 0;

    for (const [systemName, system] of this.redundancySystems) {
      try {
        const health = await this.checkSystemHealth(systemName);
        results.set(systemName, health);
        
        if (!health.healthy) {
          totalIssues += health.issues || 1;
          
          // Check if this is a critical system
          const systemConfig = this.config.systems[systemName];
          if (systemConfig && systemConfig.priority === "HIGH") {
            criticalIssues++;
          }
        }
      } catch (error) {
        this.log(`Error checking ${systemName}: ${error.message}`, "ERROR");
        results.set(systemName, { healthy: false, reason: error.message });
        totalIssues++;
      }
    }

    // Determine overall health
    if (criticalIssues > 0) {
      this.overallHealth = "CRITICAL";
    } else if (totalIssues > this.alertThreshold) {
      this.overallHealth = "WARNING";
    } else if (totalIssues === 0) {
      this.overallHealth = "HEALTHY";
    } else {
      this.overallHealth = "DEGRADED";
    }

    this.lastCheckTime = new Date().toISOString();
    this.log(`System health check completed. Overall: ${this.overallHealth}, Issues: ${totalIssues}`, "INFO");

    // Handle alerts and escalation
    if (totalIssues > 0) {
      await this.handleAlerts(totalIssues, criticalIssues);
    }

    return {
      overallHealth: this.overallHealth,
      totalIssues,
      criticalIssues,
      systemResults: results,
      timestamp: this.lastCheckTime
    };
  }

  async handleAlerts(totalIssues, criticalIssues) {
    this.alertCount++;
    
    if (criticalIssues > 0) {
      this.log(`🚨 CRITICAL ALERT: ${criticalIssues} critical system(s) down`, "CRITICAL");
      await this.escalateAlert("CRITICAL", criticalIssues);
    } else if (totalIssues > this.alertThreshold) {
      this.log(`⚠️  WARNING ALERT: ${totalIssues} total issues detected`, "WARN");
      await this.escalateAlert("WARNING", totalIssues);
    }

    // Auto-recovery if enabled
    if (this.config.autoRecovery && this.alertCount >= 2) {
      this.log("Initiating automatic recovery procedures", "INFO");
      await this.autoRecovery();
      this.alertCount = 0;
    }
  }

  async escalateAlert(level, issueCount) {
    try {
      const escalationConfig = this.config.escalation;
      const levelIndex = escalationConfig.levels.indexOf(level);
      
      if (levelIndex === -1) return;

      const timeout = escalationConfig.timeouts[levelIndex];
      const action = escalationConfig.actions[levelIndex];

      this.log(`Escalating to level ${level} with action: ${action}`, "WARN");

      // Wait for timeout before taking action
      await new Promise(resolve => setTimeout(resolve, timeout));

      // Take escalation action
      switch (action) {
        case "restart":
          await this.emergencyRestart();
          break;
        case "redeploy":
          await this.emergencyRedeploy();
          break;
        case "emergency":
          await this.emergencyProcedures();
          break;
      }
    } catch (error) {
      this.log(`Error during alert escalation: ${error.message}`, "ERROR");
    }
  }

  async autoRecovery() {
    this.log("Starting automatic recovery procedures", "INFO");
    
    try {
      // Restart all systems
      for (const [systemName, system] of this.redundancySystems) {
        try {
          if (systemName === "pm2") {
            await system.emergencyRestart();
          } else if (systemName === "netlifyFunctions") {
            await system.deployFunctions();
          }
          this.log(`Recovered ${systemName} system`, "INFO");
        } catch (error) {
          this.log(`Failed to recover ${systemName}: ${error.message}`, "ERROR");
        }
      }

      // Wait for systems to stabilize
      await new Promise(resolve => setTimeout(resolve, 30000));
      
      // Re-check health
      await this.checkAllSystems();
      
    } catch (error) {
      this.log(`Auto-recovery failed: ${error.message}`, "ERROR");
    }
  }

  async emergencyRestart() {
    this.log("🚨 EMERGENCY RESTART INITIATED", "CRITICAL");
    
    try {
      // Stop all monitoring
      await this.stopMonitoring();
      
      // Kill all PM2 processes
      await this.runCommand("pm2", ["kill"]);
      
      // Wait for cleanup
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // Restart from ecosystem files
      const ecosystemFiles = ["ecosystem.pm2.cjs", "ecosystem.redundancy.cjs"];
      for (const file of ecosystemFiles) {
        if (fs.existsSync(file)) {
          await this.runCommand("pm2", ["start", file]);
          break;
        }
      }
      
      // Restart monitoring
      await this.startMonitoring();
      
      this.log("Emergency restart completed", "INFO");
    } catch (error) {
      this.log(`Emergency restart failed: ${error.message}`, "ERROR");
    }
  }

  async emergencyRedeploy() {
    this.log("🚨 EMERGENCY REDEPLOY INITIATED", "CRITICAL");
    
    try {
      // Redeploy Netlify functions
      const netlifySystem = this.redundancySystems.get("netlifyFunctions");
      if (netlifySystem) {
        await netlifySystem.deployFunctions();
      }
      
      // Regenerate manifests
      await this.runCommand("npm", ["run", "netlify:manifest"]);
      
      this.log("Emergency redeploy completed", "INFO");
    } catch (error) {
      this.log(`Emergency redeploy failed: ${error.message}`, "ERROR");
    }
  }

  async emergencyProcedures() {
    this.log("🚨 EMERGENCY PROCEDURES INITIATED", "CRITICAL");
    
    try {
      // Full system reset
      await this.emergencyRestart();
      await this.emergencyRedeploy();
      
      // Force health check
      await this.checkAllSystems();
      
      this.log("Emergency procedures completed", "INFO");
    } catch (error) {
      this.log(`Emergency procedures failed: ${error.message}`, "ERROR");
    }
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-60e4
  }

  async startMonitoring() {
    if (this.monitoring) {
<<<<<<< HEAD
      this.log("⚠️ Monitoring is already running");
      return;
    }

    this.log("🚀 Starting master redundancy orchestrator monitoring...");
    this.monitoring = true;

    // Start all systems
    await this.startAllSystems();

    // Initial health check
    await this.performMasterHealthCheck();

    // Start monitoring loop
    this.checkInterval = setInterval(async () => {
      try {
        await this.performMasterHealthCheck();
      } catch (error) {
        this.log(`❌ Error in master monitoring loop: ${error.message}`, "ERROR");
      }
    }, this.config.orchestration.masterCheckInterval);

    this.log(`✅ Master redundancy orchestrator monitoring started with ${this.config.orchestration.masterCheckInterval}ms intervals`);
  }

  async stopMonitoring() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    
    this.monitoring = false;
    this.log("🛑 Master redundancy orchestrator monitoring stopped");
  }

  async cleanup() {
    this.log("🧹 Cleaning up master redundancy orchestrator...");
    
    try {
      await this.stopMonitoring();
      await this.stopAllSystems();
      
      this.log("✅ Cleanup completed");
    } catch (error) {
      this.log(`❌ Error during cleanup: ${error.message}`, "ERROR");
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  getSystemStatus() {
    return Object.fromEntries(this.systemStatus);
  }

  getConfiguration() {
    return this.config;
  }
}

// Start the master redundancy orchestrator
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  
  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    orchestrator.log("🛑 Shutting down master redundancy orchestrator...");
    await orchestrator.cleanup();
    process.exit(0);
  });
  
  process.on('SIGTERM', async () => {
    orchestrator.log("🛑 Shutting down master redundancy orchestrator...");
    await orchestrator.cleanup();
    process.exit(0);
  });
  
  // Start monitoring
  orchestrator.startMonitoring();
}

module.exports = MasterRedundancyOrchestrator;
=======
      this.log("Monitoring already active", "WARN");
      return;
    }

    // Initialize systems first
    const initialized = await this.initializeRedundancySystems();
    if (!initialized) {
      this.log("Failed to initialize redundancy systems", "ERROR");
      return;
    }

    this.monitoring = true;
    this.log("Starting master redundancy orchestration monitoring", "INFO");

    const monitor = async () => {
      if (!this.monitoring) return;
      
      try {
        await this.checkAllSystems();
      } catch (error) {
        this.log(`Monitoring error: ${error.message}`, "ERROR");
      }

      this.checkInterval = setTimeout(monitor, this.config.checkInterval);
    };

    await monitor();
  }

  async stopMonitoring() {
    this.monitoring = false;
    if (this.checkInterval) {
      clearTimeout(this.checkInterval);
      this.checkInterval = null;
    }
    
    // Stop all system monitoring
    for (const [systemName, system] of this.redundancySystems) {
      try {
        if (system.stopMonitoring) {
          await system.stopMonitoring();
        }
      } catch (error) {
        this.log(`Error stopping ${systemName} monitoring: ${error.message}`, "ERROR");
      }
    }
    
    this.log("Stopped master redundancy orchestration monitoring", "INFO");
  }

  async generateComprehensiveReport() {
    const report = {
      timestamp: new Date().toISOString(),
      overallHealth: this.overallHealth,
      lastCheckTime: this.lastCheckTime,
      alertCount: this.alertCount,
      systems: {},
      recommendations: []
    };

    // Gather reports from all systems
    for (const [systemName, system] of this.redundancySystems) {
      try {
        if (system.generateHealthReport) {
          const systemReport = await system.generateHealthReport();
          report.systems[systemName] = systemReport;
        } else {
          report.systems[systemName] = this.systemStatus.get(systemName) || { status: "UNKNOWN" };
        }
      } catch (error) {
        report.systems[systemName] = { status: "ERROR", error: error.message };
      }
    }

    // Generate recommendations
    if (this.overallHealth === "CRITICAL") {
      report.recommendations.push("Immediate intervention required");
      report.recommendations.push("Check system resources and dependencies");
      report.recommendations.push("Consider emergency procedures");
    } else if (this.overallHealth === "WARNING") {
      report.recommendations.push("Monitor system closely");
      report.recommendations.push("Check logs for specific issues");
      report.recommendations.push("Consider preventive maintenance");
    } else if (this.overallHealth === "HEALTHY") {
      report.recommendations.push("All systems operating normally");
      report.recommendations.push("Continue regular monitoring");
    }

    return report;
  }

  async getSystemStatus() {
    return {
      monitoring: this.monitoring,
      overallHealth: this.overallHealth,
      lastCheckTime: this.lastCheckTime,
      alertCount: this.alertCount,
      systemStatus: Object.fromEntries(this.systemStatus),
      config: this.config
    };
  }
}

// CLI interface
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  const command = process.argv[2];

  switch (command) {
    case "start":
      orchestrator.startMonitoring();
      break;
    case "stop":
      orchestrator.stopMonitoring();
      break;
    case "check":
      orchestrator.checkAllSystems();
      break;
    case "restart":
      orchestrator.emergencyRestart();
      break;
    case "redeploy":
      orchestrator.emergencyRedeploy();
      break;
    case "emergency":
      orchestrator.emergencyProcedures();
      break;
    case "recovery":
      orchestrator.autoRecovery();
      break;
    case "status":
      orchestrator.getSystemStatus().then(status => {
        console.log(JSON.stringify(status, null, 2));
      });
      break;
    case "report":
      orchestrator.generateComprehensiveReport().then(report => {
        console.log(JSON.stringify(report, null, 2));
      });
      break;
    default:
      console.log("Usage: node master-redundancy-orchestrator.cjs [start|stop|check|restart|redeploy|emergency|recovery|status|report]");
      process.exit(1);
  }
}

module.exports = { MasterRedundancyOrchestrator };
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-60e4
