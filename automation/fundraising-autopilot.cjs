#!/usr/bin/env node
/* eslint-disable no-console */
const path = require('path');
const fs = require('fs-extra');

async function generateDeck(stage, operatorPrompt, openai) {
  const title = `Autopilot Deck (${stage})`;
  const sections = {
    vision: 'Autogenerated vision for stage ' + stage,
    traction: 'Autogenerated traction highlights',
    useOfFunds: 'Autogenerated use of funds breakdown',
    tokenomics: 'Autogenerated token utility overview',
    growthModel: 'Autogenerated multiverse growth model',
  };

  if (!openai) return { title, sections };

  try {
    const prompt = `Generate concise deck sections for stage ${stage}. Include: vision, traction, use of funds, token utility, growth model. Max 80 words each.\nOperator:\n${operatorPrompt}`;
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'system', content: 'You are a precise fundraising automation.' },
        { role: 'user', content: prompt },
      ],
      temperature: 0.3,
    });
    const text = completion.choices?.[0]?.message?.content || '';
    const extract = (key) => {
      const m = text.match(new RegExp(`${key}[:\-]\\s*([^\n]+)`, 'i'));
      return (m && m[1] || '').trim();
    };
    return {
      title,
      sections: {
        vision: extract('vision') || sections.vision,
        traction: extract('traction') || sections.traction,
        useOfFunds: extract('use of funds') || sections.useOfFunds,
        tokenomics: extract('token') || sections.tokenomics,
        growthModel: extract('growth') || sections.growthModel,
      },
    };
  } catch (e) {
    return { title, sections };
  }
}

async function main() {
  const repoRoot = process.cwd();
  const outDir = path.join(repoRoot, 'data', 'fundraising', 'generated');
  const reportsDir = path.join(repoRoot, 'docs', 'investor-reports');
  await fs.ensureDir(outDir);
  await fs.ensureDir(reportsDir);

  let openai = null;
  try {
    const OpenAI = require('openai');
    const apiKey = process.env.OPENAI_API_KEY || process.env.NEXT_PUBLIC_OPENAI_API_KEY;
    if (apiKey) openai = new OpenAI({ apiKey });
  } catch (_) {}

  const operator = 'Autopilot: refresh deck content and investor summary based on latest product and growth initiatives.';
  const stages = ['pre-seed', 'seed', 'series-a', 'public-token'];
  const date = new Date();
  const dateSlug = date.toISOString().slice(0, 10);

  const decks = [];
  for (const stage of stages) {
    const deck = await generateDeck(stage, operator, openai);
    decks.push({ stage, deck });
    const file = path.join(outDir, `${dateSlug}-${stage}.json`);
    await fs.writeJson(file, { generatedAt: date.toISOString(), stage, ...deck }, { spaces: 2 });
  }

  const reportMd = [
    `# Investor Report - ${dateSlug}`,
    '',
    `Automated summary generated by Fundraising Autopilot.`,
    '',
    ...decks.map(({ stage, deck }) => [
      `## ${stage.toUpperCase()}`,
      `- Vision: ${deck.sections.vision}`,
      `- Traction: ${deck.sections.traction}`,
      `- Use of Funds: ${deck.sections.useOfFunds}`,
      `- Tokenomics: ${deck.sections.tokenomics}`,
      `- Growth Model: ${deck.sections.growthModel}`,
      ''
    ].join('\n')),
  ].join('\n');

  const reportFile = path.join(reportsDir, `${dateSlug}.md`);
  await fs.writeFile(reportFile, reportMd, 'utf-8');

  const status = {
    ranAt: date.toISOString(),
    generatedDecks: decks.length,
    reportFile: path.relative(repoRoot, reportFile),
    outputs: decks.map(d => ({ stage: d.stage })),
  };
  const logsDir = path.join(repoRoot, 'automation_logs');
  await fs.ensureDir(logsDir);
  await fs.writeJson(path.join(logsDir, 'fundraising-autopilot-status.json'), status, { spaces: 2 });
  console.log('Fundraising Autopilot completed');
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});