#!/usr/bin/env node

'use strict';

const https = require('https');
const { URL } = require('url');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const LOG_DIR = path.join(__dirname, 'logs');
const LOG_FILE = path.join(LOG_DIR, 'enhanced-netlify-healer.log');
<<<<<<< HEAD

=======
>>>>>>> origin/cursor/build-nextjs-app-and-deploy-39fe
if (!fs.existsSync(LOG_DIR)) fs.mkdirSync(LOG_DIR, { recursive: true });

function log(message) {
  const line = `[${new Date().toISOString()}] ${message}`;
  console.log(line);
  fs.appendFileSync(LOG_FILE, line + '\n');
}

<<<<<<< HEAD
class EnhancedNetlifyHealer {
  constructor() {
    this.workspace = process.cwd();
    this.recoveryAttempts = [];
    this.fixesApplied = [];
  }
  
  async healBuildFailure() {
    log('ðŸš‘ Enhanced Netlify auto-healing initiated...');
    
    try {
      // First, try to fix the issue locally
      await this.localBuildRecovery();
      
      // If successful, trigger Netlify rebuild
      await this.triggerNetlifyRebuild();
      
    } catch (error) {
      log(`âŒ Local recovery failed: ${error.message}`);
      
      // Fallback to your existing auto-healer
      await this.fallbackToAutoHealer();
    }
  }
  
  async localBuildRecovery() {
    log('ðŸ”§ Attempting local build recovery...');
    
    try {
      // Run the build failure recovery automation
      log('ðŸ“‹ Running build failure recovery...');
      execSync('npm run build:recovery', { 
        stdio: 'inherit', 
        cwd: this.workspace,
        timeout: 120000 // 2 minute timeout
      });
      
      // Verify the fix works
      log('ðŸ” Verifying build health after recovery...');
      execSync('npm run build:health-check', { 
        stdio: 'inherit', 
        cwd: this.workspace,
        timeout: 60000 // 1 minute timeout
      });
      
      log('âœ… Local build recovery successful');
      return true;
      
    } catch (error) {
      log(`âŒ Local build recovery failed: ${error.message}`);
      throw error;
    }
  }
  
  async triggerNetlifyRebuild() {
    log('ðŸš€ Triggering Netlify rebuild...');
    
    try {
      // Try to trigger via build hook first
      const buildHook = process.env.NETLIFY_BUILD_HOOK;
      if (buildHook) {
        log('ðŸ“¡ Using build hook to trigger rebuild...');
        await this.triggerBuildHook(buildHook);
        return 'build_hook';
      }
      
      // Fallback to API if no build hook
      log('ðŸ“¡ Using Netlify API to trigger rebuild...');
      await this.triggerApiBuild();
      return 'api_build';
      
    } catch (error) {
      log(`âŒ Failed to trigger Netlify rebuild: ${error.message}`);
      throw error;
    }
  }
  
  async triggerBuildHook(buildHook) {
    return new Promise((resolve, reject) => {
      const url = new URL(buildHook);
      const options = {
        method: 'POST',
        hostname: url.hostname,
        path: url.pathname + (url.search || ''),
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'Enhanced-Netlify-Healer/1.0'
        }
      };
      
      const req = https.request(options, (res) => {
        const status = res.statusCode || 0;
        if (status >= 200 && status < 300) {
          log(`âœ… Build hook triggered successfully (HTTP ${status})`);
          resolve();
        } else {
          reject(new Error(`Build hook failed with HTTP ${status}`));
        }
      });
      
      req.on('error', reject);
      req.end();
    });
  }
  
  async triggerApiBuild() {
    const apiToken = process.env.NETLIFY_AUTH_TOKEN;
    const siteId = process.env.NETLIFY_SITE_ID;
    
    if (!apiToken || !siteId) {
      throw new Error('Missing NETLIFY_AUTH_TOKEN or NETLIFY_SITE_ID');
    }
    
    return new Promise((resolve, reject) => {
      const options = {
        method: 'POST',
        hostname: 'api.netlify.com',
        path: `/api/v1/sites/${encodeURIComponent(siteId)}/builds`,
        headers: {
          'Authorization': `Bearer ${apiToken}`,
          'Content-Type': 'application/json',
          'User-Agent': 'Enhanced-Netlify-Healer/1.0'
        }
      };
      
      const req = https.request(options, (res) => {
        const status = res.statusCode || 0;
        if (status >= 200 && status < 300) {
          log(`âœ… API build triggered successfully (HTTP ${status})`);
          resolve();
        } else {
          reject(new Error(`API build failed with HTTP ${status}`));
        }
      });
      
      req.on('error', reject);
      req.write(JSON.stringify({}));
      req.end();
    });
  }
  
  async fallbackToAutoHealer() {
    log('ðŸ”„ Falling back to standard Netlify auto-healer...');
    
    try {
      // Import and run the existing auto-healer
      const { main: autoHealerMain } = require('./netlify-auto-healer.cjs');
      await autoHealerMain();
      
    } catch (error) {
      log(`âŒ Fallback auto-healer also failed: ${error.message}`);
      throw error;
    }
  }
  
  async analyzeBuildFailure(buildLog) {
    log('ðŸ” Analyzing build failure for intelligent recovery...');
    
    const patterns = {
      'page without a React Component': 'MISSING_COMPONENT',
      'export default': 'EXPORT_ISSUE',
      'syntax error': 'SYNTAX_ERROR',
      'module not found': 'DEPENDENCY_ISSUE',
      'Cannot find module': 'MODULE_ISSUE',
      'Unexpected token': 'SYNTAX_ERROR',
      'Parsing error': 'PARSING_ERROR',
      'Deploy directory.*does not exist': 'BUILD_ARTIFACT_MISSING'
    };
    
    const detectedIssues = [];
    
    for (const [pattern, issueType] of Object.entries(patterns)) {
      if (buildLog.includes(pattern)) {
        detectedIssues.push({
          pattern,
          type: issueType,
          severity: this.getIssueSeverity(issueType)
        });
      }
    }
    
    return {
      hasIssues: detectedIssues.length > 0,
      issues: detectedIssues,
      recommendations: this.generateRecommendations(detectedIssues)
    };
  }
  
  getIssueSeverity(issueType) {
    const severityMap = {
      'MISSING_COMPONENT': 'CRITICAL',
      'EXPORT_ISSUE': 'CRITICAL',
      'SYNTAX_ERROR': 'HIGH',
      'PARSING_ERROR': 'HIGH',
      'DEPENDENCY_ISSUE': 'MEDIUM',
      'MODULE_ISSUE': 'MEDIUM',
      'BUILD_ARTIFACT_MISSING': 'LOW'
    };
    
    return severityMap[issueType] || 'UNKNOWN';
  }
  
  generateRecommendations(issues) {
    const recommendations = [];
    
    issues.forEach(issue => {
      switch (issue.type) {
        case 'MISSING_COMPONENT':
          recommendations.push('Run "npm run build:validate" to identify and fix page structure issues');
          recommendations.push('Use "npm run build:recovery" to automatically fix common component issues');
          break;
        case 'EXPORT_ISSUE':
          recommendations.push('Check all page files for proper export default statements');
          recommendations.push('Ensure all React components are properly exported');
          break;
        case 'SYNTAX_ERROR':
        case 'PARSING_ERROR':
          recommendations.push('Review the build logs for specific syntax errors');
          recommendations.push('Check for missing brackets, semicolons, or invalid JSX');
          break;
        case 'DEPENDENCY_ISSUE':
        case 'MODULE_ISSUE':
          recommendations.push('Run "npm install" to ensure all dependencies are installed');
          recommendations.push('Check package.json for missing or conflicting dependencies');
          break;
        case 'BUILD_ARTIFACT_MISSING':
          recommendations.push('Verify the build process completes successfully');
          recommendations.push('Check that the output directory is properly configured');
          break;
      }
    });
    
    return recommendations;
  }
  
  async generateRecoveryReport() {
    const report = {
      summary: {
        totalRecoveryAttempts: this.recoveryAttempts.length,
        successfulRecoveries: this.fixesApplied.length,
        timestamp: new Date().toISOString()
      },
      recoveryAttempts: this.recoveryAttempts,
      fixesApplied: this.fixesApplied,
      recommendations: this.generateGeneralRecommendations()
    };
    
    return report;
  }
  
  generateGeneralRecommendations() {
    const recommendations = [
      'Monitor build health with "npm run build:monitor"',
      'Run pre-build checks with "npm run build:health-check"',
      'Use smart build with "npm run build:smart" for automatic issue detection',
      'Set up continuous monitoring to catch issues early',
      'Review build reports in public/reports/ for detailed analysis'
    ];
    
    return recommendations;
  }
  
  saveReport(report) {
    const outDir = path.join(this.workspace, 'public', 'reports', 'netlify-healing');
    if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
    
    const outJson = path.join(outDir, 'latest.json');
    const outHtml = path.join(outDir, 'index.html');
    
    // Save JSON report
    fs.writeFileSync(outJson, JSON.stringify(report, null, 2));
    
    // Generate HTML report
    const html = this.generateHtmlReport(report);
    fs.writeFileSync(outHtml, html);
    
    log(`ðŸ“Š Enhanced Netlify healing report saved to ${outJson} and ${outHtml}`);
  }
  
  generateHtmlReport(report) {
    const { summary, recoveryAttempts, fixesApplied, recommendations } = report;
    
    const html = [];
    html.push('<!doctype html>');
    html.push('<meta charset="utf-8"/>');
    html.push('<title>Enhanced Netlify Healing Report</title>');
    html.push('<style>');
    html.push('body{font-family:ui-sans-serif,system-ui;padding:20px;background:#0b1020;color:#fff}');
    html.push('.card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:12px;margin:8px 0}');
    html.push('code{background:rgba(0,0,0,.4);padding:2px 4px;border-radius:6px}');
    html.push('.status{display:inline-block;margin:2px;padding:2px 8px;border-radius:999px;font-size:12px}');
    html.push('.success{background:rgba(16,185,129,.2);border:1px solid #10b981;color:#10b981}');
    html.push('.info{background:rgba(59,130,246,.2);border:1px solid #3b82f6;color:#3b82f6}');
    html.push('</style>');
    
    html.push(`<h1>Enhanced Netlify Healing Report</h1>`);
    html.push(`<p>Generated ${new Date().toLocaleString()}</p>`);
    
    // Summary
    html.push(`<div class="card">`);
    html.push(`<h2>Healing Summary</h2>`);
    html.push(`<p><strong>Total Recovery Attempts:</strong> ${summary.totalRecoveryAttempts}</p>`);
    html.push(`<p><strong>Successful Recoveries:</strong> ${summary.successfulRecoveries}</p>`);
    html.push(`</div>`);
    
    // Fixes Applied
    if (fixesApplied.length > 0) {
      html.push(`<div class="card">`);
      html.push(`<h2>Fixes Applied</h2>`);
      fixesApplied.forEach(fix => {
        html.push(`<div style="margin:8px 0;padding:8px;border-radius:8px;background:rgba(255,255,255,.03)">`);
        html.push(`<strong>${fix.pattern}</strong>`);
        html.push(`<span class="status success">${fix.fix}</span>`);
        html.push(`<div style="margin-top:4px;color:#3b82f6"><code>${fix.file}</code></div>`);
        html.push(`</div>`);
      });
      html.push(`</div>`);
    }
    
    // Recommendations
    if (recommendations.length > 0) {
      html.push(`<div class="card">`);
      html.push(`<h2>Recommendations</h2>`);
      html.push(`<ul>`);
      recommendations.forEach(rec => {
        html.push(`<li>${rec}</li>`);
      });
      html.push(`</ul>`);
      html.push(`</div>`);
    }
    
    return html.join('\n');
=======
function loadEnvFromFile(filePath) {
  try {
    if (!fs.existsSync(filePath)) return {};
    const content = fs.readFileSync(filePath, 'utf8');
    return content.split(/\r?\n/).reduce((acc, line) => {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) return acc;
      const eqIdx = trimmed.indexOf('=');
      if (eqIdx === -1) return acc;
      const key = trimmed.slice(0, eqIdx).trim();
      const value = trimmed.slice(eqIdx + 1).trim().replace(/^"|"$/g, '');
      if (key) acc[key] = value;
      return acc;
    }, {});
  } catch {
    return {};
  }
}

async function requestJSON(method, urlString, headers, bodyObj) {
  const urlObj = new URL(urlString);
  const body = bodyObj ? JSON.stringify(bodyObj) : undefined;
  const options = {
    method,
    hostname: urlObj.hostname,
    path: urlObj.pathname + (urlObj.search || ''),
    headers: Object.assign({}, headers || {}, body ? { 'content-type': 'application/json', 'content-length': Buffer.byteLength(body) } : {}),
  };
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let data = '';
      res.setEncoding('utf8');
      res.on('data', (chunk) => (data += chunk));
      res.on('end', () => {
        const statusCode = res.statusCode || 0;
        if (statusCode < 200 || statusCode >= 300) {
          return reject(new Error(`HTTP ${statusCode}: ${data.slice(0, 200)}`));
        }
        try {
          resolve(data ? JSON.parse(data) : {});
        } catch (e) {
          resolve({ raw: data });
        }
      });
    });
    req.on('error', reject);
    if (body) req.write(body);
    req.end();
  });
}

async function post(urlString, headers) {
  const urlObj = new URL(urlString);
  const options = { method: 'POST', hostname: urlObj.hostname, path: urlObj.pathname + (urlObj.search || ''), headers: headers || {} };
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      const status = res.statusCode || 0;
      if (status >= 200 && status < 300) resolve(status);
      else reject(new Error(`HTTP ${status}`));
    });
    req.on('error', reject);
    req.end();
  });
}

async function resolveSiteId(apiToken, siteId, siteName) {
  if (siteId && siteId.trim()) return siteId.trim();
  if (!siteName || !siteName.trim()) return '';
  const headers = { Authorization: `Bearer ${apiToken}` };
  const sites = await requestJSON('GET', `https://api.netlify.com/api/v1/sites?name=${encodeURIComponent(siteName.trim())}`, headers);
  if (!Array.isArray(sites) || sites.length === 0) return '';
  const exact = sites.find((s) => s.name === siteName.trim() || s.custom_domain === siteName.trim());
  const chosen = exact || sites[0];
  return chosen && chosen.id ? chosen.id : '';
}

async function fetchDeploys(apiToken, siteId, perPage = 10) {
  const headers = { Authorization: `Bearer ${apiToken}` };
  const list = await requestJSON('GET', `https://api.netlify.com/api/v1/sites/${encodeURIComponent(siteId)}/deploys?per_page=${perPage}`, headers);
  return Array.isArray(list) ? list : [];
}

async function fetchDeployLogs(apiToken, deployId) {
  const headers = { Authorization: `Bearer ${apiToken}` };
  try {
    const logs = await requestJSON('GET', `https://api.netlify.com/api/v1/deploys/${encodeURIComponent(deployId)}/log`, headers);
    return logs;
  } catch (error) {
    log(`âš ï¸ Could not fetch deploy logs: ${error.message}`);
    return null;
  }
}

function analyzeBuildFailure(logs) {
  if (!logs || !logs.raw) return { type: 'unknown', confidence: 0, suggestedFix: 'Unknown build failure' };
  
  const logContent = logs.raw.toLowerCase();
  const analysis = {
    type: 'unknown',
    confidence: 0,
    suggestedFix: 'Unknown build failure',
    details: []
  };
  
  // React component export issues
  if (logContent.includes('page without a react component as default export') || 
      logContent.includes('page-without-valid-component')) {
    analysis.type = 'react_component_export';
    analysis.confidence = 95;
    analysis.suggestedFix = 'Fix React component exports in pages directory';
    analysis.details.push('Missing export default statements in page files');
    analysis.details.push('Files may contain only JSX without proper component structure');
  }
  
  // Missing out directory
  if (logContent.includes('deploy directory \'out\' does not exist') ||
      logContent.includes('build script returned non-zero exit code')) {
    analysis.type = 'missing_out_directory';
    analysis.confidence = 90;
    analysis.suggestedFix = 'Build script failed to create out directory';
    analysis.details.push('Export script may have failed');
    analysis.details.push('Check for React component structure issues');
  }
  
  // Next.js build failures
  if (logContent.includes('build optimization failed') ||
      logContent.includes('compilation failed')) {
    analysis.type = 'nextjs_build_failure';
    analysis.confidence = 85;
    analysis.suggestedFix = 'Fix Next.js build errors';
    analysis.details.push('Check for syntax errors in page files');
    analysis.details.push('Verify all imports and exports');
  }
  
  // Dependency issues
  if (logContent.includes('module not found') ||
      logContent.includes('cannot resolve module')) {
    analysis.type = 'dependency_issue';
    analysis.confidence = 80;
    analysis.suggestedFix = 'Fix dependency resolution issues';
    analysis.details.push('Check package.json and node_modules');
    analysis.details.push('Run npm install to resolve dependencies');
  }
  
  // Environment configuration issues
  if (logContent.includes('environment variable') ||
      logContent.includes('configuration error')) {
    analysis.type = 'environment_config';
    analysis.confidence = 75;
    analysis.suggestedFix = 'Fix environment configuration';
    analysis.details.push('Check Netlify environment variables');
    analysis.details.push('Verify build configuration');
  }
  
  return analysis;
}

async function attemptAutoFix(analysis, apiToken, siteId) {
  log(`ðŸ”§ Attempting auto-fix for: ${analysis.type}`);
  
  try {
    switch (analysis.type) {
      case 'react_component_export':
        return await fixReactComponentExports();
      
      case 'missing_out_directory':
        return await fixBuildScript();
      
      case 'nextjs_build_failure':
        return await fixNextJSBuild();
      
      case 'dependency_issue':
        return await fixDependencies();
      
      default:
        log(`âš ï¸ No auto-fix available for: ${analysis.type}`);
        return false;
    }
  } catch (error) {
    log(`âŒ Auto-fix failed: ${error.message}`);
    return false;
  }
}

async function fixReactComponentExports() {
  log('ðŸ”§ Running React component validation...');
  try {
    const validatorPath = path.join(__dirname, 'react-component-validator.cjs');
    if (fs.existsSync(validatorPath)) {
      execSync(`node ${validatorPath}`, { stdio: 'pipe' });
      log('âœ… React component validation completed');
      return true;
    } else {
      log('âš ï¸ React component validator not found');
      return false;
    }
  } catch (error) {
    log(`âŒ React component validation failed: ${error.message}`);
    return false;
  }
}

async function fixBuildScript() {
  log('ðŸ”§ Checking build script configuration...');
  try {
    const preflightPath = path.join(__dirname, 'build-preflight-checker.cjs');
    if (fs.existsSync(preflightPath)) {
      execSync(`node ${preflightPath}`, { stdio: 'pipe' });
      log('âœ… Build preflight check completed');
      return true;
    } else {
      log('âš ï¸ Build preflight checker not found');
      return false;
    }
  } catch (error) {
    log(`âŒ Build preflight check failed: ${error.message}`);
    return false;
  }
}

async function fixNextJSBuild() {
  log('ðŸ”§ Attempting to fix Next.js build issues...');
  try {
    // Clean build artifacts
    execSync('rm -rf .next out', { stdio: 'pipe' });
    log('âœ… Cleaned build artifacts');
    
    // Run preflight check
    const preflightPath = path.join(__dirname, 'build-preflight-checker.cjs');
    if (fs.existsSync(preflightPath)) {
      execSync(`node ${preflightPath}`, { stdio: 'pipe' });
      log('âœ… Preflight check after cleanup');
    }
    
    return true;
  } catch (error) {
    log(`âŒ Next.js build fix failed: ${error.message}`);
    return false;
  }
}

async function fixDependencies() {
  log('ðŸ”§ Attempting to fix dependency issues...');
  try {
    // Clean install
    execSync('rm -rf node_modules package-lock.json', { stdio: 'pipe' });
    execSync('npm install', { stdio: 'pipe' });
    log('âœ… Dependencies reinstalled');
    return true;
  } catch (error) {
    log(`âŒ Dependency fix failed: ${error.message}`);
    return false;
  }
}

async function restoreDeploy(apiToken, deployId) {
  const headers = { Authorization: `Bearer ${apiToken}` };
  try {
    await requestJSON('POST', `https://api.netlify.com/api/v1/deploys/${encodeURIComponent(deployId)}/restore`, headers);
    log(`â™»ï¸ Restored deploy ${deployId}`);
    return true;
  } catch (error) {
    log(`âŒ Failed to restore deploy: ${error.message}`);
    return false;
  }
}

async function triggerBuild(apiToken, siteId, buildHook) {
  if (buildHook && buildHook.trim()) {
    try {
      await post(buildHook.trim());
      log('ðŸš€ Triggered build via build hook');
      return 'build_hook';
    } catch (error) {
      log(`âš ï¸ Build hook failed: ${error.message}`);
    }
  }
  
  try {
    const headers = { Authorization: `Bearer ${apiToken}` };
    await requestJSON('POST', `https://api.netlify.com/api/v1/sites/${encodeURIComponent(siteId)}/builds`, headers, {});
    log('ðŸš€ Triggered build via API');
    return 'api_build';
  } catch (error) {
    log(`âŒ API build trigger failed: ${error.message}`);
    throw error;
>>>>>>> origin/cursor/build-nextjs-app-and-deploy-39fe
  }
}

async function main() {
<<<<<<< HEAD
  const healer = new EnhancedNetlifyHealer();
  
  try {
    await healer.healBuildFailure();
    
    const report = await healer.generateRecoveryReport();
    healer.saveReport(report);
    
    log('âœ… Enhanced Netlify healing completed successfully');
    
  } catch (error) {
    log(`âŒ Enhanced Netlify healing failed: ${error.message}`);
=======
  const localEnv = loadEnvFromFile(path.join(__dirname, '..', '.env.netlify'));
  const env = { ...localEnv, ...process.env };

  const apiToken = env.NETLIFY_AUTH_TOKEN || '';
  const siteIdEnv = env.NETLIFY_SITE_ID || '';
  const siteNameEnv = env.NETLIFY_SITE_NAME || '';
  const buildHook = env.NETLIFY_BUILD_HOOK || '';

  if (!apiToken) {
    log('âš ï¸ NETLIFY_AUTH_TOKEN not set. Skipping enhanced auto-heal.');
    process.exit(0);
  }

  try {
    const siteId = await resolveSiteId(apiToken, siteIdEnv, siteNameEnv);
    if (!siteId) {
      log('âŒ Unable to resolve Netlify site ID.');
      process.exit(1);
    }

    log(`ðŸ” Analyzing deploys for site: ${siteId}`);
    const deploys = await fetchDeploys(apiToken, siteId, 5);
    
    if (deploys.length === 0) {
      log('â„¹ï¸ No deploy history found. Triggering build.');
      const mode = await triggerBuild(apiToken, siteId, buildHook);
      log(`ðŸš€ Triggered new build via ${mode}.`);
      process.exit(0);
    }

    const latest = deploys[0];
    const state = latest.state || 'unknown';
    log(`ðŸ“¦ Latest deploy ${latest.id} â†’ state=${state}`);

    if (state === 'ready' || state === 'building' || state === 'processing' || state === 'enqueued') {
      log('âœ… No heal action required.');
      process.exit(0);
    }

    // Analyze the failed deploy
    log('ðŸ” Analyzing build failure...');
    const logs = await fetchDeployLogs(apiToken, latest.id);
    const analysis = analyzeBuildFailure(logs);
    
    log(`ðŸ“Š Failure analysis:`);
    log(`   Type: ${analysis.type}`);
    log(`   Confidence: ${analysis.confidence}%`);
    log(`   Suggested fix: ${analysis.suggestedFix}`);
    if (analysis.details.length > 0) {
      analysis.details.forEach(detail => log(`   Detail: ${detail}`));
    }

    // Attempt auto-fix if confidence is high enough
    if (analysis.confidence >= 80) {
      log('ðŸ”§ High confidence failure detected. Attempting auto-fix...');
      const fixSuccess = await attemptAutoFix(analysis, apiToken, siteId);
      
      if (fixSuccess) {
        log('âœ… Auto-fix successful. Triggering rebuild...');
        const mode = await triggerBuild(apiToken, siteId, buildHook);
        log(`ðŸš€ Rebuild triggered via ${mode}.`);
        process.exit(0);
      }
    }

    // Fallback: attempt restore to last good deploy
    const lastGood = deploys.find((d) => d.state === 'ready');
    if (lastGood) {
      try {
        await restoreDeploy(apiToken, lastGood.id);
        log(`â™»ï¸ Restored last healthy deploy ${lastGood.id}.`);
        process.exit(0);
      } catch (e) {
        log(`âš ï¸ Restore failed: ${e.message}`);
      }
    }

    // Final fallback: trigger a rebuild
    try {
      const mode = await triggerBuild(apiToken, siteId, buildHook);
      log(`ðŸš€ Triggered rebuild via ${mode}.`);
      process.exit(0);
    } catch (e) {
      log(`âŒ Failed to trigger rebuild: ${e.message}`);
      process.exit(1);
    }
  } catch (err) {
    log(`âŒ Enhanced auto-heal error: ${err.message}`);
>>>>>>> origin/cursor/build-nextjs-app-and-deploy-39fe
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = {
<<<<<<< HEAD
  EnhancedNetlifyHealer
=======
  analyzeBuildFailure,
  attemptAutoFix,
  fetchDeployLogs
>>>>>>> origin/cursor/build-nextjs-app-and-deploy-39fe
};