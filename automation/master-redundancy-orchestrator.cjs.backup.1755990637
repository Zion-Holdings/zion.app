#!/usr/bin/env node
"use strict";

<<<<<<< HEAD
const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");

// Import the enhanced redundancy systems
const ComprehensiveRedundancySystem = require('./comprehensive-redundancy-system.cjs');
const EnhancedPM2Redundancy = require('./enhanced-pm2-redundancy.cjs');
const EnhancedGitHubActionsRedundancy = require('./enhanced-github-actions-redundancy.cjs');
const EnhancedNetlifyFunctionsRedundancy = require('./enhanced-netlify-functions-redundancy.cjs');

class MasterRedundancyOrchestrator {
  constructor() {
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "master-redundancy-orchestrator.log");
    this.ensureLogDir();
    
    this.config = {
      systems: {
        comprehensive: true,
        pm2: true,
        githubActions: true,
        netlifyFunctions: true
      },
      orchestration: {
        healthCheckInterval: 300000, // 5 minutes
        systemStartupDelay: 10000, // 10 seconds between system starts
        enableCrossSystemRecovery: true,
        enableMetricsAggregation: true,
        enableAlerting: true
      },
      monitoring: {
        enableRealTimeMonitoring: true,
        enableHistoricalTracking: true,
        enablePerformanceMetrics: true,
        logRetentionDays: 30
      }
    };
    
    this.systems = {};
    this.monitoring = false;
    this.orchestrationInterval = null;
    this.systemStatus = new Map();
    this.performanceMetrics = new Map();
    this.startupTime = null;
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
=======
const { spawnSync, execSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

class MasterRedundancyOrchestrator {
  constructor() {
    this.config = {
      // PM2 Automation Coverage
      pm2: {
        ecosystemFiles: [
          "ecosystem.pm2.cjs",
          "ecosystem.redundancy.cjs"
        ],
        processes: [
          "zion-auto-sync",
          "zion-auto-sync-cron",
          "redundancy-automation-system",
          "redundancy-health-monitor",
          "redundancy-git-sync",
          "redundancy-build-monitor"
        ],
        healthCheckInterval: 30000,
        maxRestartAttempts: 5,
        restartDelay: 5000,
        backupProcesses: [
          "automation:pm2",
          "automation:pm2:restart",
          "automation:pm2:status"
        ]
      },
      
      // GitHub Actions Coverage
      githubActions: {
        workflows: [
          ".github/workflows/marketing-sync.yml",
          ".github/workflows/sync-health.yml"
        ],
        healthCheckInterval: 60000,
        maxFailureThreshold: 3,
        backupTriggers: [
          "gh:trigger",
          "gh:auto-heal"
        ],
        scheduledTasks: [
          "marketing-sync",
          "sync-health"
        ]
      },
      
      // Netlify Functions Coverage
      netlifyFunctions: {
        manifestFile: "netlify/functions/functions-manifest.json",
        healthCheckInterval: 120000,
        maxFailureThreshold: 2,
        criticalFunctions: [
          "netlify-auto-healer-runner",
          "continuous-orchestrator",
          "automation-matrix",
          "maintenance-scheduler"
        ],
        backupTriggers: [
          "netlify:trigger",
          "netlify:manifest"
        ]
      },
      
      // Build System Coverage
      build: {
        commands: [
          "npm run build",
          "npm run build:smart",
          "npm run build:orchestrator",
          "npm run build:recovery"
        ],
        healthCheckInterval: 300000, // 5 minutes
        maxBuildFailures: 3,
        backupCommands: [
          "npm run build:heal",
          "npm run build:auto-fix"
        ]
      },
      
      // Package Scripts Coverage
      packageScripts: {
        critical: [
          "automation:all",
          "redundancy:start",
          "git:sync",
          "content:fix",
          "security:scan"
        ],
        backup: [
          "automation:status",
          "redundancy:health",
          "git:health",
          "healing:scan"
        ]
      },
      
      // Logging Configuration
      logging: {
        logDir: "automation/logs",
        maxLogSize: 10 * 1024 * 1024, // 10MB
        maxLogFiles: 30,
        logLevels: ["INFO", "WARN", "ERROR", "DEBUG"]
      }
    };
    
    this.ensureLogDirectory();
    this.initializeMonitoring();
    this.startHealthChecks();
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.config.logging.logDir)) {
      fs.mkdirSync(this.config.logging.logDir, { recursive: true });
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
<<<<<<< HEAD
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
=======
    const logEntry = `[${timestamp}] [${level}] ${message}`;
    console.log(logEntry);
    
    const logFile = path.join(this.config.logging.logDir, `master-redundancy-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logEntry + "\n");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
<<<<<<< HEAD
        cwd: this.workspace,
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 10,
        timeout: options.timeout || 30000,
=======
        cwd: process.cwd(),
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 20,
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  async initializeSystems() {
    this.log("ðŸš€ Initializing master redundancy orchestrator...");
    this.startupTime = new Date();
    
    try {
      // Initialize comprehensive redundancy system
      if (this.config.systems.comprehensive) {
        this.log("ðŸ”§ Initializing comprehensive redundancy system...");
        this.systems.comprehensive = new ComprehensiveRedundancySystem();
        this.systemStatus.set('comprehensive', { status: 'initializing', timestamp: new Date() });
      }

      // Initialize enhanced PM2 redundancy system
      if (this.config.systems.pm2) {
        this.log("ðŸ”§ Initializing enhanced PM2 redundancy system...");
        this.systems.pm2 = new EnhancedPM2Redundancy();
        this.systemStatus.set('pm2', { status: 'initializing', timestamp: new Date() });
      }

      // Initialize enhanced GitHub Actions redundancy system
      if (this.config.systems.githubActions) {
        this.log("ðŸ”§ Initializing enhanced GitHub Actions redundancy system...");
        this.systems.githubActions = new EnhancedGitHubActionsRedundancy();
        this.systemStatus.set('githubActions', { status: 'initializing', timestamp: new Date() });
      }

      // Initialize enhanced Netlify functions redundancy system
      if (this.config.systems.netlifyFunctions) {
        this.log("ðŸ”§ Initializing enhanced Netlify functions redundancy system...");
        this.systems.netlifyFunctions = new EnhancedNetlifyFunctionsRedundancy();
        this.systemStatus.set('netlifyFunctions', { status: 'initializing', timestamp: new Date() });
      }

      this.log("âœ… All redundancy systems initialized successfully");
      return true;
    } catch (error) {
      this.log(`âŒ Failed to initialize systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async startSystems() {
    this.log("ðŸš€ Starting all redundancy systems...");
    
    try {
      // Start systems with staggered delays to prevent resource conflicts
      const systemStartPromises = [];
      
      if (this.systems.comprehensive) {
        systemStartPromises.push(
          this.startSystem('comprehensive', async () => {
            // Comprehensive system starts automatically
            this.systemStatus.set('comprehensive', { status: 'running', timestamp: new Date() });
          })
        );
      }

      if (this.systems.pm2) {
        systemStartPromises.push(
          this.startSystem('pm2', async () => {
            await this.systems.pm2.startMonitoring();
            this.systemStatus.set('pm2', { status: 'running', timestamp: new Date() });
          })
        );
      }

      if (this.systems.githubActions) {
        systemStartPromises.push(
          this.startSystem('githubActions', async () => {
            await this.systems.githubActions.startMonitoring();
            this.systemStatus.set('githubActions', { status: 'running', timestamp: new Date() });
          })
        );
      }

      if (this.systems.netlifyFunctions) {
        systemStartPromises.push(
          this.startSystem('netlifyFunctions', async () => {
            await this.systems.netlifyFunctions.startMonitoring();
            this.systemStatus.set('netlifyFunctions', { status: 'running', timestamp: new Date() });
          })
        );
      }

      // Execute all system starts with delays
      for (let i = 0; i < systemStartPromises.length; i++) {
        await systemStartPromises[i];
        if (i < systemStartPromises.length - 1) {
          await this.delay(this.config.orchestration.systemStartupDelay);
        }
      }

      this.log("âœ… All redundancy systems started successfully");
      return true;
    } catch (error) {
      this.log(`âŒ Failed to start systems: ${error.message}`, "ERROR");
=======
  async checkPM2Health() {
    this.log("Checking PM2 process health...");
    
    try {
      const statusResult = await this.runCommand("pm2", ["status", "--no-daemon"]);
      
      if (statusResult.status !== 0) {
        this.log("PM2 status check failed, attempting to restart PM2", "WARN");
        await this.runCommand("pm2", ["kill"]);
        await this.runCommand("pm2", ["start", this.config.pm2.ecosystemFiles[0]]);
        return false;
      }

      const processes = this.config.pm2.processes;
      let allHealthy = true;

      for (const processName of processes) {
        const processStatus = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
        
        if (processStatus.status !== 0) {
          this.log(`PM2 process ${processName} not found, restarting...`, "WARN");
          await this.runCommand("pm2", ["restart", processName]);
          allHealthy = false;
        } else {
          // Check if process is actually running
          const statusOutput = processStatus.stdout;
          if (statusOutput.includes("errored") || statusOutput.includes("stopped")) {
            this.log(`PM2 process ${processName} is not running, restarting...`, "WARN");
            await this.runCommand("pm2", ["restart", processName]);
            allHealthy = false;
          }
        }
      }

      if (allHealthy) {
        this.log("All PM2 processes are healthy");
      }

      return allHealthy;
    } catch (error) {
      this.log(`PM2 health check error: ${error.message}`, "ERROR");
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
      return false;
    }
  }

<<<<<<< HEAD
  async startSystem(systemName, startFunction) {
    try {
      this.log(`ðŸš€ Starting ${systemName} system...`);
      await startFunction();
      this.log(`âœ… ${systemName} system started successfully`);
    } catch (error) {
      this.log(`âŒ Failed to start ${systemName} system: ${error.message}`, "ERROR");
      this.systemStatus.set(systemName, { status: 'failed', timestamp: new Date(), error: error.message });
      throw error;
    }
  }

  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async performOrchestratedHealthCheck() {
    this.log("ðŸŽ¯ Performing orchestrated health check across all systems...");
    
    const results = {
      timestamp: new Date().toISOString(),
      systems: {},
      summary: {
        total: 0,
        healthy: 0,
        unhealthy: 0,
        failed: 0
      },
      crossSystemIssues: [],
      recommendations: []
    };

    // Check each system's health
    for (const [systemName, system] of Object.entries(this.systems)) {
      try {
        this.log(`ðŸ” Checking health of ${systemName} system...`);
        
        let systemHealth;
        if (systemName === 'comprehensive') {
          systemHealth = await system.performComprehensiveHealthCheck();
        } else if (systemName === 'pm2') {
          systemHealth = await system.performComprehensiveHealthCheck();
        } else if (systemName === 'githubActions') {
          systemHealth = await system.performComprehensiveHealthCheck();
        } else if (systemName === 'netlifyFunctions') {
          systemHealth = await system.performComprehensiveHealthCheck();
        }

        results.systems[systemName] = {
          status: 'healthy',
          health: systemHealth,
          timestamp: new Date().toISOString()
        };

        results.summary.total++;
        results.summary.healthy++;
        
        this.systemStatus.set(systemName, { status: 'healthy', timestamp: new Date() });
        this.log(`âœ… ${systemName} system is healthy`);
      } catch (error) {
        this.log(`âŒ ${systemName} system health check failed: ${error.message}`, "ERROR");
        
        results.systems[systemName] = {
          status: 'unhealthy',
          error: error.message,
          timestamp: new Date().toISOString()
        };

        results.summary.total++;
        results.summary.unhealthy++;
        
        this.systemStatus.set(systemName, { status: 'unhealthy', timestamp: new Date(), error: error.message });
      }
    }

    // Analyze cross-system dependencies and issues
    results.crossSystemIssues = this.analyzeCrossSystemIssues(results);
    
    // Generate recommendations
    results.recommendations = this.generateRecommendations(results);

    // Generate and log orchestrated health report
    const healthReport = this.generateOrchestratedHealthReport(results);
    this.log(healthReport);

    // Save orchestrated health report
    this.saveOrchestratedHealthReport(results);

    // Update performance metrics
    this.updatePerformanceMetrics(results);
=======
  async checkGitHubActionsHealth() {
    this.log("Checking GitHub Actions health...");
    
    try {
      // Check if workflow files exist and are valid
      for (const workflow of this.config.githubActions.workflows) {
        if (!fs.existsSync(workflow)) {
          this.log(`Workflow file ${workflow} not found`, "ERROR");
          continue;
        }
        
        // Validate YAML syntax (basic check)
        try {
          const content = fs.readFileSync(workflow, 'utf8');
          if (!content.includes('name:') || !content.includes('on:')) {
            this.log(`Workflow file ${workflow} appears to be invalid`, "WARN");
          }
        } catch (error) {
          this.log(`Error reading workflow ${workflow}: ${error.message}`, "ERROR");
        }
      }

      // Check if we can trigger workflows manually
      for (const trigger of this.config.githubActions.backupTriggers) {
        try {
          const result = await this.runCommand("npm", ["run", trigger]);
          if (result.status === 0) {
            this.log(`GitHub Actions trigger ${trigger} is working`);
          } else {
            this.log(`GitHub Actions trigger ${trigger} failed`, "WARN");
          }
        } catch (error) {
          this.log(`Error testing GitHub Actions trigger ${trigger}: ${error.message}`, "WARN");
        }
      }

      return true;
    } catch (error) {
      this.log(`GitHub Actions health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkNetlifyFunctionsHealth() {
    this.log("Checking Netlify functions health...");
    
    try {
      if (!fs.existsSync(this.config.netlifyFunctions.manifestFile)) {
        this.log("Netlify functions manifest not found", "ERROR");
        return false;
      }

      const manifest = JSON.parse(fs.readFileSync(this.config.netlifyFunctions.manifestFile, 'utf8'));
      
      if (!manifest.functions || manifest.functions.length === 0) {
        this.log("No Netlify functions found in manifest", "WARN");
        return false;
      }

      this.log(`Found ${manifest.functions.length} Netlify functions`);

      // Check critical functions
      for (const criticalFunc of this.config.netlifyFunctions.criticalFunctions) {
        if (!manifest.functions.includes(criticalFunc)) {
          this.log(`Critical function ${criticalFunc} not found in manifest`, "WARN");
        }
      }

      // Test backup triggers
      for (const trigger of this.config.netlifyFunctions.backupTriggers) {
        try {
          const result = await this.runCommand("npm", ["run", trigger]);
          if (result.status === 0) {
            this.log(`Netlify trigger ${trigger} is working`);
          } else {
            this.log(`Netlify trigger ${trigger} failed`, "WARN");
          }
        } catch (error) {
          this.log(`Error testing Netlify trigger ${trigger}: ${error.message}`, "WARN");
        }
      }

      return true;
    } catch (error) {
      this.log(`Netlify functions health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkBuildSystemHealth() {
    this.log("Checking build system health...");
    
    try {
      // Check if build commands are available
      for (const command of this.config.build.commands) {
        try {
          const result = await this.runCommand("npm", ["run", command.replace("npm run ", "")]);
          if (result.status === 0) {
            this.log(`Build command ${command} is working`);
          } else {
            this.log(`Build command ${command} failed`, "WARN");
          }
        } catch (error) {
          this.log(`Error testing build command ${command}: ${error.message}`, "WARN");
        }
      }

      return true;
    } catch (error) {
      this.log(`Build system health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkPackageScriptsHealth() {
    this.log("Checking package scripts health...");
    
    try {
      // Check critical scripts
      for (const script of this.config.packageScripts.critical) {
        try {
          const result = await this.runCommand("npm", ["run", script]);
          if (result.status === 0) {
            this.log(`Critical script ${script} is working`);
          } else {
            this.log(`Critical script ${script} failed`, "WARN");
          }
        } catch (error) {
          this.log(`Error testing critical script ${script}: ${error.message}`, "WARN");
        }
      }

      return true;
    } catch (error) {
      this.log(`Package scripts health check error: ${error.message}`, "ERROR");
      return false;
    }
  }

  async runFullHealthCheck() {
    this.log("Running full health check...");
    
    const results = {
      pm2: await this.checkPM2Health(),
      githubActions: await this.checkGitHubActionsHealth(),
      netlifyFunctions: await this.checkNetlifyFunctionsHealth(),
      buildSystem: await this.checkBuildSystemHealth(),
      packageScripts: await this.checkPackageScriptsHealth(),
      timestamp: new Date().toISOString()
    };

    const allHealthy = Object.values(results).filter(v => typeof v === 'boolean').every(v => v);
    
    if (allHealthy) {
      this.log("All systems are healthy");
    } else {
      this.log("Some systems have issues, check logs for details", "WARN");
    }

    // Save health check results
    const healthFile = path.join(this.config.logging.logDir, `health-check-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(healthFile, JSON.stringify(results, null, 2));
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e

    return results;
  }

<<<<<<< HEAD
  analyzeCrossSystemIssues(results) {
    const issues = [];
    
    // Check for PM2 and GitHub Actions conflicts
    if (results.systems.pm2 && results.systems.githubActions) {
      if (results.systems.pm2.status === 'unhealthy' && results.systems.githubActions.status === 'unhealthy') {
        issues.push({
          type: 'cross_system_failure',
          systems: ['pm2', 'githubActions'],
          description: 'Both PM2 and GitHub Actions systems are unhealthy, potential automation conflict',
          severity: 'high'
        });
      }
    }

    // Check for Netlify functions and PM2 conflicts
    if (results.systems.netlifyFunctions && results.systems.pm2) {
      if (results.systems.netlifyFunctions.status === 'unhealthy' && results.systems.pm2.status === 'unhealthy') {
        issues.push({
          type: 'cross_system_failure',
          systems: ['netlifyFunctions', 'pm2'],
          description: 'Both Netlify functions and PM2 systems are unhealthy, potential deployment conflict',
          severity: 'high'
        });
      }
    }

    return issues;
  }

  generateRecommendations(results) {
    const recommendations = [];
    
    // System-specific recommendations
    for (const [systemName, systemResult] of Object.entries(results.systems)) {
      if (systemResult.status === 'unhealthy') {
        recommendations.push({
          system: systemName,
          action: 'restart',
          description: `Restart ${systemName} system to resolve health issues`,
          priority: 'high'
        });
      }
    }

    // Cross-system recommendations
    if (results.crossSystemIssues.length > 0) {
      recommendations.push({
        system: 'all',
        action: 'investigate',
        description: 'Investigate cross-system dependencies and resolve conflicts',
        priority: 'critical'
      });
    }

    return recommendations;
  }

  generateOrchestratedHealthReport(results) {
    let systemStatus = "";
    for (const [systemName, systemResult] of Object.entries(results.systems)) {
      const status = systemResult.status === 'healthy' ? "âœ…" : "âŒ";
      const details = systemResult.status === 'healthy' ? "HEALTHY" : `UNHEALTHY: ${systemResult.error || 'Unknown error'}`;
      systemStatus += `${status} ${systemName}: ${details}\n`;
    }

    let crossSystemIssues = "";
    if (results.crossSystemIssues.length > 0) {
      for (const issue of results.crossSystemIssues) {
        crossSystemIssues += `âš ï¸ ${issue.description} (Severity: ${issue.severity})\n`;
      }
    } else {
      crossSystemIssues = "No cross-system issues detected\n";
    }

    let recommendations = "";
    if (results.recommendations.length > 0) {
      for (const rec of results.recommendations) {
        recommendations += `ðŸ’¡ ${rec.description} (Priority: ${rec.priority})\n`;
      }
    } else {
      recommendations = "No immediate actions required\n";
    }

    return `
ðŸŽ¯ MASTER REDUNDANCY ORCHESTRATOR HEALTH REPORT
================================================
Timestamp: ${results.timestamp}
Uptime: ${this.getUptime()}

ðŸ“Š System Health Summary:
Total Systems: ${results.summary.total}
Healthy: ${results.summary.healthy}
Unhealthy: ${results.summary.unhealthy}
Failed: ${results.summary.failed}

ðŸ” Individual System Status:
${systemStatus}

ðŸ”— Cross-System Issues:
${crossSystemIssues}

ðŸ’¡ Recommendations:
${recommendations}

${results.summary.healthy === results.summary.total ? 
  "ðŸŽ‰ All redundancy systems are operating normally!" : 
  "âš ï¸ Some redundancy systems require attention. Check recommendations above."}
`;
  }

  getUptime() {
    if (!this.startupTime) return "Not started";
    
    const uptime = Date.now() - this.startupTime.getTime();
    const days = Math.floor(uptime / (1000 * 60 * 60 * 24));
    const hours = Math.floor((uptime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
    
    return `${days}d ${hours}h ${minutes}m`;
  }

  saveOrchestratedHealthReport(results) {
    try {
      const reportPath = path.join(this.logDir, `orchestrated-health-report-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      this.log(`ðŸ“ Orchestrated health report saved to ${reportPath}`);
    } catch (error) {
      this.log(`âŒ Failed to save orchestrated health report: ${error.message}`, "ERROR");
    }
  }

  updatePerformanceMetrics(results) {
    const timestamp = new Date().toISOString();
    
    for (const [systemName, systemResult] of Object.entries(results.systems)) {
      if (!this.performanceMetrics.has(systemName)) {
        this.performanceMetrics.set(systemName, []);
      }
      
      const metrics = this.performanceMetrics.get(systemName);
      metrics.push({
        timestamp,
        status: systemResult.status,
        responseTime: Date.now() - new Date(results.timestamp).getTime()
      });
      
      // Keep only last 100 metrics per system
      if (metrics.length > 100) {
        metrics.splice(0, metrics.length - 100);
      }
    }
  }

  async startOrchestration() {
    if (this.monitoring) {
      this.log("âš ï¸ Orchestration is already running");
      return;
    }

    this.log("ðŸš€ Starting master redundancy orchestration...");
    
    try {
      // Initialize systems
      const initialized = await this.initializeSystems();
      if (!initialized) {
        throw new Error("Failed to initialize systems");
      }

      // Start systems
      const started = await this.startSystems();
      if (!started) {
        throw new Error("Failed to start systems");
      }

      this.monitoring = true;

      // Set up orchestrated monitoring
      this.orchestrationInterval = setInterval(async () => {
        await this.performOrchestratedHealthCheck();
      }, this.config.orchestration.healthCheckInterval);

      this.log("âœ… Master redundancy orchestration started successfully");
    } catch (error) {
      this.log(`âŒ Failed to start orchestration: ${error.message}`, "ERROR");
      throw error;
    }
  }

  async stopOrchestration() {
    if (!this.monitoring) {
      this.log("âš ï¸ Orchestration is not running");
      return;
    }

    this.log("ðŸ›‘ Stopping master redundancy orchestration...");
    this.monitoring = false;

    if (this.orchestrationInterval) {
      clearInterval(this.orchestrationInterval);
      this.orchestrationInterval = null;
    }

    // Stop all systems
    for (const [systemName, system] of Object.entries(this.systems)) {
      try {
        if (system && typeof system.stopMonitoring === 'function') {
          await system.stopMonitoring();
          this.log(`âœ… Stopped ${systemName} system`);
        }
      } catch (error) {
        this.log(`âš ï¸ Error stopping ${systemName} system: ${error.message}`, "WARN");
      }
    }

    this.log("âœ… Master redundancy orchestration stopped");
  }

  async emergencyRecovery() {
    this.log("ðŸš¨ Starting emergency recovery for all systems...");
    
    try {
      for (const [systemName, system] of Object.entries(this.systems)) {
        try {
          if (system && typeof system.emergencyRecovery === 'function') {
            this.log(`ðŸš¨ Starting emergency recovery for ${systemName} system...`);
            await system.emergencyRecovery();
            this.log(`âœ… Emergency recovery completed for ${systemName} system`);
          }
        } catch (error) {
          this.log(`âŒ Emergency recovery failed for ${systemName} system: ${error.message}`, "ERROR");
        }
      }

      this.log("âœ… Emergency recovery completed for all systems");
      return true;
    } catch (error) {
      this.log(`âŒ Emergency recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  getStatus() {
    return {
      monitoring: this.monitoring,
      config: this.config,
      systemStatus: Object.fromEntries(this.systemStatus),
      performanceMetrics: Object.fromEntries(this.performanceMetrics),
      startupTime: this.startupTime,
      uptime: this.getUptime()
    };
  }
}

// Start the master redundancy orchestrator
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  
  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\nðŸ›‘ Shutting down master redundancy orchestrator...');
    await orchestrator.stopOrchestration();
    process.exit(0);
  });
  
  process.on('SIGTERM', async () => {
    console.log('\nðŸ›‘ Terminating master redundancy orchestrator...');
    await orchestrator.stopOrchestration();
    process.exit(0);
  });

  // Start orchestration
  orchestrator.startOrchestration().catch(error => {
    console.error('Failed to start orchestration:', error);
    process.exit(1);
  });
=======
  async startHealthChecks() {
    this.log("Starting health check monitoring...");
    
    // Run initial health check
    await this.runFullHealthCheck();
    
    // Set up periodic health checks
    setInterval(async () => {
      await this.runFullHealthCheck();
    }, this.config.pm2.healthCheckInterval);
  }

  async initializeMonitoring() {
    this.log("Initializing master redundancy monitoring...");
    
    // Ensure all required directories exist
    const requiredDirs = [
      this.config.logging.logDir,
      "automation/backups",
      "automation/redundancy"
    ];
    
    for (const dir of requiredDirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        this.log(`Created directory: ${dir}`);
      }
    }
  }

  async generateRedundancyReport() {
    this.log("Generating redundancy report...");
    
    const report = {
      timestamp: new Date().toISOString(),
      systems: {
        pm2: {
          status: "monitored",
          processes: this.config.pm2.processes.length,
          ecosystemFiles: this.config.pm2.ecosystemFiles.length
        },
        githubActions: {
          status: "monitored",
          workflows: this.config.githubActions.workflows.length,
          scheduledTasks: this.config.githubActions.scheduledTasks.length
        },
        netlifyFunctions: {
          status: "monitored",
          criticalFunctions: this.config.netlifyFunctions.criticalFunctions.length
        },
        buildSystem: {
          status: "monitored",
          commands: this.config.build.commands.length
        },
        packageScripts: {
          status: "monitored",
          critical: this.config.packageScripts.critical.length
        }
      },
      redundancy: {
        pm2Backup: this.config.pm2.backupProcesses,
        githubBackup: this.config.githubActions.backupTriggers,
        netlifyBackup: this.config.netlifyFunctions.backupTriggers,
        buildBackup: this.config.build.backupCommands,
        scriptsBackup: this.config.packageScripts.backup
      }
    };

    const reportFile = path.join(this.config.logging.logDir, `redundancy-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    this.log(`Redundancy report generated: ${reportFile}`);
    return report;
  }

  async start() {
    this.log("Starting Master Redundancy Orchestrator...");
    
    try {
      await this.initializeMonitoring();
      await this.runFullHealthCheck();
      await this.generateRedundancyReport();
      
      this.log("Master Redundancy Orchestrator started successfully");
      
      // Keep the process running
      setInterval(() => {
        // Heartbeat
        this.log("Master Redundancy Orchestrator heartbeat");
      }, 300000); // 5 minutes
      
    } catch (error) {
      this.log(`Error starting Master Redundancy Orchestrator: ${error.message}`, "ERROR");
      process.exit(1);
    }
  }
}

// CLI interface
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  
  const command = process.argv[2] || 'start';
  
  switch (command) {
    case 'start':
      orchestrator.start();
      break;
    case 'health':
      orchestrator.runFullHealthCheck();
      break;
    case 'report':
      orchestrator.generateRedundancyReport();
      break;
    case 'pm2':
      orchestrator.checkPM2Health();
      break;
    case 'github':
      orchestrator.checkGitHubActionsHealth();
      break;
    case 'netlify':
      orchestrator.checkNetlifyFunctionsHealth();
      break;
    case 'build':
      orchestrator.checkBuildSystemHealth();
      break;
    case 'scripts':
      orchestrator.checkPackageScriptsHealth();
      break;
    default:
      console.log(`
Master Redundancy Orchestrator

Usage: node master-redundancy-orchestrator.cjs [command]

Commands:
  start     Start the orchestrator (default)
  health    Run full health check
  report    Generate redundancy report
  pm2       Check PM2 health
  github    Check GitHub Actions health
  netlify   Check Netlify functions health
  build     Check build system health
  scripts   Check package scripts health
      `);
      process.exit(0);
  }
>>>>>>> origin/cursor/automate-automation-redundancy-and-build-improvement-964e
}

module.exports = MasterRedundancyOrchestrator;