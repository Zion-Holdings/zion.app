#!/usr/bin/env node
"use strict";

const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");
<<<<<<< HEAD
const crypto = require("crypto");

// Import the enhanced redundancy systems
const EnhancedPM2Redundancy = require("./enhanced-pm2-redundancy.cjs");
const EnhancedGitHubActionsRedundancy = require("./enhanced-github-actions-redundancy.cjs");
const EnhancedNetlifyFunctionsRedundancy = require("./enhanced-netlify-functions-redundancy.cjs");
=======
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78

class MasterRedundancyOrchestrator {
  constructor() {
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "master-redundancy-orchestrator.log");
    this.ensureLogDir();
    
    this.config = {
<<<<<<< HEAD
      checkInterval: 60000, // 1 minute
      healthCheckTimeout: 30000,
      backupInterval: 900000, // 15 minutes
      maxLogSize: 10 * 1024 * 1024, // 10MB
      systems: {
        pm2: {
          enabled: true,
          priority: 1,
          autoRecovery: true,
          healthThreshold: 0.8
        },
        githubActions: {
          enabled: true,
          priority: 2,
          autoRecovery: true,
          healthThreshold: 0.8
        },
        netlifyFunctions: {
          enabled: true,
          priority: 3,
          autoRecovery: true,
          healthThreshold: 0.8
        }
      },
      monitoring: false,
      checkInterval: null,
      emergencyMode: false
    };
    
    // Initialize redundancy systems
    this.pm2Redundancy = new EnhancedPM2Redundancy();
    this.githubActionsRedundancy = new EnhancedGitHubActionsRedundancy();
    this.netlifyFunctionsRedundancy = new EnhancedNetlifyFunctionsRedundancy();
    
    this.systemStates = new Map();
    this.overallHealth = 1.0;
    this.lastBackup = Date.now();
    this.recoveryAttempts = 0;
    this.maxRecoveryAttempts = 5;
=======
      systems: {
        pm2: {
          enabled: true,
          script: "automation/enhanced-pm2-redundancy.cjs",
          healthCheckInterval: 30000,
          autoRecovery: true
        },
        githubActions: {
          enabled: true,
          script: "automation/enhanced-github-actions-redundancy.cjs",
          healthCheckInterval: 60000,
          autoRecovery: true
        },
        netlifyFunctions: {
          enabled: true,
          script: "automation/enhanced-netlify-functions-redundancy.cjs",
          healthCheckInterval: 120000,
          autoRecovery: true
        }
      },
      orchestration: {
        masterCheckInterval: 60000,
        systemStartupDelay: 10000,
        maxConcurrentRecoveries: 2,
        emergencyMode: false
      },
      logging: {
        logLevel: "INFO",
        maxLogSize: 10 * 1024 * 1024,
        maxLogFiles: 30
      }
    };
    
    this.systems = new Map();
    this.monitoring = false;
    this.checkInterval = null;
    this.recoveryInProgress = false;
    this.systemStatus = new Map();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
<<<<<<< HEAD
      this.rotateLogs();
=======
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
  }

<<<<<<< HEAD
  rotateLogs() {
    try {
      const stats = fs.statSync(this.logFile);
      if (stats.size > this.config.maxLogSize) {
        const backupFile = `${this.logFile}.${Date.now()}`;
        fs.renameSync(this.logFile, backupFile);
        this.log("Log file rotated", "INFO");
      }
    } catch (error) {
      // Ignore rotation errors
    }
  }

=======
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: this.workspace,
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 10,
<<<<<<< HEAD
        timeout: options.timeout || this.config.healthCheckTimeout,
=======
        timeout: options.timeout || 30000,
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

<<<<<<< HEAD
  async startHealthChecks() {
    this.log("Starting health check monitoring...");
    
    // Run initial health check
    await this.runFullHealthCheck();
    
    // Set up periodic health checks
    setInterval(async () => {
      await this.runFullHealthCheck();
    }, this.config.pm2.healthCheckInterval);
  }

  async initializeMonitoring() {
    this.log("Initializing master redundancy monitoring...");
    
    // Ensure all required directories exist
    const requiredDirs = [
      this.config.logging.logDir,
      "automation/backups",
      "automation/redundancy"
    ];
    
    for (const dir of requiredDirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        this.log(`Created directory: ${dir}`);
      }
    }
  }

  async generateRedundancyReport() {
    this.log("Generating redundancy report...");
    
    const report = {
      timestamp: new Date().toISOString(),
      systems: {
        pm2: {
          status: "monitored",
          processes: this.config.pm2.processes.length,
          ecosystemFiles: this.config.pm2.ecosystemFiles.length
        },
        githubActions: {
          status: "monitored",
          workflows: this.config.githubActions.workflows.length,
          scheduledTasks: this.config.githubActions.scheduledTasks.length
        },
        netlifyFunctions: {
          status: "monitored",
          criticalFunctions: this.config.netlifyFunctions.criticalFunctions.length
        },
        buildSystem: {
          status: "monitored",
          commands: this.config.build.commands.length
        },
        packageScripts: {
          status: "monitored",
          critical: this.config.packageScripts.critical.length
        }
      },
      redundancy: {
        pm2Backup: this.config.pm2.backupProcesses,
        githubBackup: this.config.githubActions.backupTriggers,
        netlifyBackup: this.config.netlifyFunctions.backupTriggers,
        buildBackup: this.config.build.backupCommands,
        scriptsBackup: this.config.packageScripts.backup
      }
    };

    const reportFile = path.join(this.config.logging.logDir, `redundancy-report-${new Date().toISOString().split('T')[0]}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    this.log(`Redundancy report generated: ${reportFile}`);
    return report;
  }

  async start() {
    this.log("Starting Master Redundancy Orchestrator...");
    
    try {
      await this.initializeMonitoring();
      await this.runFullHealthCheck();
      await this.generateRedundancyReport();
      
      this.log("Master Redundancy Orchestrator started successfully");
      
      // Keep the process running
      setInterval(() => {
        // Heartbeat
        this.log("Master Redundancy Orchestrator heartbeat");
      }, 300000); // 5 minutes
      
    } catch (error) {
      this.log(`Error starting Master Redundancy Orchestrator: ${error.message}`, "ERROR");
=======
  async checkSystemHealth(systemName) {
    try {
      let health = 0;
      let details = {};

      switch (systemName) {
        case 'pm2':
          if (this.config.systems.pm2.enabled) {
            const report = await this.pm2Redundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;

        case 'githubActions':
          if (this.config.systems.githubActions.enabled) {
            const report = await this.githubActionsRedundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;

        case 'netlifyFunctions':
          if (this.config.systems.netlifyFunctions.enabled) {
            const report = await this.netlifyFunctionsRedundancy.generateHealthReport();
            if (report) {
              health = report.summary.healthy / report.summary.total;
              details = report;
            }
          }
          break;
      }

      return { health, details };
    } catch (error) {
      this.log(`Error checking ${systemName} health: ${error.message}`, "ERROR");
      return { health: 0, details: { error: error.message } };
    }
  }

  async backupAllSystems() {
    try {
      const backupDir = path.join(this.workspace, "automation/backups/master");
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(backupDir, `master-backup-${timestamp}`);
      fs.mkdirSync(backupPath, { recursive: true });

      // Backup PM2 ecosystem files
      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.backupEcosystemFiles();
      }

      // Backup GitHub Actions workflows
      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.backupWorkflows();
      }

      // Backup Netlify functions
      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.backupFunctions();
      }

      // Backup configuration files
      const configFiles = [
        "ecosystem.pm2.cjs",
        "ecosystem.redundancy.cjs",
        ".github/workflows/",
        "netlify/",
        "automation/redundancy-config.json"
      ];

      for (const configFile of configFiles) {
        const sourcePath = path.join(this.workspace, configFile);
        if (fs.existsSync(sourcePath)) {
          const targetPath = path.join(backupPath, configFile);
          if (fs.lstatSync(sourcePath).isDirectory()) {
            await this.runCommand("cp", ["-r", sourcePath, targetPath]);
          } else {
            fs.copyFileSync(sourcePath, targetPath);
          }
        }
      }

      this.log(`Master backup completed: ${backupPath}`, "INFO");
      this.lastBackup = Date.now();
      return true;
    } catch (error) {
      this.log(`Failed to backup all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async restoreAllSystems(backupTimestamp = null) {
    try {
      this.log("Starting system-wide restoration", "WARN");
      
      // Stop all monitoring
      await this.stopAllMonitoring();

      // Restore each system
      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.restoreFromBackup();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.restoreWorkflowsFromBackup();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.restoreFunctionsFromBackup();
      }

      // Restart monitoring
      await this.startAllMonitoring();

      this.log("System-wide restoration completed", "INFO");
      return true;
    } catch (error) {
      this.log(`System-wide restoration failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async startAllMonitoring() {
    try {
      this.log("Starting all redundancy systems", "INFO");

      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.startMonitoring();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.startMonitoring();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.startMonitoring();
      }

      this.log("All redundancy systems started", "INFO");
      return true;
    } catch (error) {
      this.log(`Failed to start all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async stopAllMonitoring() {
    try {
      this.log("Stopping all redundancy systems", "INFO");

      if (this.config.systems.pm2.enabled) {
        await this.pm2Redundancy.stopMonitoring();
      }

      if (this.config.systems.githubActions.enabled) {
        await this.githubActionsRedundancy.stopMonitoring();
      }

      if (this.config.systems.netlifyFunctions.enabled) {
        await this.netlifyFunctionsRedundancy.stopMonitoring();
      }

      this.log("All redundancy systems stopped", "INFO");
      return true;
    } catch (error) {
      this.log(`Failed to stop all systems: ${error.message}`, "ERROR");
      return false;
    }
  }

  async monitorAllSystems() {
    this.log("Starting master system monitoring...", "INFO");
    
    const systemNames = Object.keys(this.config.systems);
    let totalHealth = 0;
    let healthySystems = 0;

    for (const systemName of systemNames) {
      if (this.config.systems[systemName].enabled) {
        try {
          const { health, details } = await this.checkSystemHealth(systemName);
          
          this.systemStates.set(systemName, { health, details, lastCheck: Date.now() });
          
          if (health >= this.config.systems[systemName].healthThreshold) {
            healthySystems++;
            this.log(`System ${systemName} healthy (${(health * 100).toFixed(1)}%)`, "INFO");
          } else {
            this.log(`System ${systemName} unhealthy (${(health * 100).toFixed(1)}%)`, "WARN");
            
            // Attempt auto-recovery if enabled
            if (this.config.systems[systemName].autoRecovery) {
              await this.attemptSystemRecovery(systemName);
            }
          }
          
          totalHealth += health;
          
        } catch (error) {
          this.log(`Error monitoring system ${systemName}: ${error.message}`, "ERROR");
          this.systemStates.set(systemName, { health: 0, details: { error: error.message }, lastCheck: Date.now() });
        }
      }
    }

    // Calculate overall health
    this.overallHealth = totalHealth / systemNames.length;
    
    // Check if emergency mode is needed
    if (this.overallHealth < 0.5 && !this.config.emergencyMode) {
      await this.enterEmergencyMode();
    } else if (this.overallHealth >= 0.8 && this.config.emergencyMode) {
      await this.exitEmergencyMode();
    }

    this.log(`Overall system health: ${(this.overallHealth * 100).toFixed(1)}% (${healthySystems}/${systemNames.length} healthy)`, "INFO");
  }

  async attemptSystemRecovery(systemName) {
    try {
      this.log(`Attempting recovery for system: ${systemName}`, "WARN");
      
      let recoverySuccess = false;
      
      switch (systemName) {
        case 'pm2':
          recoverySuccess = await this.pm2Redundancy.emergencyRecovery();
          break;
        case 'githubActions':
          recoverySuccess = await this.githubActionsRedundancy.emergencyRecovery();
          break;
        case 'netlifyFunctions':
          recoverySuccess = await this.netlifyFunctionsRedundancy.emergencyRecovery();
          break;
      }

      if (recoverySuccess) {
        this.log(`Successfully recovered system: ${systemName}`, "INFO");
        this.recoveryAttempts = 0;
      } else {
        this.recoveryAttempts++;
        this.log(`Failed to recover system: ${systemName} (attempt ${this.recoveryAttempts})`, "ERROR");
      }

      return recoverySuccess;
    } catch (error) {
      this.log(`Error during system recovery: ${error.message}`, "ERROR");
      return false;
    }
  }

  async enterEmergencyMode() {
    this.config.emergencyMode = true;
    this.log("ðŸš¨ ENTERING EMERGENCY MODE - System health critically low", "ERROR");
    
    try {
      // Stop all monitoring to prevent interference
      await this.stopAllMonitoring();
      
      // Perform emergency backup
      await this.backupAllSystems();
      
      // Attempt full system recovery
      if (this.recoveryAttempts < this.maxRecoveryAttempts) {
        await this.attemptFullSystemRecovery();
      } else {
        this.log("Maximum recovery attempts reached, manual intervention required", "ERROR");
      }
      
      // Restart monitoring
      await this.startAllMonitoring();
      
    } catch (error) {
      this.log(`Emergency mode error: ${error.message}`, "ERROR");
    }
  }

  async exitEmergencyMode() {
    this.config.emergencyMode = false;
    this.log("âœ… EXITING EMERGENCY MODE - System health restored", "INFO");
    this.recoveryAttempts = 0;
  }

  async attemptFullSystemRecovery() {
    try {
      this.log("Attempting full system recovery", "WARN");
      
      // Restore from latest backup
      if (await this.restoreAllSystems()) {
        this.log("Full system recovery successful", "INFO");
        return true;
      }
      
      // If backup restoration fails, try individual system recovery
      const systemNames = Object.keys(this.config.systems);
      let recoveryCount = 0;
      
      for (const systemName of systemNames) {
        if (this.config.systems[systemName].enabled) {
          if (await this.attemptSystemRecovery(systemName)) {
            recoveryCount++;
          }
        }
      }
      
      this.log(`Recovered ${recoveryCount}/${systemNames.length} systems`, "INFO");
      return recoveryCount > 0;
      
    } catch (error) {
      this.log(`Full system recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  async generateMasterReport() {
    try {
      const report = {
        timestamp: new Date().toISOString(),
        overallHealth: this.overallHealth,
        emergencyMode: this.config.emergencyMode,
        recoveryAttempts: this.recoveryAttempts,
        systems: {},
        summary: {
          total: Object.keys(this.config.systems).length,
          healthy: 0,
          unhealthy: 0,
          disabled: 0
        }
      };

      for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
        const state = this.systemStates.get(systemName);
        
        if (systemConfig.enabled) {
          if (state && state.health >= systemConfig.healthThreshold) {
            report.summary.healthy++;
          } else {
            report.summary.unhealthy++;
          }
          
          report.systems[systemName] = {
            enabled: true,
            health: state ? state.health : 0,
            priority: systemConfig.priority,
            autoRecovery: systemConfig.autoRecovery,
            lastCheck: state ? state.lastCheck : null,
            details: state ? state.details : {}
          };
        } else {
          report.summary.disabled++;
          report.systems[systemName] = {
            enabled: false,
            health: 0,
            priority: systemConfig.priority,
            autoRecovery: systemConfig.autoRecovery
          };
        }
      }

      // Save report
      const reportPath = path.join(this.logDir, "master-redundancy-report.json");
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      
      this.log(`Master report generated: ${reportPath}`, "INFO");
      return report;
    } catch (error) {
      this.log(`Failed to generate master report: ${error.message}`, "ERROR");
      return null;
    }
=======
  async startSystem(systemName, systemConfig) {
    try {
      this.log(`ðŸš€ Starting ${systemName} redundancy system...`);
      
      if (!fs.existsSync(systemConfig.script)) {
        this.log(`âŒ Script not found for ${systemName}: ${systemConfig.script}`, "ERROR");
        return false;
      }

      // Start the system process
      const result = await this.runCommand("node", [systemConfig.script], {
        timeout: 60000
      });

      if (result.status === 0) {
        this.log(`âœ… ${systemName} redundancy system started successfully`);
        this.systemStatus.set(systemName, { status: "running", lastStart: new Date().toISOString() });
        return true;
      } else {
        this.log(`âŒ Failed to start ${systemName} redundancy system: ${result.stderr}`, "ERROR");
        this.systemStatus.set(systemName, { status: "failed", lastStart: new Date().toISOString(), error: result.stderr });
        return false;
      }
    } catch (error) {
      this.log(`âŒ Error starting ${systemName} redundancy system: ${error.message}`, "ERROR");
      this.systemStatus.set(systemName, { status: "error", lastStart: new Date().toISOString(), error: error.message });
      return false;
    }
  }

  async stopSystem(systemName) {
    try {
      this.log(`ðŸ›‘ Stopping ${systemName} redundancy system...`);
      
      // Find and kill the process
      const result = await this.runCommand("pkill", ["-f", systemName]);
      
      if (result.status === 0 || result.status === 1) { // 1 means no processes found
        this.log(`âœ… ${systemName} redundancy system stopped`);
        this.systemStatus.set(systemName, { status: "stopped", lastStop: new Date().toISOString() });
        return true;
      } else {
        this.log(`âš ï¸ Could not stop ${systemName} redundancy system cleanly`, "WARN");
        return false;
      }
    } catch (error) {
      this.log(`âŒ Error stopping ${systemName} redundancy system: ${error.message}`, "ERROR");
      return false;
    }
  }

  async restartSystem(systemName, systemConfig) {
    try {
      this.log(`ðŸ”„ Restarting ${systemName} redundancy system...`);
      
      await this.stopSystem(systemName);
      await this.sleep(5000); // Wait for cleanup
      const success = await this.startSystem(systemName, systemConfig);
      
      if (success) {
        this.log(`âœ… ${systemName} redundancy system restarted successfully`);
      } else {
        this.log(`âŒ Failed to restart ${systemName} redundancy system`, "ERROR");
      }
      
      return success;
    } catch (error) {
      this.log(`âŒ Error restarting ${systemName} redundancy system: ${error.message}`, "ERROR");
      return false;
    }
  }

  async checkSystemHealth(systemName, systemConfig) {
    try {
      this.log(`ðŸ” Checking health of ${systemName} redundancy system...`);
      
      // Check if the system process is running
      const result = await this.runCommand("pgrep", ["-f", systemName]);
      const isRunning = result.status === 0;
      
      if (isRunning) {
        this.log(`âœ… ${systemName} redundancy system is running`);
        this.systemStatus.set(systemName, { 
          status: "healthy", 
          lastCheck: new Date().toISOString(),
          uptime: await this.getSystemUptime(systemName)
        });
        return true;
      } else {
        this.log(`âš ï¸ ${systemName} redundancy system is not running`, "WARN");
        this.systemStatus.set(systemName, { 
          status: "down", 
          lastCheck: new Date().toISOString()
        });
        return false;
      }
    } catch (error) {
      this.log(`âŒ Error checking health of ${systemName} redundancy system: ${error.message}`, "ERROR");
      return false;
    }
  }

  async getSystemUptime(systemName) {
    try {
      const result = await this.runCommand("pgrep", ["-o", "-f", systemName]);
      if (result.status === 0) {
        const pid = result.stdout.trim();
        const psResult = await this.runCommand("ps", ["-o", "etime=", "-p", pid]);
        if (psResult.status === 0) {
          return psResult.stdout.trim();
        }
      }
      return "unknown";
    } catch (error) {
      return "unknown";
    }
  }

  async performSystemRecovery(systemName, systemConfig) {
    if (this.recoveryInProgress) {
      this.log(`âš ï¸ Recovery already in progress, skipping ${systemName}`, "WARN");
      return false;
    }

    try {
      this.recoveryInProgress = true;
      this.log(`ðŸš¨ Starting recovery for ${systemName} redundancy system...`);
      
      const recoverySuccess = await this.restartSystem(systemName, systemConfig);
      
      if (recoverySuccess) {
        this.log(`âœ… Recovery completed successfully for ${systemName}`);
        this.systemStatus.set(systemName, { 
          status: "recovered", 
          lastRecovery: new Date().toISOString()
        });
      } else {
        this.log(`âŒ Recovery failed for ${systemName}`, "ERROR");
        this.systemStatus.set(systemName, { 
          status: "recovery_failed", 
          lastRecovery: new Date().toISOString()
        });
      }
      
      return recoverySuccess;
    } catch (error) {
      this.log(`âŒ Error during recovery of ${systemName}: ${error.message}`, "ERROR");
      return false;
    } finally {
      this.recoveryInProgress = false;
    }
  }

  async performMasterHealthCheck() {
    this.log("ðŸš€ Starting master redundancy orchestrator health check...");
    
    const results = {
      systems: {},
      overall: {
        healthy: 0,
        unhealthy: 0,
        total: 0
      },
      timestamp: new Date().toISOString()
    };

    // Check each system
    for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
      if (!systemConfig.enabled) {
        this.log(`â­ï¸ Skipping disabled system: ${systemName}`);
        continue;
      }

      const isHealthy = await this.checkSystemHealth(systemName, systemConfig);
      results.systems[systemName] = {
        enabled: systemConfig.enabled,
        healthy: isHealthy,
        status: this.systemStatus.get(systemName) || { status: "unknown" }
      };

      if (isHealthy) {
        results.overall.healthy++;
      } else {
        results.overall.unhealthy++;
        
        // Attempt recovery if enabled
        if (systemConfig.autoRecovery && !this.recoveryInProgress) {
          this.log(`ðŸ”„ Initiating auto-recovery for ${systemName}...`);
          setTimeout(() => this.performSystemRecovery(systemName, systemConfig), 1000);
        }
      }
      
      results.overall.total++;
    }

    // Log results
    this.log(`ðŸ“Š Master Health Check Results:
    - Total Systems: ${results.overall.total}
    - Healthy: ${results.overall.healthy} âœ…
    - Unhealthy: ${results.overall.unhealthy} âŒ
    - Health Rate: ${results.overall.total > 0 ? Math.round((results.overall.healthy / results.overall.total) * 100) : 0}%`);

    // Save health check results
    const healthCheckFile = path.join(this.logDir, `master-health-check-${new Date().toISOString().split('T')[0]}.json`);
    try {
      fs.writeFileSync(healthCheckFile, JSON.stringify(results, null, 2));
    } catch (error) {
      this.log(`âŒ Failed to save master health check results: ${error.message}`, "ERROR");
    }

    return results;
  }

  async emergencyMode() {
    this.log("ðŸš¨ Entering emergency mode - attempting full system recovery...");
    
    try {
      this.config.orchestration.emergencyMode = true;
      
      // Stop all systems
      for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
        if (systemConfig.enabled) {
          await this.stopSystem(systemName);
        }
      }
      
      await this.sleep(10000); // Wait for cleanup
      
      // Start all systems in sequence
      for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
        if (systemConfig.enabled) {
          await this.startSystem(systemName, systemConfig);
          await this.sleep(this.config.orchestration.systemStartupDelay);
        }
      }
      
      // Perform health check
      await this.performMasterHealthCheck();
      
      this.config.orchestration.emergencyMode = false;
      this.log("âœ… Emergency mode recovery completed");
      return true;
    } catch (error) {
      this.log(`âŒ Emergency mode recovery failed: ${error.message}`, "ERROR");
      this.config.orchestration.emergencyMode = false;
      return false;
    }
  }

  async startAllSystems() {
    this.log("ðŸš€ Starting all redundancy systems...");
    
    const startupResults = {};
    
    for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
      if (systemConfig.enabled) {
        this.log(`ðŸ“ Starting ${systemName}...`);
        const success = await this.startSystem(systemName, systemConfig);
        startupResults[systemName] = success;
        
        if (success) {
          await this.sleep(this.config.orchestration.systemStartupDelay);
        }
      } else {
        this.log(`â­ï¸ Skipping disabled system: ${systemName}`);
        startupResults[systemName] = "disabled";
      }
    }
    
    // Log startup results
    const successful = Object.values(startupResults).filter(r => r === true).length;
    const total = Object.keys(startupResults).length;
    
    this.log(`ðŸ“Š System Startup Results: ${successful}/${total} systems started successfully`);
    
    return startupResults;
  }

  async stopAllSystems() {
    this.log("ðŸ›‘ Stopping all redundancy systems...");
    
    const stopResults = {};
    
    for (const [systemName, systemConfig] of Object.entries(this.config.systems)) {
      if (systemConfig.enabled) {
        this.log(`ðŸ“ Stopping ${systemName}...`);
        const success = await this.stopSystem(systemName);
        stopResults[systemName] = success;
      } else {
        this.log(`â­ï¸ Skipping disabled system: ${systemName}`);
        stopResults[systemName] = "disabled";
      }
    }
    
    this.log("âœ… All redundancy systems stopped");
    return stopResults;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
  }

  async startMonitoring() {
    if (this.monitoring) {
<<<<<<< HEAD
      this.log("Monitoring already started", "WARN");
      return;
    }

    this.monitoring = true;
    this.log("Starting master redundancy orchestrator", "INFO");

    // Initial backup
    await this.backupAllSystems();

    // Start all system monitoring
    await this.startAllMonitoring();

    // Start master monitoring loop
    this.checkInterval = setInterval(async () => {
      try {
        await this.monitorAllSystems();
        
        // Backup all systems periodically
        if (Date.now() - this.lastBackup > this.config.backupInterval) {
          await this.backupAllSystems();
        }
        
        // Generate master report every 5 minutes
        if (Date.now() % 300000 < this.config.checkInterval) {
          await this.generateMasterReport();
        }
        
      } catch (error) {
        this.log(`Error in master monitoring loop: ${error.message}`, "ERROR");
      }
    }, this.config.checkInterval);

    this.log("Master redundancy orchestrator started", "INFO");
=======
      this.log("âš ï¸ Monitoring is already running");
      return;
    }

    this.log("ðŸš€ Starting master redundancy orchestrator monitoring...");
    this.monitoring = true;

    // Start all systems
    await this.startAllSystems();

    // Initial health check
    await this.performMasterHealthCheck();

    // Start monitoring loop
    this.checkInterval = setInterval(async () => {
      try {
        await this.performMasterHealthCheck();
      } catch (error) {
        this.log(`âŒ Error in master monitoring loop: ${error.message}`, "ERROR");
      }
    }, this.config.orchestration.masterCheckInterval);

    this.log(`âœ… Master redundancy orchestrator monitoring started with ${this.config.orchestration.masterCheckInterval}ms intervals`);
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
  }

  async stopMonitoring() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    
<<<<<<< HEAD
    await this.stopAllMonitoring();
    this.monitoring = false;
    this.log("Master redundancy orchestrator stopped", "INFO");
  }

  async emergencyShutdown() {
    this.log("ðŸš¨ EMERGENCY SHUTDOWN INITIATED", "ERROR");
    
    try {
      // Stop all monitoring
      await this.stopAllMonitoring();
      
      // Perform final backup
      await this.backupAllSystems();
      
      this.log("Emergency shutdown completed", "INFO");
      process.exit(1);
    } catch (error) {
      this.log(`Emergency shutdown error: ${error.message}`, "ERROR");
      process.exit(1);
    }
  }
}

// CLI interface
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  
  const command = process.argv[2];
  
  switch (command) {
    case "start":
      orchestrator.startMonitoring();
      break;
    case "stop":
      orchestrator.stopMonitoring();
      break;
    case "status":
      orchestrator.monitorAllSystems();
      break;
    case "report":
      orchestrator.generateMasterReport();
      break;
    case "backup":
      orchestrator.backupAllSystems();
      break;
    case "restore":
      orchestrator.restoreAllSystems();
      break;
    case "recovery":
      orchestrator.attemptFullSystemRecovery();
      break;
    case "emergency":
      orchestrator.enterEmergencyMode();
      break;
    case "shutdown":
      orchestrator.emergencyShutdown();
      break;
    default:
      console.log("Usage: node master-redundancy-orchestrator.cjs [start|stop|status|report|backup|restore|recovery|emergency|shutdown]");
      process.exit(1);
  }
=======
    this.monitoring = false;
    this.log("ðŸ›‘ Master redundancy orchestrator monitoring stopped");
  }

  async cleanup() {
    this.log("ðŸ§¹ Cleaning up master redundancy orchestrator...");
    
    try {
      await this.stopMonitoring();
      await this.stopAllSystems();
      
      this.log("âœ… Cleanup completed");
    } catch (error) {
      this.log(`âŒ Error during cleanup: ${error.message}`, "ERROR");
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  getSystemStatus() {
    return Object.fromEntries(this.systemStatus);
  }

  getConfiguration() {
    return this.config;
  }
}

// Start the master redundancy orchestrator
if (require.main === module) {
  const orchestrator = new MasterRedundancyOrchestrator();
  
  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    orchestrator.log("ðŸ›‘ Shutting down master redundancy orchestrator...");
    await orchestrator.cleanup();
    process.exit(0);
  });
  
  process.on('SIGTERM', async () => {
    orchestrator.log("ðŸ›‘ Shutting down master redundancy orchestrator...");
    await orchestrator.cleanup();
    process.exit(0);
  });
  
  // Start monitoring
  orchestrator.startMonitoring();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-5c78
}

module.exports = MasterRedundancyOrchestrator;