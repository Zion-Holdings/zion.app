#!/usr/bin/env node
"use strict";

const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");

class EnhancedPM2Redundancy {
  constructor() {
    this.workspace = process.cwd();
    this.logDir = path.join(this.workspace, "automation/logs");
    this.logFile = path.join(this.logDir, "enhanced-pm2-redundancy.log");
    this.ensureLogDir();
    
    this.config = {
<<<<<<< HEAD
      ecosystemFiles: [
        "ecosystem.pm2.cjs",
        "ecosystem.redundancy.cjs"
      ],
      criticalProcesses: [
        "zion-auto-sync",
        "zion-auto-sync-cron"
      ],
      redundancyProcesses: [
=======
      enabled: true,
      checkInterval: 30000,
      maxRestartAttempts: 5,
      restartDelay: 5000,
      autoRecovery: true,
      healthCheckTimeout: 15000,
      criticalProcesses: [
        "zion-auto-sync",
        "zion-auto-sync-cron",
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
        "redundancy-automation-system",
        "redundancy-health-monitor",
        "redundancy-git-sync",
        "redundancy-build-monitor"
      ],
<<<<<<< HEAD
      allProcesses: [],
      healthCheckInterval: 30000,
      maxRestartAttempts: 5,
      restartDelay: 5000,
      enableAutoRecovery: true,
      enableProcessMonitoring: true,
      enableEcosystemValidation: true
    };
    
    this.initializeProcesses();
    this.monitoring = false;
    this.checkInterval = null;
    this.restartAttempts = new Map();
=======
      ecosystemFiles: [
        "ecosystem.pm2.cjs",
        "ecosystem.redundancy.cjs"
      ],
      backupEcosystems: true,
      logRotation: true,
      maxLogSize: 10 * 1024 * 1024, // 10MB
      maxLogFiles: 30
    };
    
    this.monitoring = false;
    this.checkInterval = null;
    this.restartAttempts = new Map();
    this.healthHistory = [];
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
  }

  ensureLogDir() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

<<<<<<< HEAD
  initializeProcesses() {
    this.config.allProcesses = [
      ...this.config.criticalProcesses,
      ...this.config.redundancyProcesses
    ];
  }

=======
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
  log(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      fs.appendFileSync(this.logFile, logMessage + "\n");
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
  }

  async runCommand(command, args = [], options = {}) {
    return new Promise((resolve) => {
      const result = spawnSync(command, args, {
        cwd: this.workspace,
        env: process.env,
        shell: false,
        encoding: "utf8",
        maxBuffer: 1024 * 1024 * 10,
<<<<<<< HEAD
        timeout: options.timeout || 30000,
=======
        timeout: options.timeout || this.config.healthCheckTimeout,
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
        ...options
      });
      
      resolve({
        status: result.status,
        stdout: result.stdout || "",
        stderr: result.stderr || "",
        error: result.error
      });
    });
  }

  async checkPM2Daemon() {
    try {
<<<<<<< HEAD
      const result = await this.runCommand("pm2", ["ping"]);
      if (result.status === 0) {
        this.log("‚úÖ PM2 daemon is responding");
        return true;
      } else {
        this.log("‚ùå PM2 daemon not responding", "WARN");
        return false;
      }
=======
      const result = await this.runCommand("pm2", ["status", "--no-daemon"]);
      
      if (result.status !== 0) {
        this.log("‚ùå PM2 daemon not responding", "ERROR");
        return false;
      }
      
      this.log("‚úÖ PM2 daemon is healthy");
      return true;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    } catch (error) {
      this.log(`‚ùå PM2 daemon check failed: ${error.message}`, "ERROR");
      return false;
    }
  }

<<<<<<< HEAD
  async restartPM2Daemon() {
    this.log("üîÑ Restarting PM2 daemon...");
    try {
      await this.runCommand("pm2", ["kill"]);
      await this.runCommand("pm2", ["start"]);
      this.log("‚úÖ PM2 daemon restarted successfully");
      return true;
    } catch (error) {
      this.log(`‚ùå Failed to restart PM2 daemon: ${error.message}`, "ERROR");
      return false;
    }
  }

  async validateEcosystemFiles() {
    this.log("üîç Validating PM2 ecosystem files...");
    
    const validFiles = [];
    for (const ecosystemFile of this.config.ecosystemFiles) {
      const filePath = path.join(this.workspace, ecosystemFile);
      if (fs.existsSync(filePath)) {
        try {
          // Try to require the ecosystem file to validate syntax
          require(filePath);
          validFiles.push(ecosystemFile);
          this.log(`‚úÖ Ecosystem file ${ecosystemFile} is valid`);
        } catch (error) {
          this.log(`‚ùå Ecosystem file ${ecosystemFile} has syntax errors: ${error.message}`, "ERROR");
        }
      } else {
        this.log(`‚ö†Ô∏è Ecosystem file ${ecosystemFile} not found`, "WARN");
      }
    }
    
    return validFiles;
  }

  async startEcosystemFile(ecosystemFile) {
    this.log(`üöÄ Starting ecosystem file: ${ecosystemFile}`);
    try {
      const result = await this.runCommand("pm2", ["start", ecosystemFile]);
      if (result.status === 0) {
        this.log(`‚úÖ Successfully started ecosystem: ${ecosystemFile}`);
        return true;
      } else {
        this.log(`‚ùå Failed to start ecosystem: ${ecosystemFile}`, "ERROR");
        return false;
      }
    } catch (error) {
      this.log(`‚ùå Error starting ecosystem ${ecosystemFile}: ${error.message}`, "ERROR");
      return false;
=======
  async checkEcosystemFiles() {
    this.log("üîç Checking PM2 ecosystem files...");
    
    const results = {
      exists: [],
      missing: [],
      valid: [],
      invalid: []
    };

    for (const ecosystemFile of this.config.ecosystemFiles) {
      const filePath = path.join(this.workspace, ecosystemFile);
      
      if (fs.existsSync(filePath)) {
        results.exists.push(ecosystemFile);
        
        try {
          // Basic validation - check if it's a valid CommonJS module
          const content = fs.readFileSync(filePath, 'utf8');
          if (content.includes('module.exports') && content.includes('apps:')) {
            results.valid.push(ecosystemFile);
            this.log(`‚úÖ Ecosystem file ${ecosystemFile} is valid`);
          } else {
            results.invalid.push(ecosystemFile);
            this.log(`‚ö†Ô∏è Ecosystem file ${ecosystemFile} appears invalid`, "WARN");
          }
        } catch (error) {
          results.invalid.push(ecosystemFile);
          this.log(`‚ùå Error reading ecosystem file ${ecosystemFile}: ${error.message}`, "ERROR");
        }
      } else {
        results.missing.push(ecosystemFile);
        this.log(`‚ùå Ecosystem file ${ecosystemFile} not found`, "ERROR");
      }
    }

    // Create backup ecosystems if enabled
    if (this.config.backupEcosystems) {
      await this.createBackupEcosystems(results.exists);
    }

    return results;
  }

  async createBackupEcosystems(existingFiles) {
    try {
      const backupDir = path.join(this.workspace, "automation/backup/ecosystems");
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      for (const ecosystemFile of existingFiles) {
        const sourcePath = path.join(this.workspace, ecosystemFile);
        const backupPath = path.join(backupDir, `${ecosystemFile}.backup`);
        
        if (fs.existsSync(sourcePath) && !fs.existsSync(backupPath)) {
          fs.copyFileSync(sourcePath, backupPath);
          this.log(`üíæ Created backup for ecosystem: ${ecosystemFile}`);
        }
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not create backup ecosystems: ${error.message}`, "WARN");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    }
  }

  async checkProcessHealth(processName) {
    try {
<<<<<<< HEAD
      const result = await this.runCommand("pm2", ["show", processName]);
      if (result.status === 0) {
        // Parse process status from output
        const output = result.stdout;
        if (output.includes("status") && output.includes("online")) {
          this.log(`‚úÖ Process ${processName} is healthy and online`);
          return { healthy: true, status: "online" };
        } else if (output.includes("status") && output.includes("stopped")) {
          this.log(`‚ö†Ô∏è Process ${processName} is stopped`, "WARN");
          return { healthy: false, status: "stopped" };
        } else if (output.includes("status") && output.includes("errored")) {
          this.log(`‚ùå Process ${processName} has errors`, "ERROR");
          return { healthy: false, status: "errored" };
        } else {
          this.log(`‚ö†Ô∏è Process ${processName} status unclear`, "WARN");
          return { healthy: false, status: "unknown" };
        }
      } else {
        this.log(`‚ùå Process ${processName} not found`, "WARN");
        return { healthy: false, status: "not_found" };
      }
    } catch (error) {
      this.log(`‚ùå Error checking process ${processName}: ${error.message}`, "ERROR");
      return { healthy: false, status: "error" };
    }
  }

  async restartProcess(processName) {
    const attempts = this.restartAttempts.get(processName) || 0;
    
    if (attempts >= this.config.maxRestartAttempts) {
      this.log(`‚ö†Ô∏è Process ${processName} has exceeded max restart attempts (${attempts}/${this.config.maxRestartAttempts})`, "WARN");
      return false;
    }
    
    this.log(`üîÑ Restarting process ${processName} (attempt ${attempts + 1}/${this.config.maxRestartAttempts})`);
    
    try {
      const result = await this.runCommand("pm2", ["restart", processName]);
      if (result.status === 0) {
        this.log(`‚úÖ Successfully restarted process: ${processName}`);
        this.restartAttempts.set(processName, attempts + 1);
        
        // Reset restart attempts after successful restart
        setTimeout(() => {
          this.restartAttempts.set(processName, 0);
        }, 60000); // Reset after 1 minute
        
        return true;
      } else {
        this.log(`‚ùå Failed to restart process: ${processName}`, "ERROR");
=======
      const result = await this.runCommand("pm2", ["show", processName, "--no-daemon"]);
      
      if (result.status !== 0) {
        this.log(`‚ùå Process ${processName} not found`, "ERROR");
        return {
          healthy: false,
          status: "not_found",
          restartCount: 0,
          uptime: 0
        };
      }

      // Parse process information
      const output = result.stdout;
      const restartCount = this.extractRestartCount(output);
      const uptime = this.extractUptime(output);
      const status = this.extractStatus(output);

      const isHealthy = status === "online" && uptime > 0;
      
      if (isHealthy) {
        this.log(`‚úÖ Process ${processName} is healthy (uptime: ${uptime}s, restarts: ${restartCount})`);
      } else {
        this.log(`‚ö†Ô∏è Process ${processName} is unhealthy (status: ${status}, uptime: ${uptime}s)`, "WARN");
      }

      return {
        healthy: isHealthy,
        status: status,
        restartCount: restartCount,
        uptime: uptime
      };
    } catch (error) {
      this.log(`‚ùå Error checking process ${processName}: ${error.message}`, "ERROR");
      return {
        healthy: false,
        status: "error",
        restartCount: 0,
        uptime: 0
      };
    }
  }

  extractRestartCount(output) {
    const match = output.match(/restarts:\s*(\d+)/i);
    return match ? parseInt(match[1]) : 0;
  }

  extractUptime(output) {
    const match = output.match(/uptime:\s*([^\n]+)/i);
    if (match) {
      const uptimeStr = match[1].trim();
      // Convert uptime string to seconds
      if (uptimeStr.includes('d')) {
        const days = parseInt(uptimeStr.match(/(\d+)d/)?.[1] || 0);
        const hours = parseInt(uptimeStr.match(/(\d+)h/)?.[1] || 0);
        const minutes = parseInt(uptimeStr.match(/(\d+)m/)?.[1] || 0);
        const seconds = parseInt(uptimeStr.match(/(\d+)s/)?.[1] || 0);
        return days * 86400 + hours * 3600 + minutes * 60 + seconds;
      }
      return 0;
    }
    return 0;
  }

  extractStatus(output) {
    const match = output.match(/status:\s*(\w+)/i);
    return match ? match[1].toLowerCase() : "unknown";
  }

  async restartProcess(processName) {
    try {
      const attempts = this.restartAttempts.get(processName) || 0;
      
      if (attempts >= this.config.maxRestartAttempts) {
        this.log(`üö® Process ${processName} has exceeded max restart attempts (${attempts})`, "ERROR");
        return false;
      }

      this.log(`üîÑ Restarting process ${processName} (attempt ${attempts + 1})`);
      
      const result = await this.runCommand("pm2", ["restart", processName]);
      
      if (result.status === 0) {
        this.log(`‚úÖ Successfully restarted process ${processName}`);
        this.restartAttempts.set(processName, attempts + 1);
        
        // Wait before checking health
        await new Promise(resolve => setTimeout(resolve, this.config.restartDelay));
        
        // Check if restart was successful
        const health = await this.checkProcessHealth(processName);
        if (health.healthy) {
          this.log(`‚úÖ Process ${processName} is healthy after restart`);
          this.restartAttempts.delete(processName); // Reset counter on success
          return true;
        } else {
          this.log(`‚ö†Ô∏è Process ${processName} still unhealthy after restart`, "WARN");
          return false;
        }
      } else {
        this.log(`‚ùå Failed to restart process ${processName}: ${result.stderr}`, "ERROR");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
        this.restartAttempts.set(processName, attempts + 1);
        return false;
      }
    } catch (error) {
      this.log(`‚ùå Error restarting process ${processName}: ${error.message}`, "ERROR");
<<<<<<< HEAD
      this.restartAttempts.set(processName, attempts + 1);
      return false;
    }
  }

  async startProcess(processName) {
    this.log(`üöÄ Starting process: ${processName}`);
    try {
      const result = await this.runCommand("pm2", ["start", processName]);
      if (result.status === 0) {
        this.log(`‚úÖ Successfully started process: ${processName}`);
        return true;
      } else {
        this.log(`‚ùå Failed to start process: ${processName}`, "ERROR");
        return false;
      }
    } catch (error) {
      this.log(`‚ùå Error starting process ${processName}: ${error.message}`, "ERROR");
=======
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
      return false;
    }
  }

  async performComprehensiveHealthCheck() {
    this.log("üöÄ Starting comprehensive PM2 health check...");
    
    const results = {
      daemon: false,
<<<<<<< HEAD
      ecosystem: false,
      processes: {},
      summary: {
        total: this.config.allProcesses.length,
        healthy: 0,
        unhealthy: 0,
        restarted: 0
      },
=======
      ecosystems: {},
      processes: {},
      overall: false,
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
      timestamp: new Date().toISOString()
    };

    // Check PM2 daemon
    results.daemon = await this.checkPM2Daemon();
<<<<<<< HEAD
    if (!results.daemon) {
      this.log("‚ö†Ô∏è PM2 daemon unhealthy, attempting restart...", "WARN");
      results.daemon = await this.restartPM2Daemon();
    }

    // Validate ecosystem files
    const validEcosystems = await this.validateEcosystemFiles();
    results.ecosystem = validEcosystems.length > 0;

    // Check all processes
    for (const processName of this.config.allProcesses) {
      const processHealth = await this.checkProcessHealth(processName);
      results.processes[processName] = processHealth;
      
      if (processHealth.healthy) {
        results.summary.healthy++;
      } else {
        results.summary.unhealthy++;
        
        if (this.config.enableAutoRecovery) {
          if (processHealth.status === "not_found") {
            // Try to start the process
            const started = await this.startProcess(processName);
            if (started) results.summary.restarted++;
          } else {
            // Try to restart the process
            const restarted = await this.restartProcess(processName);
            if (restarted) results.summary.restarted++;
          }
=======
    
    // Check ecosystem files
    results.ecosystems = await this.checkEcosystemFiles();
    
    // Check each critical process
    const processResults = {};
    let healthyProcesses = 0;
    let totalProcesses = this.config.criticalProcesses.length;

    for (const processName of this.config.criticalProcesses) {
      const health = await this.checkProcessHealth(processName);
      processResults[processName] = health;
      
      if (health.healthy) {
        healthyProcesses++;
      } else if (this.config.autoRecovery) {
        // Attempt to restart unhealthy processes
        const restartSuccess = await this.restartProcess(processName);
        if (restartSuccess) {
          healthyProcesses++;
          processResults[processName].recovered = true;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
        }
      }
    }

<<<<<<< HEAD
    // Generate and log health report
    const healthReport = this.generateHealthReport(results);
    this.log(healthReport);

    // Save health report
    this.saveHealthReport(results);
=======
    results.processes = processResults;
    results.overall = results.daemon && healthyProcesses === totalProcesses;

    // Generate health summary
    this.log(`üìä PM2 Health Summary:`);
    this.log(`   Daemon: ${results.daemon ? '‚úÖ' : '‚ùå'}`);
    this.log(`   Ecosystems: ${results.ecosystems.valid.length}/${results.ecosystems.exists.length} valid`);
    this.log(`   Processes: ${healthyProcesses}/${totalProcesses} healthy`);
    this.log(`   Overall: ${results.overall ? '‚úÖ' : '‚ùå'}`);

    // Save health history
    this.healthHistory.push(results);
    if (this.healthHistory.length > 100) {
      this.healthHistory = this.healthHistory.slice(-100);
    }

    // Save detailed health report
    await this.saveHealthReport(results);
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f

    return results;
  }

<<<<<<< HEAD
  generateHealthReport(results) {
    const daemonStatus = results.daemon ? "‚úÖ HEALTHY" : "‚ùå UNHEALTHY";
    const ecosystemStatus = results.ecosystem ? "‚úÖ VALID" : "‚ùå INVALID";
    
    let processStatus = "";
    for (const [processName, health] of Object.entries(results.processes)) {
      const status = health.healthy ? "‚úÖ" : "‚ùå";
      processStatus += `${status} ${processName}: ${health.status}\n`;
    }

    return `
üìä ENHANCED PM2 HEALTH REPORT
==============================
Timestamp: ${results.timestamp}

üîß PM2 Daemon: ${daemonStatus}
üìã Ecosystem Files: ${ecosystemStatus}

üìä Process Health Summary:
Total Processes: ${results.summary.total}
Healthy: ${results.summary.healthy}
Unhealthy: ${results.summary.unhealthy}
Restarted: ${results.summary.restarted}

üîç Individual Process Status:
${processStatus}

${results.summary.healthy === results.summary.total ? 
  "üéâ All PM2 processes are healthy!" : 
  "‚ö†Ô∏è Some PM2 processes require attention. Check logs for details."}
`;
  }

  saveHealthReport(results) {
    try {
      const reportPath = path.join(this.logDir, `pm2-health-report-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      this.log(`üìù PM2 health report saved to ${reportPath}`);
    } catch (error) {
      this.log(`‚ùå Failed to save PM2 health report: ${error.message}`, "ERROR");
=======
  async saveHealthReport(results) {
    try {
      const reportPath = path.join(this.logDir, "pm2-health-report.json");
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      
      // Also save to logs directory
      const logReportPath = path.join(this.logDir, `pm2-health-${new Date().toISOString().split('T')[0]}.json`);
      fs.writeFileSync(logReportPath, JSON.stringify(results, null, 2));
      
      this.log(`üíæ Health report saved`);
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not save health report: ${error.message}`, "WARN");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    }
  }

  async startMonitoring() {
    if (this.monitoring) {
<<<<<<< HEAD
      this.log("‚ö†Ô∏è Monitoring is already running");
      return;
    }

    this.log("üöÄ Starting enhanced PM2 redundancy monitoring...");
    this.monitoring = true;

    // Initial health check
    await this.performComprehensiveHealthCheck();

    // Set up periodic monitoring
    this.checkInterval = setInterval(async () => {
      await this.performComprehensiveHealthCheck();
    }, this.config.healthCheckInterval);

    this.log("‚úÖ Enhanced PM2 redundancy monitoring started successfully");
=======
      this.log("‚ö†Ô∏è Monitoring is already running", "WARN");
      return;
    }

    this.log("üîç Starting enhanced PM2 redundancy monitoring...");
    this.monitoring = true;

    // Perform initial health check
    await this.performComprehensiveHealthCheck();

    // Start periodic monitoring
    this.checkInterval = setInterval(async () => {
      try {
        await this.performComprehensiveHealthCheck();
      } catch (error) {
        this.log(`‚ùå Monitoring cycle failed: ${error.message}`, "ERROR");
      }
    }, this.config.checkInterval);

    this.log(`‚úÖ Enhanced PM2 redundancy monitoring started with ${this.config.checkInterval}ms intervals`);
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
  }

  async stopMonitoring() {
    if (!this.monitoring) {
<<<<<<< HEAD
      this.log("‚ö†Ô∏è Monitoring is not running");
=======
      this.log("‚ö†Ô∏è Monitoring is not running", "WARN");
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
      return;
    }

    this.log("üõë Stopping enhanced PM2 redundancy monitoring...");
<<<<<<< HEAD
    this.monitoring = false;

=======
    
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
<<<<<<< HEAD

=======
    
    this.monitoring = false;
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    this.log("‚úÖ Enhanced PM2 redundancy monitoring stopped");
  }

  async emergencyRecovery() {
<<<<<<< HEAD
    this.log("üö® Starting emergency PM2 recovery...");
    
    try {
      // Kill all PM2 processes
      await this.runCommand("pm2", ["kill"]);
      
      // Restart PM2 daemon
      await this.runCommand("pm2", ["start"]);
      
      // Start all ecosystem files
      for (const ecosystemFile of this.config.ecosystemFiles) {
        if (fs.existsSync(ecosystemFile)) {
          await this.startEcosystemFile(ecosystemFile);
        }
      }
      
      this.log("‚úÖ Emergency PM2 recovery completed");
      return true;
    } catch (error) {
      this.log(`‚ùå Emergency PM2 recovery failed: ${error.message}`, "ERROR");
      return false;
    }
  }

  getStatus() {
    return {
      monitoring: this.monitoring,
      config: this.config,
      restartAttempts: Object.fromEntries(this.restartAttempts)
    };
  }
}

// Start the enhanced PM2 redundancy system
if (require.main === module) {
  const pm2Redundancy = new EnhancedPM2Redundancy();
  
  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\nüõë Shutting down enhanced PM2 redundancy system...');
    await pm2Redundancy.stopMonitoring();
=======
    this.log("üö® Emergency recovery mode activated...");
    
    try {
      // Stop monitoring temporarily
      await this.stopMonitoring();
      
      // Kill all PM2 processes
      await this.runCommand("pm2", ["kill"]);
      this.log("üîÑ Killed all PM2 processes");
      
      // Wait for cleanup
      await new Promise(resolve => setTimeout(resolve, 10000));
      
      // Start with primary ecosystem
      const primaryEcosystem = this.config.ecosystemFiles[0];
      if (fs.existsSync(primaryEcosystem)) {
        await this.runCommand("pm2", ["start", primaryEcosystem]);
        this.log(`üîÑ Started PM2 with ${primaryEcosystem}`);
      }
      
      // Save PM2 configuration
      await this.runCommand("pm2", ["save"]);
      this.log("üíæ Saved PM2 configuration");
      
      // Wait for processes to stabilize
      await new Promise(resolve => setTimeout(resolve, 15000));
      
      // Restart monitoring
      await this.startMonitoring();
      
      this.log("‚úÖ Emergency recovery completed");
    } catch (error) {
      this.log(`‚ùå Emergency recovery failed: ${error.message}`, "ERROR");
      
      // Try to restart monitoring anyway
      try {
        await this.startMonitoring();
      } catch (monitoringError) {
        this.log(`‚ùå Failed to restart monitoring: ${monitoringError.message}`, "ERROR");
      }
    }
  }

  getHealthHistory() {
    return this.healthHistory;
  }

  getRestartAttempts() {
    return Object.fromEntries(this.restartAttempts);
  }

  async cleanup() {
    this.log("üßπ Cleaning up enhanced PM2 redundancy...");
    
    try {
      await this.stopMonitoring();
      
      // Rotate logs if enabled
      if (this.config.logRotation) {
        await this.rotateLogs();
      }
      
      this.log("‚úÖ Cleanup completed");
    } catch (error) {
      this.log(`‚ùå Cleanup failed: ${error.message}`, "ERROR");
    }
  }

  async rotateLogs() {
    try {
      const logFiles = fs.readdirSync(this.logDir)
        .filter(file => file.startsWith('enhanced-pm2-redundancy'))
        .sort();

      // Remove old log files if we exceed maxLogFiles
      if (logFiles.length > this.config.maxLogFiles) {
        const filesToRemove = logFiles.slice(0, logFiles.length - this.config.maxLogFiles);
        
        for (const file of filesToRemove) {
          const filePath = path.join(this.logDir, file);
          fs.unlinkSync(filePath);
          this.log(`üóëÔ∏è Removed old log file: ${file}`);
        }
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Could not rotate logs: ${error.message}`, "WARN");
    }
  }
}

// Start the enhanced PM2 redundancy monitor if run directly
if (require.main === module) {
  const monitor = new EnhancedPM2Redundancy();
  
  // Handle process signals
  process.on('SIGINT', async () => {
    console.log('\nüõë Received SIGINT, shutting down gracefully...');
    await monitor.cleanup();
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
    process.exit(0);
  });
  
  process.on('SIGTERM', async () => {
<<<<<<< HEAD
    console.log('\nüõë Terminating enhanced PM2 redundancy system...');
    await pm2Redundancy.stopMonitoring();
    process.exit(0);
  });

  // Start monitoring
  pm2Redundancy.startMonitoring();
=======
    console.log('\nüõë Received SIGTERM, shutting down gracefully...');
    await monitor.cleanup();
    process.exit(0);
  });
  
  // Start monitoring
  monitor.startMonitoring().catch(error => {
    console.error('‚ùå Failed to start monitoring:', error);
    process.exit(1);
  });
>>>>>>> origin/cursor/automate-deployment-redundancy-and-clean-up-405f
}

module.exports = EnhancedPM2Redundancy;