exports.handler = async function(event, context) {
  const githubToken = process.env.GITHUB_TOKEN || '';
  const githubRepo = process.env.GITHUB_REPO || 'Zion-Holdings/zion.app';
  const githubBranch = process.env.GIT_BRANCH || 'main';
  const filePath = '_redirects';
  const csvPath = 'link_report.csv';

  function log(msg) { console.log(`[smart-redirects] ${msg}`); }

  async function readFileLocal(path) {
    try {
      const fs = require('fs');
      return fs.readFileSync(require('path').join(process.cwd(), path), 'utf8');
    } catch (_) { return ''; }
  }

  function parseCsvLoose(csvText) {
    const lines = csvText.split(/\r?\n/).filter(l => l.trim().length > 0);
    if (lines.length === 0) return { headers: [], rows: [] };
    const headers = lines[0].split(',').map(h => h.trim());
    const rows = [];
    for (let i = 1; i < lines.length; i += 1) {
      const cols = lines[i].split(',');
      if (cols.length < headers.length) continue;
      const row = {};
      headers.forEach((h, idx) => row[h] = (cols[idx] || '').trim());
      rows.push(row);
    }
    return { headers, rows };
  }

  function urlPath(href) {
    try { return new URL(href).pathname; } catch { return ''; }
  }

  function suggestTarget(fromPath) {
    if (!fromPath || fromPath === '/') return '/';
    if (fromPath.startsWith('/services')) return '/automation';
    if (fromPath.startsWith('/products')) return '/automation';
    if (fromPath.startsWith('/contact')) return '/automation';
    if (fromPath.startsWith('/blog')) return '/newsroom';
    // Fallback to main front hub
    return '/main/front';
  }

  function normalizeRedirectLine(line) {
    return line.replace(/\s+/g, ' ').trim();
  }

  function buildRedirectLinesFromCsv(csvText) {
    const { rows } = parseCsvLoose(csvText);
    const suggestions = new Set();
    for (const r of rows) {
      const status = parseInt(r.status_code || '0', 10);
      const isInternal = String(r.is_internal || '').toLowerCase() === 'true';
      if (isInternal && status === 404) {
        const fromPath = urlPath(r.link_url || r.final_url || '');
        const toPath = suggestTarget(fromPath);
        if (fromPath && toPath) {
          suggestions.add(`${fromPath} ${toPath} 301`);
        }
      }
    }
    return Array.from(suggestions).map(normalizeRedirectLine).sort();
  }

  async function githubGetFileSha(path) {
    if (!githubToken) return { ok: false };
    const headers = {
      Authorization: `token ${githubToken}`,
      'Content-Type': 'application/json',
      'User-Agent': 'smart-redirects-function'
    };
    try {
      const res = await fetch(`https://api.github.com/repos/${githubRepo}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(githubBranch)}`, { headers });
      if (!res.ok) return { ok: false, status: res.status };
      const json = await res.json();
      return { ok: true, sha: json.sha, contentB64: json.content };
    } catch (e) {
      return { ok: false, error: String(e) };
    }
  }

  async function githubPutFile(path, contentText, message, sha) {
    if (!githubToken) return { ok: false };
    const headers = {
      Authorization: `token ${githubToken}`,
      'Content-Type': 'application/json',
      'User-Agent': 'smart-redirects-function'
    };
    const body = {
      message,
      content: Buffer.from(contentText, 'utf8').toString('base64'),
      branch: githubBranch,
      sha
    };
    try {
      const res = await fetch(`https://api.github.com/repos/${githubRepo}/contents/${encodeURIComponent(path)}`, {
        method: 'PUT', headers, body: JSON.stringify(body)
      });
      const ok = res.ok; const status = res.status;
      let error; if (!ok) { try { error = await res.text(); } catch (e) { error = String(e); } }
      return { ok, status, error };
    } catch (e) {
      return { ok: false, error: String(e) };
    }
  }

  function mergeRedirects(existingText, newLines) {
    const out = new Set();
    const header = '# Autogenerated by smart-redirects (managed)';
    if (existingText) {
      existingText.split(/\r?\n/).forEach(l => {
        const t = l.trim(); if (t) out.add(t);
      });
    }
    out.add(header);
    for (const l of newLines) out.add(l);
    // Ensure trailing newline
    return Array.from(out).join('\n') + '\n';
  }

  try {
    const csvText = await readFileLocal(csvPath);
    if (!csvText) {
      return { statusCode: 200, body: JSON.stringify({ message: 'No link_report.csv found; nothing to do.' }) };
    }
    const newRedirects = buildRedirectLinesFromCsv(csvText);

    let existingText = '';
    let sha;
    const getRes = await githubGetFileSha(filePath);
    if (getRes.ok && getRes.sha) {
      sha = getRes.sha;
      try {
        if (getRes.contentB64) existingText = Buffer.from(getRes.contentB64, 'base64').toString('utf8');
      } catch {}
    }

    const merged = mergeRedirects(existingText, newRedirects);
    const message = `chore(redirects): heal internal 404s via smart-redirects (${new Date().toISOString()})`;
    const putRes = await githubPutFile(filePath, merged, message, sha);

    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        generatedAt: new Date().toISOString(),
        added: newRedirects.length,
        updated: putRes.ok,
        status: putRes.status,
        error: putRes.error || null,
        filePath
      })
    };
  } catch (err) {
    log(String(err));
    return { statusCode: 500, body: JSON.stringify({ error: String(err) }) };
  }
};