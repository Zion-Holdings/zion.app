#!/usr/bin/env node

'use strict';

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const ROOT = path.resolve(__dirname, '..', '..');
const PAGES_DIR = path.join(ROOT, 'pages');
const COMPONENTS_DIR = path.join(ROOT, 'components');
const LOGS_DIR = path.join(ROOT, 'automation', 'logs');

function ensureDir(dir) {
  try { fs.mkdirSync(dir, { recursive: true }); } catch (_) {}
}

function log(message) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${message}`);
}

function scanMarketingContent() {
  const content = {
    pages: [],
    components: [],
    features: []
  };
  
  try {
    // Scan pages for marketing content
    if (fs.existsSync(PAGES_DIR)) {
      const scanDirectory = (dir, basePath = '') => {
        if (!fs.existsSync(dir)) return;
        
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        
        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);
          const relativePath = path.join(basePath, entry.name);
          
          if (entry.isDirectory()) {
            scanDirectory(fullPath, relativePath);
          } else if (entry.name.endsWith('.tsx') || entry.name.endsWith('.jsx') || entry.name.endsWith('.js')) {
            const fileContent = fs.readFileSync(fullPath, 'utf8');
            
            // Look for marketing-related content
            if (fileContent.includes('marketing') || fileContent.includes('promo') || fileContent.includes('feature')) {
              content.pages.push({
                name: entry.name,
                path: relativePath,
                size: fs.statSync(fullPath).size,
                hasMarketing: true
              });
            }
          }
        }
      };
      
      scanDirectory(PAGES_DIR);
    }
    
    // Scan components for features
    if (fs.existsSync(COMPONENTS_DIR)) {
      const scanDirectory = (dir, basePath = '') => {
        if (!fs.existsSync(dir)) return;
        
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        
        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);
          const relativePath = path.join(basePath, entry.name);
          
          if (entry.isDirectory()) {
            scanDirectory(fullPath, relativePath);
          } else if (entry.name.endsWith('.tsx') || entry.name.endsWith('.jsx') || entry.name.endsWith('.js')) {
            const fileContent = fs.readFileSync(fullPath, 'utf8');
            
            // Look for feature-related content
            if (fileContent.includes('feature') || fileContent.includes('capability') || fileContent.includes('benefit')) {
              content.components.push({
                name: entry.name,
                path: relativePath,
                size: fs.statSync(fullPath).size,
                hasFeatures: true
              });
            }
          }
        }
      };
      
      scanDirectory(COMPONENTS_DIR);
    }
    
  } catch (error) {
    log(`Error scanning marketing content: ${error.message}`);
  }
  
  return content;
}

function generateMarketingIndex(content) {
  try {
    const indexContent = `// Auto-generated marketing and features index
// Generated: ${new Date().toISOString()}

export const marketingPages = ${JSON.stringify(content.pages, null, 2)};

export const featureComponents = ${JSON.stringify(content.components, null, 2)};

export function getMarketingPage(name) {
  return marketingPages.find(p => p.name === name);
}

export function getFeatureComponent(name) {
  return featureComponents.find(c => c.name === name);
}

export function getAllMarketingContent() {
  return {
    pages: marketingPages,
    components: featureComponents,
    totalPages: marketingPages.length,
    totalComponents: featureComponents.length
  };
}
`;
    
    const indexPath = path.join(ROOT, 'marketing-index.ts');
    fs.writeFileSync(indexPath, indexContent, 'utf8');
    log('‚úÖ Marketing index generated');
    return true;
  } catch (error) {
    log(`‚ùå Error generating marketing index: ${error.message}`);
    return false;
  }
}

function generatePromoContent(content) {
  try {
    const promoContent = `# Marketing and Features Promo

Generated: ${new Date().toISOString()}

## Marketing Pages (${content.pages.length})

${content.pages.map(page => `- **${page.name}** - ${page.path}`).join('\n')}

## Feature Components (${content.components.length})

${content.components.map(comp => `- **${comp.name}** - ${comp.path}`).join('\n')}

## Summary

- Total Marketing Pages: ${content.pages.length}
- Total Feature Components: ${content.components.length}
- Last Updated: ${new Date().toISOString()}

This content is automatically generated by the Netlify function \`marketing-and-features-promo\`.
`;
    
    const promoPath = path.join(ROOT, 'MARKETING_PROMO.md');
    fs.writeFileSync(promoPath, promoContent, 'utf8');
    log('‚úÖ Promo content generated');
    return true;
  } catch (error) {
    log(`‚ùå Error generating promo content: ${error.message}`);
    return false;
  }
}

function commitChanges() {
  try {
    const gitStatus = execSync('git status --porcelain', { encoding: 'utf8' }).trim();
    
    if (gitStatus) {
      execSync('git add .', { stdio: 'inherit' });
      execSync('git commit -m "ü§ñ Update marketing and features promo via Netlify function [skip ci]"', { stdio: 'inherit' });
      execSync('git push', { stdio: 'inherit' });
      log('‚úÖ Changes committed and pushed');
      return { success: true, changes: gitStatus.split('\n').length };
    } else {
      log('No changes to commit');
      return { success: true, changes: 0 };
    }
  } catch (error) {
    log(`‚ùå Git commit failed: ${error.message}`);
    return { success: false, error: error.message };
  }
}

// Netlify function handler
exports.handler = async function(event, context) {
  try {
    log('ü§ñ Starting marketing-and-features-promo function...');
    
    ensureDir(LOGS_DIR);
    
    // Scan marketing content
    const content = scanMarketingContent();
    log(`Found ${content.pages.length} marketing pages and ${content.components.length} feature components`);
    
    // Generate marketing index
    const indexGenerated = generateMarketingIndex(content);
    
    // Generate promo content
    const promoGenerated = generatePromoContent(content);
    
    // Commit changes
    const commitResult = commitChanges();
    
    // Generate report
    const report = {
      timestamp: new Date().toISOString(),
      function: 'marketing-and-features-promo',
      status: 'completed',
      summary: {
        marketingPages: content.pages.length,
        featureComponents: content.components.length,
        indexGenerated: indexGenerated,
        promoGenerated: promoGenerated,
        gitChanges: commitResult.changes || 0
      },
      content: {
        pages: content.pages.map(p => ({
          name: p.name,
          path: p.path,
          size: p.size
        })),
        components: content.components.map(c => ({
          name: c.name,
          path: c.path,
          size: c.size
        }))
      },
      gitResult: commitResult
    };
    
    // Write report
    const reportPath = path.join(LOGS_DIR, 'marketing-features-promo-report.json');
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    log('‚úÖ marketing-and-features-promo completed successfully');
    
    return {
      statusCode: 200,
      body: JSON.stringify(report)
    };
    
  } catch (error) {
    log(`‚ùå marketing-and-features-promo function failed: ${error.message}`);
    
    const errorReport = {
      timestamp: new Date().toISOString(),
      function: 'marketing-and-features-promo',
      status: 'failed',
      error: error.message,
      stack: error.stack
    };
    
    // Write error report
    try {
      const errorPath = path.join(LOGS_DIR, 'marketing-features-promo-error.json');
      fs.writeFileSync(errorPath, JSON.stringify(errorReport, null, 2));
    } catch (writeError) {
      log(`Failed to write error report: ${writeError.message}`);
    }
    
    return {
      statusCode: 500,
      body: JSON.stringify(errorReport)
    };
  }
};