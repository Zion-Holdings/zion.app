<<<<<<< HEAD
const path = require('path');
const fs = require('fs');
const { spawnSync } = require('child_process');

function runNode(relPath, args = []) {
  const abs = path.resolve(__dirname, '..', '..', relPath);
  const res = spawnSync('node', [abs, ...args], { stdio: 'pipe', encoding: 'utf8' });
  return { status: res.status || 0, stdout: res.stdout || '', stderr: res.stderr || '' };
}

function collectFiles(root, patterns) {
  const results = [];
  function walk(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const e of entries) {
      const full = path.join(dir, e.name);
      if (e.isDirectory()) {
        walk(full);
      } else {
        const rel = path.relative(root, full);
        if (patterns.some((p) => rel.startsWith(p.dir) && rel.endsWith(p.ext))) {
          results.push(full);
        }
      }
    }
  }
  walk(root);
  return results;
}

function getLastModifiedIso(filePath) {
  try {
    // Prefer git last commit time if available
    const gitRes = spawnSync('git', ['log', '-1', '--format=%cI', '--', filePath], { encoding: 'utf8' });
    const out = (gitRes.stdout || '').trim();
    if (out) return out;
  } catch (e) {
    if (process.env.DEBUG) console.warn('git log failed', e);
    void e;
  }
  try {
    const stat = fs.statSync(filePath);
    return new Date(stat.mtimeMs).toISOString();
  } catch (e) {
    if (process.env.DEBUG) console.warn('stat failed', e);
    void e;
    return null;
  }
}

exports.handler = async () => {
  const logs = [];
  function log(msg) { if (msg) logs.push(String(msg)); }

  // Simple stale detector: lists files not modified in > 90 days
  const cutoffDays = Number(process.env.STALE_CUTOFF_DAYS || 90);
  const cutoffMs = cutoffDays * 24 * 60 * 60 * 1000;
  const now = Date.now();

  function listFiles(dir, acc = []) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.name.startsWith('.git')) continue;
      const full = path.join(dir, entry.name);
      if (entry.isDirectory()) listFiles(full, acc);
      else acc.push(full);
    }
    return acc;
  }

  findings.sort((a, b) => b.ageDays - a.ageDays);

  const dataDir = path.join(root, 'data', 'reports', 'stale-content');
  const publicDir = path.join(root, 'public', 'reports', 'stale-content');
  try { fs.mkdirSync(dataDir, { recursive: true }); } catch (err) { void err; }
  try { fs.mkdirSync(publicDir, { recursive: true }); } catch (err) { void err; }

  const json = {
    generatedAt: new Date().toISOString(),
    totals: {
      count: findings.length,
      byGroup: findings.reduce((acc, f) => { acc[f.group] = (acc[f.group] || 0) + 1; return acc; }, {})
    },
    thresholds,
    findings,
  };
  const jsonPath = path.join(dataDir, `stale-content-${new Date().toISOString().replace(/[:.]/g, '-')}.json`);
  fs.writeFileSync(jsonPath, JSON.stringify(json, null, 2));

  const latestPublic = path.join(publicDir, 'latest.json');
  fs.writeFileSync(latestPublic, JSON.stringify(json, null, 2));

  const mdPath = path.join(root, 'docs', 'reports', 'stale-content.md');
  try { fs.mkdirSync(path.dirname(mdPath), { recursive: true }); } catch (err) { void err; }
  const md = [
    '# Stale Content Report',
    '',
    `Generated: ${json.generatedAt}`,
    '',
    `Total stale items: ${json.totals.count}`,
    '',
    '| Group | Count |',
    '|-------|------:|',
    ...Object.entries(json.totals.byGroup).map(([k,v]) => `| ${k} | ${v} |`),
    '',
    '| File | Last Modified | Age (days) | Threshold |',
    '|------|---------------|-----------:|----------:|',
    ...findings.map(f => `| ${f.file} | ${f.lastModified} | ${f.ageDays} | ${f.thresholdDays} |`),
    '',
    `Public JSON: /reports/stale-content/latest.json`,
  ].join('\n');
  fs.writeFileSync(mdPath, md);

  log(`Wrote stale content report: ${jsonPath}`);
  log(`Updated public: ${latestPublic}`);

  // Commit and push changes
  try {
    const sync = runNode('automation/advanced-git-sync.cjs');
    log(sync.stdout || '');
    if (sync.stderr) log(sync.stderr);
  } catch (e) {
    log(`git sync error: ${e.message}`);
  }

  const reportDir = path.resolve(__dirname, '..', '..', 'public', 'automation');
  fs.mkdirSync(reportDir, { recursive: true });
  const reportPath = path.join(reportDir, 'stale-content-report.json');
  fs.writeFileSync(reportPath, JSON.stringify({ generatedAt: new Date().toISOString(), cutoffDays, total: stale.length, stale }, null, 2));
  log(`Saved report to ${reportPath}`);

  // Optional: also run existing scanners
  runNode('automation/todo-scanner.cjs');

  // Commit and push via advanced git sync
  runNode('automation/advanced-git-sync.cjs');

  return { statusCode: 200, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ok: true, total: stale.length }) };
};
=======
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function sh(cmd) {
  return execSync(cmd, { stdio: ['ignore', 'pipe', 'pipe'], encoding: 'utf8', shell: true }).toString();
}

function safeMkdirp(dirPath) {
  fs.mkdirSync(dirPath, { recursive: true });
}

function getTrackedFiles(globs) {
  const files = sh('git ls-files').split('\n').filter(Boolean);
  if (!globs || globs.length === 0) return files;
  const regexes = globs.map((g) => new RegExp(g.replace(/[.+^${}()|[\]\\]/g, r => r).replace(/\*/g, '.*')));
  return files.filter((f) => regexes.some((rx) => rx.test(f)));
}

function getLastCommitEpochForFile(filePath) {
  try {
    const out = sh(`git log -1 --format=%ct -- ${JSON.stringify(filePath)}`).trim();
    return out ? parseInt(out, 10) : 0;
  } catch {
    return 0;
  }
}

function daysBetween(epochSeconds) {
  if (!epochSeconds) return Number.POSITIVE_INFINITY;
  const ms = (Date.now() - epochSeconds * 1000);
  return Math.floor(ms / (1000 * 60 * 60 * 24));
}

function renderHtml(data) {
  const rows = data.map((d) => `<tr><td style="padding:8px;border-bottom:1px solid #222">${d.path}</td><td style="padding:8px;border-bottom:1px solid #222">${d.days}</td><td style="padding:8px;border-bottom:1px solid #222">${new Date(d.lastCommitEpoch*1000).toISOString()}</td></tr>`).join('');
  return `<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Stale Content Auditor</title>
<style>body{background:#0b1220;color:#e5e7eb;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif} a{color:#67e8f9} .wrap{max-width:960px;margin:32px auto;padding:0 16px}</style></head>
<body><div class="wrap"><h1>Stale Content Auditor</h1><p>Files not updated recently. Generated autonomously.</p>
<table style="width:100%;border-collapse:collapse;margin-top:16px"><thead><tr><th style="text-align:left;padding:8px;border-bottom:2px solid #333">Path</th><th style="text-align:left;padding:8px;border-bottom:2px solid #333">Age (days)</th><th style="text-align:left;padding:8px;border-bottom:2px solid #333">Last Commit</th></tr></thead><tbody>${rows}</tbody></table>
<p style="margin-top:16px">JSON: <a href="./report.json">report.json</a></p></div></body></html>`;
}

function run(cmd) {
  execSync(cmd, { stdio: 'inherit', shell: true });
}

exports.config = { schedule: '0 */6 * * *' };

exports.handler = async () => {
  try {
    const includeGlobs = [
      '^(pages/|components/|docs/|public/).+',
      '\\.(md|mdx|tsx|ts|jsx|js|json|html|css)$'
    ];

    const files = getTrackedFiles([]).filter((f) => new RegExp(includeGlobs[0]).test(f) && new RegExp(includeGlobs[1]).test(f));
    const staleThresholdDays = parseInt(process.env.STALE_DAYS || '90', 10);

    const report = files.map((filePath) => {
      const lastCommitEpoch = getLastCommitEpochForFile(filePath);
      const ageDays = daysBetween(lastCommitEpoch);
      return { path: filePath, lastCommitEpoch, days: ageDays };
    }).filter((r) => r.days >= staleThresholdDays)
      .sort((a, b) => b.days - a.days)
      .slice(0, 500);

    const outDir = path.join(process.cwd(), 'public', 'reports', 'stale');
    safeMkdirp(outDir);
    fs.writeFileSync(path.join(outDir, 'report.json'), JSON.stringify({ generatedAt: new Date().toISOString(), thresholdDays: staleThresholdDays, total: report.length, items: report }, null, 2));
    fs.writeFileSync(path.join(outDir, 'index.html'), renderHtml(report), 'utf8');

    // Sync changes back to repo
    run('node automation/advanced-git-sync.cjs || true');

    return { statusCode: 200, body: JSON.stringify({ ok: true, tool: 'stale-content-auditor-runner', items: report.length }) };
  } catch (e) {
    return { statusCode: 200, body: JSON.stringify({ ok: false, error: String(e) }) };
  }
};
>>>>>>> origin/cursor/invent-and-deploy-autonomous-cloud-automations-b49a
