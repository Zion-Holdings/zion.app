#!/usr/bin/env node
import fs from 'fs';
import path from 'path';

function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) fs.mkdirSync(dirPath, { recursive: true });
}

function getRepoFromEnv() {
  const envRepo = process.env.GITHUB_REPOSITORY; // owner/repo
  if (envRepo) {
    const [owner, repo] = envRepo.split('/');
    return { owner, repo };
  }
  const repoUrl = require('../package.json').repository?.url || '';
  const match = repoUrl.match(/github.com\/(.+?)\/(.+?)\.git$/i);
  return { owner: match ? match[1] : '', repo: match ? match[2] : '' };
}

async function gh(endpoint) {
  const { owner, repo } = getRepoFromEnv();
  const url = `https://api.github.com/repos/${owner}/${repo}${endpoint}`;
  const headers = { 'User-Agent': 'zion-autonomy', 'Accept': 'application/vnd.github+json' };
  if (process.env.GITHUB_TOKEN) headers['Authorization'] = `token ${process.env.GITHUB_TOKEN}`;
  const res = await fetch(url, { headers });
  if (!res.ok) throw new Error(`GitHub API ${endpoint} failed: ${res.status}`);
  return res.json();
}

async function fetchIssues() {
  try {
    const issues = await gh('/issues?state=open&per_page=50');
    return issues.filter((i) => !i.pull_request).map((i) => ({
      id: i.number,
      title: i.title,
      url: i.html_url,
      labels: (i.labels || []).map((l) => (typeof l === 'string' ? l : l.name)),
    }));
  } catch {
    return [];
  }
}

async function fetchRecentCommits() {
  try {
    const commits = await gh('/commits?per_page=20');
    return commits.map((c) => ({
      sha: c.sha.substring(0, 7),
      msg: c.commit.message.split('\n')[0],
      url: c.html_url,
    }));
  } catch {
    return [];
  }
}

function renderRoadmap(issues, commits) {
  const now = new Date().toISOString();
  const lines = [];
  lines.push(`# Zion OS Roadmap (Autonomous)`);
  lines.push('');
  lines.push(`Last updated: ${now}`);
  lines.push('');
  lines.push('## Focus Queue (Open Issues)');
  if (issues.length === 0) lines.push('- No open issues found');
  for (const i of issues) {
    const labels = i.labels && i.labels.length ? ` [${i.labels.join(', ')}]` : '';
    lines.push(`- #${i.id}${labels}: ${i.title} (${i.url})`);
  }
  lines.push('');
  lines.push('## Latest Changes (Commits)');
  if (commits.length === 0) lines.push('- No recent commits found');
  for (const c of commits) {
    lines.push(`- ${c.sha}: ${c.msg} (${c.url})`);
  }
  lines.push('');
  lines.push('> Generated by Autonomous Roadmap Synthesizer');
  return lines.join('\n');
}

async function main() {
  const issues = await fetchIssues();
  const commits = await fetchRecentCommits();
  const md = renderRoadmap(issues, commits);
  ensureDir(path.join(process.cwd(), 'docs'));
  fs.writeFileSync(path.join(process.cwd(), 'docs', 'ROADMAP.md'), md, 'utf8');

  const snapshot = {
    generatedAt: new Date().toISOString(),
    issuesCount: issues.length,
    commitsCount: commits.length,
  };
  ensureDir(path.join(process.cwd(), 'automation_logs'));
  const id = new Date().toISOString().replace(/[:.]/g, '-').toLowerCase();
  fs.writeFileSync(path.join(process.cwd(), 'automation_logs', `roadmap-${id}.json`), JSON.stringify(snapshot, null, 2));
  console.log('Updated docs/ROADMAP.md and wrote snapshot');
}

main();