// scripts/check_coverage_and_notify.js
const fs = require('fs');
const path = require('path');

const COVERAGE_THRESHOLD = 80; // Example threshold

// Output file for gather-notification-data.sh
const TEMP_DATA_DIR = path.resolve(process.env.GITHUB_WORKSPACE || '/tmp', 'notification_data');
const TEST_STATUS_FILE = path.join(TEMP_DATA_DIR, 'test_status.json');

// Expected path for Jest JSON output (to be generated by run-hourly-tests.sh or similar)
// This path should be relative to the project root or an absolute path if more appropriate.
// Assuming scripts are in /scripts, logs in /logs
const JEST_RESULTS_FILE = path.resolve(__dirname, '../logs/tests/hourly-jest-results.json');


function main() {
  const coverageSummaryPath = process.argv[2];
  if (!coverageSummaryPath) {
    console.error('Error: Coverage summary JSON path not provided.');
    // Try to write status even on early exit, to indicate failure cause
    writeTestStatus({ passed: 0, failed: 0, total: 0, coverage: 0, error: 'Coverage summary path missing' });
    process.exit(1);
  }

  let coverageData;
  try {
    coverageData = JSON.parse(fs.readFileSync(coverageSummaryPath, 'utf-8'));
  } catch (err) {
    console.error(`Error: Could not read or parse coverage summary at ${coverageSummaryPath}`, err);
    writeTestStatus({ passed: 0, failed: 0, total: 0, coverage: 0, error: `Failed to parse coverage summary: ${err.message}` });
    process.exit(1); // Exit, as coverage check is a primary function
  }

  // Extract coverage percentage (e.g., lines)
  const coveragePct = coverageData.total && coverageData.total.lines ? coverageData.total.lines.pct : 0;

  let jestResultsData = { numPassedTests: 0, numFailedTests: 0, numTotalTests: 0 };
  let testCountsError = null; // To store any error/warning message regarding test counts

  try {
    if (fs.existsSync(JEST_RESULTS_FILE)) {
      const jestOutput = JSON.parse(fs.readFileSync(JEST_RESULTS_FILE, 'utf-8'));
      jestResultsData = {
        numPassedTests: jestOutput.numPassedTests || 0,
        numFailedTests: jestOutput.numFailedTests || 0,
        numTotalTests: jestOutput.numTotalTests || 0,
      };
    } else {
      testCountsError = `Jest results file not found at ${JEST_RESULTS_FILE}. Test counts set to zero.`;
      console.warn(testCountsError);
    }
  } catch (err) {
    testCountsError = `Error parsing Jest results file ${JEST_RESULTS_FILE}: ${err.message}. Test counts set to zero.`;
    console.error(testCountsError);
  }

  const testStatusPayload = {
    passed: jestResultsData.numPassedTests,
    failed: jestResultsData.numFailedTests,
    total: jestResultsData.numTotalTests,
    coverage: coveragePct,
  };

  // If there was an issue with test counts, add it as an 'error' field in the status.
  // The TestStatusInfo interface doesn't have 'error', so we log it instead,
  // and the gather-notification-data.sh might need to be aware if testStatus is partial.
  // For strictness with current TestStatusInfo, we won't add extra fields.
  // The gather-notification-data.sh will take what it gets.
  if (testCountsError) {
    // This error is logged to console; the payload will just have 0s for counts.
  }

  writeTestStatus(testStatusPayload);

  console.log(`Coverage: ${coveragePct}% (Threshold: ${COVERAGE_THRESHOLD}%)`);
  if (coveragePct < COVERAGE_THRESHOLD) {
    console.error(`Error: Coverage (${coveragePct}%) is below threshold of ${COVERAGE_THRESHOLD}%.`);
    process.exit(1);
  } else {
    console.log('Coverage check passed.');
  }
}

function writeTestStatus(statusData) {
  try {
    fs.mkdirSync(TEMP_DATA_DIR, { recursive: true });
    // Ensure statusData always conforms to TestStatusInfo, even if there was an error string previously.
    const finalPayload = {
        passed: statusData.passed || 0,
        failed: statusData.failed || 0,
        total: statusData.total || 0,
        coverage: statusData.coverage || 0,
    };
    // If an error was part of statusData and needs to be recorded, it should be logged
    // or TestStatusInfo interface should be updated. For now, ensure clean payload.
    if (statusData.error) {
        console.error(`Error context for test_status.json: ${statusData.error}`);
        // Optionally, could add the error to the payload if interface allowed:
        // finalPayload.error = statusData.error;
    }

    fs.writeFileSync(TEST_STATUS_FILE, JSON.stringify(finalPayload, null, 2));
    console.log(`Test status written to ${TEST_STATUS_FILE}`);
  } catch (err) {
    console.error(`Error writing test status to ${TEST_STATUS_FILE}:`, err);
    // If this write fails, the gather script won't find the file.
  }
}

// Ensure any unhandled promise rejections are caught
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  // Attempt to write a status indicating this script itself failed.
  writeTestStatus({
    passed: 0, failed: 0, total: 0, coverage: 0,
    error: 'Unhandled rejection in check_coverage_and_notify.js'
  });
  process.exit(1);
});

main();
