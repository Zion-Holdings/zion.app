#!/usr/bin/env node

/**
 * Cursor AI Installer
 * 
 * This script installs and configures AI assistants on multiple computers
 * with Cursor installed for distributed continuous improvement.
 */

const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');
const os = require('os');
const crypto = require('crypto');

// Configuration
const INSTALL_CONFIG = {
  // AI assistants to install
  aiAssistants: [
    {
      name: 'code-analyzer',
      description: 'Analyzes code quality and suggests improvements',
      commands: [
        'npm install -g @cursor/code-analyzer',
        'cursor --install-extension code-analyzer'
      ],
      config: {
        autoAnalyze: true,
        suggestImprovements: true,
        performanceOptimization: true
      }
    },
    {
      name: 'security-scanner',
      description: 'Scans for security vulnerabilities',
      commands: [
        'npm install -g @cursor/security-scanner',
        'cursor --install-extension security-scanner'
      ],
      config: {
        autoScan: true,
        vulnerabilityAlerts: true,
        dependencyAnalysis: true
      }
    },
    {
      name: 'performance-optimizer',
      description: 'Optimizes application performance',
      commands: [
        'npm install -g @cursor/performance-optimizer',
        'cursor --install-extension performance-optimizer'
      ],
      config: {
        autoOptimize: true,
        bundleAnalysis: true,
        memoryProfiling: true
      }
    },
    {
      name: 'test-generator',
      description: 'Generates and maintains tests',
      commands: [
        'npm install -g @cursor/test-generator',
        'cursor --install-extension test-generator'
      ],
      config: {
        autoGenerateTests: true,
        testCoverage: true,
        testMaintenance: true
      }
    },
    {
      name: 'documentation-generator',
      description: 'Generates and maintains documentation',
      commands: [
        'npm install -g @cursor/doc-generator',
        'cursor --install-extension doc-generator'
      ],
      config: {
        autoGenerateDocs: true,
        apiDocumentation: true,
        readmeMaintenance: true
      }
    }
  ],
  
  // Cursor configuration
  cursorConfig: {
    enableAI: true,
    autoSave: true,
    autoFormat: true,
    lintOnSave: true,
    testOnSave: true,
    continuousImprovement: true
  },
  
  // Network configuration
  networkConfig: {
    discoveryPort: 3001,
    communicationPort: 3002,
    heartbeatInterval: 30000
  }
};

class CursorAIInstaller {
  constructor() {
    this.installedAssistants = new Map();
    this.targetComputers = new Map();
    this.installationLog = [];
  }

  async installOnLocalComputer() {
    console.log('Installing AI assistants on local computer...');
    
    try {
      // Check if Cursor is installed
      if (!this.isCursorInstalled()) {
        throw new Error('Cursor is not installed on this computer');
      }
      
      // Install each AI assistant
      for (const assistant of INSTALL_CONFIG.aiAssistants) {
        await this.installAssistant(assistant);
      }
      
      // Configure Cursor
      await this.configureCursor();
      
      // Start AI services
      await this.startAIServices();
      
      console.log('âœ… AI assistants installed successfully on local computer');
      
    } catch (error) {
      console.error('âŒ Failed to install AI assistants:', error.message);
      throw error;
    }
  }

  async installOnRemoteComputers(computerList) {
    console.log(`Installing AI assistants on ${computerList.length} remote computers...`);
    
    const results = [];
    
    for (const computer of computerList) {
      try {
        console.log(`Installing on ${computer.hostname} (${computer.ip})...`);
        
        const result = await this.installOnRemoteComputer(computer);
        results.push({ computer, success: true, result });
        
        console.log(`âœ… Installed on ${computer.hostname}`);
        
      } catch (error) {
        console.error(`âŒ Failed to install on ${computer.hostname}:`, error.message);
        results.push({ computer, success: false, error: error.message });
      }
    }
    
    return results;
  }

  async installOnRemoteComputer(computer) {
    // Create installation script
    const installScript = this.generateInstallScript();
    const scriptPath = `/tmp/cursor_ai_install_${Date.now()}.sh`;
    
    try {
      // Upload installation script
      await this.uploadFile(installScript, scriptPath, computer.ip);
      
      // Execute installation
      const result = await this.executeRemoteCommand(computer.ip, `bash ${scriptPath}`);
      
      // Cleanup
      await this.executeRemoteCommand(computer.ip, `rm -f ${scriptPath}`);
      
      return result;
      
    } catch (error) {
      throw new Error(`Remote installation failed: ${error.message}`);
    }
  }

  generateInstallScript() {
    const script = `#!/bin/bash
set -e

echo "Installing Cursor AI assistants..."

# Update package manager
if command -v apt-get &> /dev/null; then
    sudo apt-get update
elif command -v yum &> /dev/null; then
    sudo yum update -y
elif command -v brew &> /dev/null; then
    brew update
fi

# Install Node.js if not present
if ! command -v node &> /dev/null; then
    echo "Installing Node.js..."
    if command -v curl &> /dev/null; then
        curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
        sudo apt-get install -y nodejs
    elif command -v brew &> /dev/null; then
        brew install node
    fi
fi

# Install AI assistants
${INSTALL_CONFIG.aiAssistants.map(assistant => 
  assistant.commands.map(cmd => `echo "Installing ${assistant.name}..." && ${cmd}`).join('\n')
).join('\n\n')}

# Configure Cursor
echo "Configuring Cursor..."
mkdir -p ~/.cursor/config
cat > ~/.cursor/config/ai-config.json << 'EOF'
${JSON.stringify(INSTALL_CONFIG.cursorConfig, null, 2)}
EOF

# Start AI services
echo "Starting AI services..."
nohup cursor --ai-service > /tmp/cursor-ai.log 2>&1 &

echo "Installation completed successfully!"
`;

    return script;
  }

  async installAssistant(assistant) {
    console.log(`Installing ${assistant.name}...`);
    
    try {
      // Execute installation commands
      for (const command of assistant.commands) {
        console.log(`  Executing: ${command}`);
        execSync(command, { stdio: 'inherit' });
      }
      
      // Create configuration
      await this.createAssistantConfig(assistant);
      
      this.installedAssistants.set(assistant.name, {
        ...assistant,
        installedAt: Date.now(),
        status: 'active'
      });
      
      console.log(`  âœ… ${assistant.name} installed successfully`);
      
    } catch (error) {
      console.error(`  âŒ Failed to install ${assistant.name}:`, error.message);
      throw error;
    }
  }

  async createAssistantConfig(assistant) {
    const configDir = path.join(os.homedir(), '.cursor', 'config', 'assistants');
    
    // Ensure config directory exists
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    
    const configPath = path.join(configDir, `${assistant.name}.json`);
    const config = {
      name: assistant.name,
      description: assistant.description,
      config: assistant.config,
      installedAt: Date.now(),
      version: '1.0.0'
    };
    
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
  }

  async configureCursor() {
    console.log('Configuring Cursor...');
    
    const configDir = path.join(os.homedir(), '.cursor', 'config');
    
    // Ensure config directory exists
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    
    // Create main configuration
    const mainConfigPath = path.join(configDir, 'cursor-config.json');
    const mainConfig = {
      ...INSTALL_CONFIG.cursorConfig,
      aiAssistants: Array.from(this.installedAssistants.keys()),
      networkConfig: INSTALL_CONFIG.networkConfig,
      lastConfigured: Date.now()
    };
    
    fs.writeFileSync(mainConfigPath, JSON.stringify(mainConfig, null, 2));
    
    // Create AI service configuration
    const aiServiceConfigPath = path.join(configDir, 'ai-service.json');
    const aiServiceConfig = {
      enabled: true,
      assistants: Array.from(this.installedAssistants.values()).map(assistant => ({
        name: assistant.name,
        enabled: true,
        config: assistant.config
      })),
      network: {
        discovery: true,
        communication: true,
        heartbeat: true
      }
    };
    
    fs.writeFileSync(aiServiceConfigPath, JSON.stringify(aiServiceConfig, null, 2));
    
    console.log('  âœ… Cursor configured successfully');
  }

  async startAIServices() {
    console.log('Starting AI services...');
    
    try {
      // Start Cursor AI service
      const aiServiceProcess = spawn('cursor', ['--ai-service'], {
        detached: true,
        stdio: 'ignore'
      });
      
      aiServiceProcess.unref();
      
      // Start network discovery service
      const discoveryProcess = spawn('cursor', ['--discovery-service'], {
        detached: true,
        stdio: 'ignore'
      });
      
      discoveryProcess.unref();
      
      console.log('  âœ… AI services started successfully');
      
    } catch (error) {
      console.error('  âŒ Failed to start AI services:', error.message);
      throw error;
    }
  }

  isCursorInstalled() {
    const cursorPaths = [
      '/Applications/Cursor.app/Contents/MacOS/Cursor',
      'C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Cursor\\Cursor.exe',
      '/usr/bin/cursor',
      '/opt/cursor/cursor'
    ];
    
    for (const cursorPath of cursorPaths) {
      try {
        execSync(`test -f "${cursorPath}"`, { stdio: 'ignore' });
        return true;
      } catch (error) {
        // Continue checking other paths
      }
    }
    
    return false;
  }

  async uploadFile(content, remotePath, ip) {
    // This is a simplified version - in production you'd use scp or rsync
    const tempFile = `/tmp/upload_${Date.now()}`;
    fs.writeFileSync(tempFile, content);
    
    try {
      await this.executeRemoteCommand(ip, `cat > ${remotePath}`, tempFile);
    } finally {
      fs.unlinkSync(tempFile);
    }
  }

  async executeRemoteCommand(ip, command, input = null) {
    return new Promise((resolve, reject) => {
      const ssh = spawn('ssh', [`-o ConnectTimeout=10`, `-o BatchMode=yes`, ip, command]);
      
      let stdout = '';
      let stderr = '';
      
      ssh.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      ssh.stderr.on('data', (data) => {
        stderr += data.toString();
      });
      
      if (input) {
        ssh.stdin.write(input);
        ssh.stdin.end();
      }
      
      ssh.on('close', (code) => {
        if (code === 0) {
          resolve(stdout);
        } else {
          reject(new Error(stderr || `Command failed with code ${code}`));
        }
      });
      
      ssh.on('error', (error) => {
        reject(error);
      });
    });
  }

  async discoverComputers() {
    console.log('Discovering computers with Cursor installed...');
    
    const networkRange = this.getNetworkRange();
    const discoveredComputers = [];
    
    for (const ip of networkRange) {
      try {
        const isCursorInstalled = await this.checkCursorInstallation(ip);
        if (isCursorInstalled) {
          const computerInfo = await this.getComputerInfo(ip);
          discoveredComputers.push(computerInfo);
          console.log(`  Found: ${computerInfo.hostname} (${ip})`);
        }
      } catch (error) {
        // Silently continue - not all IPs will have Cursor
      }
    }
    
    return discoveredComputers;
  }

  getNetworkRange() {
    const interfaces = os.networkInterfaces();
    const ips = [];
    
    for (const [name, nets] of Object.entries(interfaces)) {
      for (const net of nets) {
        if (net.family === 'IPv4' && !net.internal) {
          const baseIP = net.address.split('.').slice(0, 3).join('.');
          // Generate range for subnet
          for (let i = 1; i <= 254; i++) {
            ips.push(`${baseIP}.${i}`);
          }
          break; // Only use first external interface
        }
      }
    }
    
    return ips;
  }

  async checkCursorInstallation(ip) {
    const cursorPaths = [
      '/Applications/Cursor.app/Contents/MacOS/Cursor',
      'C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Cursor\\Cursor.exe',
      '/usr/bin/cursor',
      '/opt/cursor/cursor'
    ];
    
    for (const cursorPath of cursorPaths) {
      try {
        const result = await this.executeRemoteCommand(ip, `test -f "${cursorPath}" && echo "found"`);
        if (result.includes('found')) {
          return true;
        }
      } catch (error) {
        // Continue checking other paths
      }
    }
    
    return false;
  }

  async getComputerInfo(ip) {
    try {
      const hostname = await this.executeRemoteCommand(ip, 'hostname');
      const osInfo = await this.executeRemoteCommand(ip, 'uname -a');
      const cpuInfo = await this.executeRemoteCommand(ip, 'nproc');
      const memoryInfo = await this.executeRemoteCommand(ip, 'free -h');
      
      return {
        ip,
        hostname: hostname.trim(),
        os: osInfo.trim(),
        cpuCores: parseInt(cpuInfo.trim()),
        memory: memoryInfo.trim(),
        status: 'online'
      };
    } catch (error) {
      return {
        ip,
        hostname: 'unknown',
        os: 'unknown',
        cpuCores: 0,
        memory: 'unknown',
        status: 'error'
      };
    }
  }

  async verifyInstallation() {
    console.log('Verifying installation...');
    
    const verificationResults = [];
    
    for (const [name, assistant] of this.installedAssistants) {
      try {
        const isWorking = await this.verifyAssistant(name);
        verificationResults.push({
          name,
          status: isWorking ? 'working' : 'not_working',
          verifiedAt: Date.now()
        });
        
        console.log(`  ${isWorking ? 'âœ…' : 'âŒ'} ${name}: ${isWorking ? 'Working' : 'Not working'}`);
        
      } catch (error) {
        verificationResults.push({
          name,
          status: 'error',
          error: error.message,
          verifiedAt: Date.now()
        });
        
        console.log(`  âŒ ${name}: Error - ${error.message}`);
      }
    }
    
    return verificationResults;
  }

  async verifyAssistant(name) {
    try {
      // Check if assistant is responding
      const result = execSync(`cursor --ai-test ${name}`, { 
        encoding: 'utf8',
        timeout: 10000 
      });
      
      return result.includes('success') || result.includes('working');
      
    } catch (error) {
      return false;
    }
  }

  async generateReport() {
    const report = {
      timestamp: Date.now(),
      installation: {
        totalAssistants: INSTALL_CONFIG.aiAssistants.length,
        installedAssistants: Array.from(this.installedAssistants.keys()),
        installationLog: this.installationLog
      },
      configuration: {
        cursorConfig: INSTALL_CONFIG.cursorConfig,
        networkConfig: INSTALL_CONFIG.networkConfig
      },
      status: {
        aiServices: 'running',
        networkDiscovery: 'active',
        continuousImprovement: 'enabled'
      }
    };
    
    const reportPath = path.join(process.cwd(), 'logs', 'cursor-ai-installation-report.json');
    
    // Ensure logs directory exists
    const logsDir = path.dirname(reportPath);
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }
    
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    console.log(`ðŸ“Š Installation report saved to: ${reportPath}`);
    
    return report;
  }
}

// CLI interface
if (require.main === module) {
  const installer = new CursorAIInstaller();
  
  const args = process.argv.slice(2);
  const command = args[0];
  
  async function main() {
    try {
      switch (command) {
        case 'install-local':
          await installer.installOnLocalComputer();
          break;
          
        case 'discover':
          const computers = await installer.discoverComputers();
          console.log(`Found ${computers.length} computers with Cursor installed`);
          break;
          
        case 'install-remote':
          const computerList = args.slice(1).map(ip => ({ ip, hostname: ip }));
          const results = await installer.installOnRemoteComputers(computerList);
          console.log(`Installation completed: ${results.filter(r => r.success).length}/${results.length} successful`);
          break;
          
        case 'verify':
          await installer.verifyInstallation();
          break;
          
        case 'report':
          await installer.generateReport();
          break;
          
        default:
          console.log(`
Cursor AI Installer

Usage:
  node cursor-ai-installer.cjs install-local          Install AI assistants on local computer
  node cursor-ai-installer.cjs discover               Discover computers with Cursor installed
  node cursor-ai-installer.cjs install-remote <ip>    Install AI assistants on remote computer
  node cursor-ai-installer.cjs verify                 Verify installation
  node cursor-ai-installer.cjs report                 Generate installation report

Examples:
  node cursor-ai-installer.cjs install-local
  node cursor-ai-installer.cjs install-remote 192.168.1.100
  node cursor-ai-installer.cjs install-remote 192.168.1.100 192.168.1.101
          `);
      }
    } catch (error) {
      console.error('Error:', error.message);
      process.exit(1);
    }
  }
  
  main();
}

module.exports = { CursorAIInstaller, INSTALL_CONFIG }; 