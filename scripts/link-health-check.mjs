#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import https from 'https';
import http from 'http';

function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) fs.mkdirSync(dirPath, { recursive: true });
}

function findFiles(dir, exts, acc = []) {
  for (const name of fs.readdirSync(dir)) {
    const p = path.join(dir, name);
    const stat = fs.statSync(p);
    if (stat.isDirectory()) findFiles(p, exts, acc);
    else if (exts.includes(path.extname(name))) acc.push(p);
  }
  return acc;
}

function extractLinks(content) {
  const links = new Set();
  const hrefRegex = /href=\"([^\"]+)\"/g;
  const mdRegex = /\]\((https?:[^\)]+)\)/g;
  let m;
  while ((m = hrefRegex.exec(content))) links.add(m[1]);
  while ((m = mdRegex.exec(content))) links.add(m[1]);
  return Array.from(links);
}

function head(url) {
  return new Promise((resolve) => {
    try {
      const lib = url.startsWith('https') ? https : http;
      const req = lib.request(url, { method: 'HEAD', timeout: 8000 }, (res) => {
        resolve({ url, status: res.statusCode || 0 });
        res.resume();
      });
      req.on('error', () => resolve({ url, status: 0 }));
      req.on('timeout', () => { req.destroy(); resolve({ url, status: 0 }); });
      req.end();
    } catch {
      resolve({ url, status: 0 });
    }
  });
}

async function main() {
  const roots = ['pages', 'docs'];
  const files = roots.flatMap((r) => (fs.existsSync(r) ? findFiles(r, ['.tsx', '.md', '.mdx']) : []));
  const links = new Set();
  for (const file of files) {
    try {
      const content = fs.readFileSync(file, 'utf8');
      extractLinks(content).forEach((l) => { if (l.startsWith('http')) links.add(l); });
    } catch {}
  }
  const urls = Array.from(links).slice(0, 200); // cap for speed
  const results = [];
  for (const u of urls) results.push(await head(u));

  const broken = results.filter((r) => r.status >= 400 || r.status === 0);
  const ok = results.length - broken.length;
  const md = [
    '# Link Health (Autonomous)',
    '',
    `Checked: ${results.length} links. OK: ${ok}. Broken: ${broken.length}.`,
    '',
    '## Broken Links',
    '',
    ...broken.map((b) => `- ${b.url} [status: ${b.status}]`),
    '',
    '> Generated by Autonomous Link Health Checker',
  ].join('\n');

  ensureDir('docs');
  fs.writeFileSync(path.join('docs', 'LINK_HEALTH.md'), md, 'utf8');
  ensureDir(path.join('public', 'autonomy'));
  fs.writeFileSync(path.join('public', 'autonomy', 'LINK_HEALTH.md'), md, 'utf8');
  ensureDir('automation_logs');
  const id = new Date().toISOString().replace(/[:.]/g, '-').toLowerCase();
  fs.writeFileSync(path.join('automation_logs', `link-health-${id}.json`), JSON.stringify({ generatedAt: new Date().toISOString(), total: results.length, broken: broken.length }, null, 2));
  console.log('Wrote docs/LINK_HEALTH.md, public/autonomy/LINK_HEALTH.md and link health log');
}

main();